{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"local_florist Assembly local_florist A Pythonic Object-Oriented Web Framework built on Flask About Assembly is a pythonic object-oriented, mid stack, batteries included framework built on Flask, that adds structure to your Flask application, and group your routes by class. Assembly allows developers to build web applications in much the same way they would build any other object-oriented Python program. Technically Assembly is an attempt of making a simple framework based on Flask Great Again! Installation Guide Quick Start This quickstart will allow us to go with Assembly from 0 to 100! 1. Install Assembly Install Assembly with pip install assembly It is highly recommended to use a virtualenv, in this case let's use VirtualenvWrapper (you can use any that is convenient for you) mkvirtualenv my - first - app workon my - first - app pip install assembly 2. Initialize your application Initialize Assembly with asm-admin init CD into the folder you intend to create the application, then run asm-admin init . This will setup the structure along with the necessary files to get started cd app - dir asm - admin init Upon initialization you should have a structure similar to this: -- / |- wsgi . py |- config . py |- requirements . txt |- main |- __init__ . py |- __models__ . py |- templates |- Index |- index . html |- layouts |- base . html |- static |- cli . py |- __data__ / 3. Edit your first view # main/__init__.py from assembly import ( Assembly , response ) class Index ( Assembly ): index ( self ): return { \"title\" : \"Assembly is awesome\" , \"content\" : \"That is a true fact\" } @response.json api ( self ): return { \"name\" : \"Assembly\" , \"version\" : \"x-to-infinity\" } 4. Edit your template 4.0 Edit base layout <!-- main/templates/layouts/base.html --> <!doctype html> <html lang= \"en\" > <head> <title> {% block title %}{% endblock %} </title> </head> <body> <div class= \"container\" > {% block body %}{% endblock %} </div> </body> </html> 4.1 Edit Index/index.html <!-- main/templates/Index/index.html --> {% extends 'main/layouts/base.html' %} {% block title %} Welcome to my Assembly Site {% endblock %} {% block body %} <div> <h1> {{ title }} </h1> </div> <div> {{ content }} </div> {% endblock %} 5. Serve your first application If everything is all set, all you need to do now is run your site: asm - admin serve It will start serving your application by default at 127.0.0.1:5000 Two endpoints will be available: http://127.0.0.1:5000/ which will show an HTML http://127.0.0.1:5000/api/ which will a json response Features List Smart routing: automatically generates routes based on the classes and methods in your views Class name as the base url, ie: class UserAccount will be accessed at '/user-account' Class methods (action) could be accessed: hello_world(self) becomes 'hello-world' RESTful API Automatic view rendering Auto route can be edited with @route() Markdown friendly. Inclusion of a markdown file will turn into HTML BCRYPT is chosen as the password hasher Session: Redis, AWS S3, Google Storage, SQLite, MySQL, PostgreSQL Database/ORM: Active-Alchemy (SQLALchemy wrapper) CSRF on all POST Idiomatic HTTP error responses Storage: Local, S3, Google Storage Flask-Cloudy Mailer (SES or SMTP) Arrow for date and time Caching JWT Pagination Signals: to dispatch messages and data to other part of the application Markdown Jinja2 for templating language Multi application Web Assets CLI Inbuilt development server Credits: Flask, Flask-Classy","title":"Overview"},{"location":"#about","text":"Assembly is a pythonic object-oriented, mid stack, batteries included framework built on Flask, that adds structure to your Flask application, and group your routes by class. Assembly allows developers to build web applications in much the same way they would build any other object-oriented Python program. Technically Assembly is an attempt of making a simple framework based on Flask Great Again! Installation Guide","title":"About"},{"location":"#quick-start","text":"This quickstart will allow us to go with Assembly from 0 to 100!","title":"Quick Start"},{"location":"#1-install-assembly","text":"Install Assembly with pip install assembly It is highly recommended to use a virtualenv, in this case let's use VirtualenvWrapper (you can use any that is convenient for you) mkvirtualenv my - first - app workon my - first - app pip install assembly","title":"1. Install Assembly"},{"location":"#2-initialize-your-application","text":"Initialize Assembly with asm-admin init CD into the folder you intend to create the application, then run asm-admin init . This will setup the structure along with the necessary files to get started cd app - dir asm - admin init Upon initialization you should have a structure similar to this: -- / |- wsgi . py |- config . py |- requirements . txt |- main |- __init__ . py |- __models__ . py |- templates |- Index |- index . html |- layouts |- base . html |- static |- cli . py |- __data__ /","title":"2. Initialize your application"},{"location":"#3-edit-your-first-view","text":"# main/__init__.py from assembly import ( Assembly , response ) class Index ( Assembly ): index ( self ): return { \"title\" : \"Assembly is awesome\" , \"content\" : \"That is a true fact\" } @response.json api ( self ): return { \"name\" : \"Assembly\" , \"version\" : \"x-to-infinity\" }","title":"3. Edit your first view"},{"location":"#4-edit-your-template","text":"","title":"4. Edit your template"},{"location":"#40-edit-base-layout","text":"<!-- main/templates/layouts/base.html --> <!doctype html> <html lang= \"en\" > <head> <title> {% block title %}{% endblock %} </title> </head> <body> <div class= \"container\" > {% block body %}{% endblock %} </div> </body> </html>","title":"4.0 Edit base layout"},{"location":"#41-edit-indexindexhtml","text":"<!-- main/templates/Index/index.html --> {% extends 'main/layouts/base.html' %} {% block title %} Welcome to my Assembly Site {% endblock %} {% block body %} <div> <h1> {{ title }} </h1> </div> <div> {{ content }} </div> {% endblock %}","title":"4.1  Edit Index/index.html"},{"location":"#5-serve-your-first-application","text":"If everything is all set, all you need to do now is run your site: asm - admin serve It will start serving your application by default at 127.0.0.1:5000 Two endpoints will be available: http://127.0.0.1:5000/ which will show an HTML http://127.0.0.1:5000/api/ which will a json response","title":"5. Serve your first application"},{"location":"#features-list","text":"Smart routing: automatically generates routes based on the classes and methods in your views Class name as the base url, ie: class UserAccount will be accessed at '/user-account' Class methods (action) could be accessed: hello_world(self) becomes 'hello-world' RESTful API Automatic view rendering Auto route can be edited with @route() Markdown friendly. Inclusion of a markdown file will turn into HTML BCRYPT is chosen as the password hasher Session: Redis, AWS S3, Google Storage, SQLite, MySQL, PostgreSQL Database/ORM: Active-Alchemy (SQLALchemy wrapper) CSRF on all POST Idiomatic HTTP error responses Storage: Local, S3, Google Storage Flask-Cloudy Mailer (SES or SMTP) Arrow for date and time Caching JWT Pagination Signals: to dispatch messages and data to other part of the application Markdown Jinja2 for templating language Multi application Web Assets CLI Inbuilt development server Credits: Flask, Flask-Classy","title":"Features List"},{"location":"architecture/","text":"Overview Assembly tries to keep it simple by providing a flat structure for your application and gives you the freedom to do whatever else. It lays out a basic layout, so the application can be consistent. Structure A basic application structure looks like this -- / |- wsgi . py |- config . py |- requirements . txt |- app . json |- __data__ |- main |- __init__ . py |- __models__ . py |- templates |- Index |- index . html |- layouts |- base . html |- static |- cli . py Base files Base files are at the root of the application. And wsgi.py , config.py are required by Assembly. -- / |- wsgi . py |- config . py |- requirements . txt |- app . json |- __data__ wsgi.py is the application object. (required) config.py : contains class based configurations (required) requirements.txt : contains application dependencies including assembly app.json : Application manifest to deploy using Gokku __data__ : A variable directory, to put misc files, uploads, etc. View Package Structure View Package are simply a package/directory that contains at least __init__.py and can be imported into the APPS list in the wsgi.py file. Additionally, you can find __models__.py , templates/ , static/ The view name is the folder. The example below show the main view. |- main |- __init__ . py |- __models__ . py |- templates |- Index |- index . html |- layouts |- base . html |- static |- cli . py main view directory __init__.py contains all the View classes __models__.py contains all the Models for that View templates contains templates for the each endpoint in the View classes static contain the static files, images, css, js, etc. cli.py Custom CLI for that view. __init__.py , __models__.py , templates/ , static/ will be loaded implicitely by Assemby. Only __init__.py is required. __init__.py is also served as files containing all the view classes. View Class structure You can place your view classes in __init__.py . Assembly will automatically load them when they are added in the APPS list. Aside from importing the assembly package, nothing special needs to be done in the View. Just work on your application like you would in your normal Python file. As a matter of fact this is a normal Python file. # main/__init__ from assembly import Assembly class Index ( Assembly ): def index ( self ): return Multiple Classes It's ok to have multiple classes in your View. They will be treated properly with the proper endpoint. # main/__init__ from assembly import Assembly , request # responds to / class Index ( Assembly ): index ( self ): return # responds to /api/ class Api ( Assembly ): index ( self ): return # responds to /admin/ class Admin ( Assembly ): index ( self ): return Namespace Everything is properly namespaced, however the only time you may have some clashes is when more than one class has the same class name. To fix that, just use a different route name for the class base. # main/__init__ from assembly import Assembly # responds to / class Index ( Assembly ): index ( self ): return --- # admin/__init__ from assembly import Assembly , request # responds to /admin/ @request.route ( \"/admin/\" ) class Index ( Assembly ): index ( self ): return View Templates Assembly uses Jinja as templating language. Templates are mapped by their class and method name Having a sctructure like this... |- admin |- __init__ . py |- __models__ . py |- templates |- Index |- index . html |- login . html |- Articles |- index . html |- all . html |- static |- cli . py our View class will have # admin/__init__.py from assembly import Assembly class Index ( Assembly ): def index ( self ): return def login ( self ): return class Articles ( Assembly ): def index ( self ): return def all ( self ): return -- View Static Assembly uses Flask-Assets to help manage static assets, ie: images, js, css in your application","title":"Architecture"},{"location":"architecture/#overview","text":"Assembly tries to keep it simple by providing a flat structure for your application and gives you the freedom to do whatever else. It lays out a basic layout, so the application can be consistent.","title":"Overview"},{"location":"architecture/#structure","text":"A basic application structure looks like this -- / |- wsgi . py |- config . py |- requirements . txt |- app . json |- __data__ |- main |- __init__ . py |- __models__ . py |- templates |- Index |- index . html |- layouts |- base . html |- static |- cli . py","title":"Structure"},{"location":"architecture/#base-files","text":"Base files are at the root of the application. And wsgi.py , config.py are required by Assembly. -- / |- wsgi . py |- config . py |- requirements . txt |- app . json |- __data__ wsgi.py is the application object. (required) config.py : contains class based configurations (required) requirements.txt : contains application dependencies including assembly app.json : Application manifest to deploy using Gokku __data__ : A variable directory, to put misc files, uploads, etc.","title":"Base files"},{"location":"architecture/#view-package-structure","text":"View Package are simply a package/directory that contains at least __init__.py and can be imported into the APPS list in the wsgi.py file. Additionally, you can find __models__.py , templates/ , static/ The view name is the folder. The example below show the main view. |- main |- __init__ . py |- __models__ . py |- templates |- Index |- index . html |- layouts |- base . html |- static |- cli . py main view directory __init__.py contains all the View classes __models__.py contains all the Models for that View templates contains templates for the each endpoint in the View classes static contain the static files, images, css, js, etc. cli.py Custom CLI for that view. __init__.py , __models__.py , templates/ , static/ will be loaded implicitely by Assemby. Only __init__.py is required. __init__.py is also served as files containing all the view classes.","title":"View Package Structure"},{"location":"architecture/#view-class-structure","text":"You can place your view classes in __init__.py . Assembly will automatically load them when they are added in the APPS list. Aside from importing the assembly package, nothing special needs to be done in the View. Just work on your application like you would in your normal Python file. As a matter of fact this is a normal Python file. # main/__init__ from assembly import Assembly class Index ( Assembly ): def index ( self ): return","title":"View Class structure"},{"location":"architecture/#multiple-classes","text":"It's ok to have multiple classes in your View. They will be treated properly with the proper endpoint. # main/__init__ from assembly import Assembly , request # responds to / class Index ( Assembly ): index ( self ): return # responds to /api/ class Api ( Assembly ): index ( self ): return # responds to /admin/ class Admin ( Assembly ): index ( self ): return","title":"Multiple Classes"},{"location":"architecture/#namespace","text":"Everything is properly namespaced, however the only time you may have some clashes is when more than one class has the same class name. To fix that, just use a different route name for the class base. # main/__init__ from assembly import Assembly # responds to / class Index ( Assembly ): index ( self ): return --- # admin/__init__ from assembly import Assembly , request # responds to /admin/ @request.route ( \"/admin/\" ) class Index ( Assembly ): index ( self ): return","title":"Namespace"},{"location":"architecture/#view-templates","text":"Assembly uses Jinja as templating language. Templates are mapped by their class and method name Having a sctructure like this... |- admin |- __init__ . py |- __models__ . py |- templates |- Index |- index . html |- login . html |- Articles |- index . html |- all . html |- static |- cli . py our View class will have # admin/__init__.py from assembly import Assembly class Index ( Assembly ): def index ( self ): return def login ( self ): return class Articles ( Assembly ): def index ( self ): return def all ( self ): return --","title":"View Templates"},{"location":"architecture/#view-static","text":"Assembly uses Flask-Assets to help manage static assets, ie: images, js, css in your application","title":"View Static"},{"location":"cli/","text":"Overview Assembly provides a CLI tool and framework based on Click library Extension: Click Usage Upon installing Assembly via pip install assembly , two commands will be available for the command line: asm : for custom command list asm-admin : for Assembly specific commands Admin CLI: asm-admin This command allows you to access Assembly specific commands init To initialize Assembly for the first time in the current directory cd my - dir asm - admin init serve To run the development server. asm - admin serve or changing environment export ASSEMBLY_ENV = Staging asm - admin serve or changing environment and app export ASSEMBLY_ENV = Testing export ASSEMBLY_APP = api asm - admin serve sync-models To sync database models to create new tables. Models that extended db.Model will be created. asm - admin sync - models gen-api-view To create a view that can be used as API endpoint asm - admin gen - api - view $ view - name ie: asm - admin gen - api - view api It will create a new view at the root. gen-template-view To create a view that contains template asm - admin gen - template - view $ view - name ie: asm - admin gen - api - view admin It will create a new view admin at the root. upload-assets-s3 If you are serving your assets via CDN or S3, you need to upload them before deploying the application. When config.ASSETS_DELIVERY_METHOD is S3 , this util will allow you to upload your assets to S3, and the application will automatically point all your assets to S3. asm - admin upload - assets - s3 version Return the version of Assembly asm - admin version Custom CLI: asm Assembly also allows you to create your own CLI scripts, to use with your application. You probably need CLI to run some routines and setup outside of the web environment, ie: setup database, run worker/task, cronjob, scheduler, etc... 1. Create CLI Functions Assembly CLI is based on Click library. Inside of your view, create cli.py (named so for discoverability). NOTE: @command is the alias to the custom command. Use it, otherwise your CLI scripts won't be available. Learn more about Click # main/cli.py from assembly.cli import ( command , option , argument , click ) @command def hello (): print ( \"Hello world!\" ) @command ( 'do-something' ) @argument ( name ) def do_something ( name ): print ( \"Hello %s \" % name ) 2. Import in wsgi.py # wsgi.py from assembly import Assembly #->>> Import your CLI in the wsgi.py import admin.cli APPS = { \"default\" : [ \"main\" ] } app = Assembly . init ( __name__ , APPS ) 3. Execute Commands Commands can easily be executed by invoking asm followed by the name of the function that had @command Example: # main/cli.py from assembly.cli import ( command , option , argument , click ) @command def hello (): print ( \"Hello world!\" ) >> asm hello @command ( 'do-something' ) @argument ( name ) def do_something ( name ): print ( \"Hello %s \" % name ) >> asm do - something Assembly it will print out : `Hello Assembly`","title":"CLI"},{"location":"cli/#overview","text":"Assembly provides a CLI tool and framework based on Click library Extension: Click","title":"Overview"},{"location":"cli/#usage","text":"Upon installing Assembly via pip install assembly , two commands will be available for the command line: asm : for custom command list asm-admin : for Assembly specific commands","title":"Usage"},{"location":"cli/#admin-cli-asm-admin","text":"This command allows you to access Assembly specific commands","title":"Admin CLI: asm-admin"},{"location":"cli/#init","text":"To initialize Assembly for the first time in the current directory cd my - dir asm - admin init","title":"init"},{"location":"cli/#serve","text":"To run the development server. asm - admin serve or changing environment export ASSEMBLY_ENV = Staging asm - admin serve or changing environment and app export ASSEMBLY_ENV = Testing export ASSEMBLY_APP = api asm - admin serve","title":"serve"},{"location":"cli/#sync-models","text":"To sync database models to create new tables. Models that extended db.Model will be created. asm - admin sync - models","title":"sync-models"},{"location":"cli/#gen-api-view","text":"To create a view that can be used as API endpoint asm - admin gen - api - view $ view - name ie: asm - admin gen - api - view api It will create a new view at the root.","title":"gen-api-view"},{"location":"cli/#gen-template-view","text":"To create a view that contains template asm - admin gen - template - view $ view - name ie: asm - admin gen - api - view admin It will create a new view admin at the root.","title":"gen-template-view"},{"location":"cli/#upload-assets-s3","text":"If you are serving your assets via CDN or S3, you need to upload them before deploying the application. When config.ASSETS_DELIVERY_METHOD is S3 , this util will allow you to upload your assets to S3, and the application will automatically point all your assets to S3. asm - admin upload - assets - s3","title":"upload-assets-s3"},{"location":"cli/#version","text":"Return the version of Assembly asm - admin version","title":"version"},{"location":"cli/#custom-cli-asm","text":"Assembly also allows you to create your own CLI scripts, to use with your application. You probably need CLI to run some routines and setup outside of the web environment, ie: setup database, run worker/task, cronjob, scheduler, etc...","title":"Custom CLI: asm"},{"location":"cli/#1-create-cli-functions","text":"Assembly CLI is based on Click library. Inside of your view, create cli.py (named so for discoverability). NOTE: @command is the alias to the custom command. Use it, otherwise your CLI scripts won't be available. Learn more about Click # main/cli.py from assembly.cli import ( command , option , argument , click ) @command def hello (): print ( \"Hello world!\" ) @command ( 'do-something' ) @argument ( name ) def do_something ( name ): print ( \"Hello %s \" % name )","title":"1. Create CLI Functions"},{"location":"cli/#2-import-in-wsgipy","text":"# wsgi.py from assembly import Assembly #->>> Import your CLI in the wsgi.py import admin.cli APPS = { \"default\" : [ \"main\" ] } app = Assembly . init ( __name__ , APPS )","title":"2. Import in wsgi.py"},{"location":"cli/#3-execute-commands","text":"Commands can easily be executed by invoking asm followed by the name of the function that had @command Example: # main/cli.py from assembly.cli import ( command , option , argument , click ) @command def hello (): print ( \"Hello world!\" ) >> asm hello @command ( 'do-something' ) @argument ( name ) def do_something ( name ): print ( \"Hello %s \" % name ) >> asm do - something Assembly it will print out : `Hello Assembly`","title":"3. Execute Commands"},{"location":"config/","text":"Overview ./config.py contains class-based configurations. This file must exist at the root of the application where wsgi.py exists. It is recommended to have a base class, BaseConfig , and your environment classes Development , Production which are subclasses of the BaseConfig , this way they can share some common config. The environment classes will be loaded on Assembly startup. By default, and in development, Assembly will attempt to load the Development if one isn't provided. To switch to a different config, you have to set the environment variable, or in production export ASSEMBLY_ENV = Production export ASSEMBLY_APP = default or to set the application along with the environment ASSEMBLY_ENV = Production ASSEMBLY_APP = default asm - admin serve The code above will load the Production config. One main advantage of having your config like that, is that you have the ability of using different config for different environment, could be for testing, prod, dev, etc. Config Accessor Assembly exposes config to access variable from your config environment. config is a subset of dict, and also has dot notation accessor, where can access variable using the dot notation, ie: config.get('key.val1.val2.val3') Import from assembly import config Usage from assembly import ( Assembly , config ) class Index ( Assembly ): def index ( self ): return { \"version\" : config . get ( \"APPLICATION_VERSION\" ), \"version2\" : config [ \"APPLICATION_VERSION\" ], } As DotNotation from assembly import ( Assembly , config ) class Index ( Assembly ): def index ( self ): return { \"default_date_format\" : config . get ( \"DATE_FORMAT.default\" ) } Class Based Configuration Each class corresponds to an environment that you will be able to use for either 'Development', 'Production', 'Testing', 'Staging' etc. class BaseConf ( object ): \"\"\" That will be default class base, which other classes will extends from \"\"\" APPLICATION_NAME = \"Assembly\" class Development ( BaseConf ): DEBUG = True class Production ( BaseConf ): DEBUG = False class Testing ( BaseConf ): DEBUG = True Select Environment When you are ready to serve your application, set the environment variable ASSEMBLY_ENV to the class name you want to use. Example: export ASSEMBLY_ENV=Production -> for Production export ASSEMBLY_ENV=Staging -> for Staging By default Assembly will load the Development class during development. Default Configurations Assembly uses class-based configuration, and the config will be loaded implicitely. ./config.py is required at the root of the application. # config.py import os # The root dir ROOT_DIR = os . path . dirname ( __file__ ) # Data directory DATA_DIR = os . path . join ( ROOT_DIR , \"__data__\" ) class BaseConfig ( object ): \"\"\" Base configuration \"\"\" #: Site's name or Name of the application APPLICATION_NAME = \"Assembly\" #: The application url APPLICATION_URL = \"\" #: Version of application APPLICATION_VERSION = \"0.0.1\" #: Google Analytics ID GOOGLE_ANALYTICS_ID = \"\" #: Required to setup. This email will have SUPER USER role ADMIN_EMAIL = None #: The address to receive email when using the contact page CONTACT_EMAIL = None #: PAGINATION_PER_PAGE : Total entries to display per page PAGINATION_PER_PAGE = 20 # MAX_CONTENT_LENGTH # If set to a value in bytes, Flask will reject incoming requests with a # content length greater than this by returning a 413 status code MAX_CONTENT_LENGTH = 2 * 1024 * 1024 # To remove whitespace off the HTML result COMPRESS_HTML = False # Data directory DATA_DIR = DATA_DIR #------------------- DATE FORMAT and TIMEZONE ------------- # Arrow is used as date parser # from assembly import date # http://crsmithdev.com/arrow # To view tokens: http://crsmithdev.com/arrow/#tokens # Timezone to use when dealing with date. # Example # date.now().to(config.get(\"TIMEZONE\")) # Timezone TIMEZONE = \"US/Eastern\" # Date format # Dict of dates format # Example # date.now().format(config.get(\"DATE_FORMAT.default\")) DATE_FORMAT = { \"default\" : \"MM/DD/YYYY\" , \"date\" : \"MM/DD/YYYY\" , \"datetime\" : \"MM/DD/YYYY hh:mm a\" , \"time\" : \"hh:mm a\" , \"long_datetime\" : \"dddd, MMMM D, YYYY hh:mm a\" , } #--------- AWS Credentials ---------- #: AWS Credentials # AWS is used by lots of extensions # For: S3, SES Mailer, flask S3. # The AWS Access KEY AWS_ACCESS_KEY_ID = \"\" # Secret Key AWS_SECRET_ACCESS_KEY = \"\" # The bucket name for S3 AWS_S3_BUCKET_NAME = \"\" # The default region name AWS_REGION_NAME = \"us-east-1\" #--------- DATABASES URL ---------- #: DB_URL #: Assembly uses Active-Alchemy to work with DB #: format: engine://USERNAME:PASSWORD@HOST:PORT/DB_NAME DB_URL = \"sqlite://// %s /db.db\" % DATA_DIR #: DB_REDIS_URL #: format: USERNAME:PASSWORD@HOST:PORT DB_REDIS_URL = None #--------- ASSETS DELIVERY ---------- # ASSETS DELIVERY allows to serve static files from S3, Cloudfront or other CDN # The delivery method: # - None: will use the local static files # - S3: Will use AWS S3. By default it will use the bucket name set in AWS_S3_BUCKET_NAME # When S3, AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY are required to upload files # - CDN: To use a CDN. ASSETS_DELIVERY_DOMAIN need to have the CDN domain ASSETS_DELIVERY_METHOD = None # Set the base domain of the CDN ASSETS_DELIVERY_DOMAIN = None #--------- SESSION ---------- #: SESSION #: Flask-KVSession is used to save the user's session #: Set the SESSION_URL by using these examples below to set KVSession #: To use local session, just set SESSION_URL to None #: #: Redis: redis://username:password@host:6379/db #: S3: s3://username:password@s3.aws.amazon.com/bucket #: Google Storage: google_storage://username:password@cloud.google.com/bucket #: SQL: postgresql://username:password@host:3306/db #: mysql+pysql://username:password@host:3306/db #: sqlite:// #: Memcached: memcache://host:port #: SESSION_URL = None #--------- STORAGE ---------- #: STORAGE #: Flask-Cloudy is used to save upload on S3, Google Storage, #: Cloudfiles, Azure Blobs, and Local storage #: When using local storage, they can be accessed via http://yoursite/files #: #: STORAGE_PROVIDER: # The provider to use. By default it's 'LOCAL'. # You can use: # LOCAL, S3, GOOGLE_STORAGE, AZURE_BLOBS, CLOUDFILES STORAGE_PROVIDER = \"LOCAL\" #: STORAGE_KEY # The storage key. Leave it blank if PROVIDER is LOCAL STORAGE_KEY = AWS_ACCESS_KEY_ID #: STORAGE_SECRET #: The storage secret key. Leave it blank if PROVIDER is LOCAL STORAGE_SECRET = AWS_SECRET_ACCESS_KEY #: STORAGE_REGION_NAME #: The region for the storage. Leave it blank if PROVIDER is LOCAL STORAGE_REGION_NAME = AWS_REGION_NAME #: STORAGE_CONTAINER #: The Bucket name (for S3, Google storage, Azure, cloudfile) #: or the directory name (LOCAL) to access STORAGE_CONTAINER = os . path . join ( DATA_DIR , \"uploads\" ) #: STORAGE_SERVER #: Bool, to serve local file STORAGE_SERVER = True #: STORAGE_SERVER_URL #: The url suffix for local storage STORAGE_SERVER_URL = \"files\" #:STORAGE_UPLOAD_FILE_PROPS #: A convenient K/V properties for storage.upload to use when using `upload_file()` #: It contains common properties that can passed into the upload function #: ie: upload_file(\"profile-image\", file) STORAGE_UPLOAD_FILE_PROPS = { # To upload regular images \"image\" : { \"extensions\" : [ \"jpg\" , \"png\" , \"gif\" , \"jpeg\" ], \"public\" : True }, # To upload profile image \"profile-image\" : { \"prefix\" : \"profile-image/\" , \"extensions\" : [ \"jpg\" , \"png\" , \"gif\" , \"jpeg\" ], \"public\" : True } } #--------- MAIL ---------- # To send emails # AWS SES # To use AWS SES to send email #: #: - To use the default AWS credentials (AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY) #: set MAIL_URL = \"ses://\" #: * To use a different credential: #: set MAIL_URL = \"ses://{access_key}:{secret_key}@{region}\" #: #: *** uncomment if you are using SMTP instead # MAIL_URL = \"ses://\" # SMTP #: If you are using SMTP, it will use Flask-Mail #: The uri for the smtp connection. It will use Flask-Mail #: format: smtp://USERNAME:PASSWORD@HOST:PORT #: with sll -> smtp+ssl://USERNAME:PASSWORD@HOST:PORT #: with ssl and tls -> smtp+ssl+tls://USERNAME:PASSWORD@HOST:PORT #: #: *** comment out if you are using SES instead # MAIL_URL = \"smtp+ssl://{username}:{password}@{host}:{port}\"\\ # .format(username=\"\", password=\"\", host=\"smtp.gmail.com\", port=465) #: MAIL_SENDER - The sender of the email by default #: For SES, this email must be authorized MAIL_SENDER = ADMIN_EMAIL #: MAIL_REPLY_TO #: The email to reply to by default MAIL_REPLY_TO = ADMIN_EMAIL #: MAIL_TEMPLATE #: a directory that contains the email template or a dict MAIL_TEMPLATE = os . path . join ( DATA_DIR , 'mail-templates' ) #: MAIL_TEMPLATE_CONTEXT #: a dict of all context to pass to the email by default MAIL_TEMPLATE_CONTEXT = { \"params\" : { \"site_name\" : APPLICATION_NAME , \"site_url\" : APPLICATION_URL } } #--------- CACHING ---------- #: Flask-Cache is used to caching #: CACHE_TYPE #: The type of cache to use #: null, simple, redis, filesystem, CACHE_TYPE = \"simple\" #: CACHE_REDIS_URL #: If CHACHE_TYPE is 'redis', set the redis uri #: redis://username:password@host:port/db CACHE_REDIS_URL = \"\" #: CACHE_DIR #: Directory to store cache if CACHE_TYPE is filesystem, it will CACHE_DIR = \"\" # -------------------------- ENVIRONMENT BASED CONFIG --------------------------- \"\"\" The environment based config is what will be loaded. By default it will load the development ## 1. Set environment variables export ASSEMBLY_ENV=Development # for development export ASSEMBLY_APP=default ## 2. Run the wsgi wsgi:app ### **for local server asm-admin server \"\"\" class Development ( BaseConfig ): \"\"\" Config for development environment \"\"\" SERVER_NAME = None DEBUG = True SECRET_KEY = \"PLEASE CHANGE ME\" class Production ( BaseConfig ): \"\"\" Config for Production environment \"\"\" SERVER_NAME = None DEBUG = False SECRET_KEY = None COMPRESS_HTML = True","title":"Configuration"},{"location":"config/#overview","text":"./config.py contains class-based configurations. This file must exist at the root of the application where wsgi.py exists. It is recommended to have a base class, BaseConfig , and your environment classes Development , Production which are subclasses of the BaseConfig , this way they can share some common config. The environment classes will be loaded on Assembly startup. By default, and in development, Assembly will attempt to load the Development if one isn't provided. To switch to a different config, you have to set the environment variable, or in production export ASSEMBLY_ENV = Production export ASSEMBLY_APP = default or to set the application along with the environment ASSEMBLY_ENV = Production ASSEMBLY_APP = default asm - admin serve The code above will load the Production config. One main advantage of having your config like that, is that you have the ability of using different config for different environment, could be for testing, prod, dev, etc.","title":"Overview"},{"location":"config/#config-accessor","text":"Assembly exposes config to access variable from your config environment. config is a subset of dict, and also has dot notation accessor, where can access variable using the dot notation, ie: config.get('key.val1.val2.val3')","title":"Config Accessor"},{"location":"config/#import","text":"from assembly import config","title":"Import"},{"location":"config/#usage","text":"from assembly import ( Assembly , config ) class Index ( Assembly ): def index ( self ): return { \"version\" : config . get ( \"APPLICATION_VERSION\" ), \"version2\" : config [ \"APPLICATION_VERSION\" ], } As DotNotation from assembly import ( Assembly , config ) class Index ( Assembly ): def index ( self ): return { \"default_date_format\" : config . get ( \"DATE_FORMAT.default\" ) }","title":"Usage"},{"location":"config/#class-based-configuration","text":"Each class corresponds to an environment that you will be able to use for either 'Development', 'Production', 'Testing', 'Staging' etc. class BaseConf ( object ): \"\"\" That will be default class base, which other classes will extends from \"\"\" APPLICATION_NAME = \"Assembly\" class Development ( BaseConf ): DEBUG = True class Production ( BaseConf ): DEBUG = False class Testing ( BaseConf ): DEBUG = True","title":"Class Based Configuration"},{"location":"config/#select-environment","text":"When you are ready to serve your application, set the environment variable ASSEMBLY_ENV to the class name you want to use. Example: export ASSEMBLY_ENV=Production -> for Production export ASSEMBLY_ENV=Staging -> for Staging By default Assembly will load the Development class during development.","title":"Select Environment"},{"location":"config/#default-configurations","text":"Assembly uses class-based configuration, and the config will be loaded implicitely. ./config.py is required at the root of the application. # config.py import os # The root dir ROOT_DIR = os . path . dirname ( __file__ ) # Data directory DATA_DIR = os . path . join ( ROOT_DIR , \"__data__\" ) class BaseConfig ( object ): \"\"\" Base configuration \"\"\" #: Site's name or Name of the application APPLICATION_NAME = \"Assembly\" #: The application url APPLICATION_URL = \"\" #: Version of application APPLICATION_VERSION = \"0.0.1\" #: Google Analytics ID GOOGLE_ANALYTICS_ID = \"\" #: Required to setup. This email will have SUPER USER role ADMIN_EMAIL = None #: The address to receive email when using the contact page CONTACT_EMAIL = None #: PAGINATION_PER_PAGE : Total entries to display per page PAGINATION_PER_PAGE = 20 # MAX_CONTENT_LENGTH # If set to a value in bytes, Flask will reject incoming requests with a # content length greater than this by returning a 413 status code MAX_CONTENT_LENGTH = 2 * 1024 * 1024 # To remove whitespace off the HTML result COMPRESS_HTML = False # Data directory DATA_DIR = DATA_DIR #------------------- DATE FORMAT and TIMEZONE ------------- # Arrow is used as date parser # from assembly import date # http://crsmithdev.com/arrow # To view tokens: http://crsmithdev.com/arrow/#tokens # Timezone to use when dealing with date. # Example # date.now().to(config.get(\"TIMEZONE\")) # Timezone TIMEZONE = \"US/Eastern\" # Date format # Dict of dates format # Example # date.now().format(config.get(\"DATE_FORMAT.default\")) DATE_FORMAT = { \"default\" : \"MM/DD/YYYY\" , \"date\" : \"MM/DD/YYYY\" , \"datetime\" : \"MM/DD/YYYY hh:mm a\" , \"time\" : \"hh:mm a\" , \"long_datetime\" : \"dddd, MMMM D, YYYY hh:mm a\" , } #--------- AWS Credentials ---------- #: AWS Credentials # AWS is used by lots of extensions # For: S3, SES Mailer, flask S3. # The AWS Access KEY AWS_ACCESS_KEY_ID = \"\" # Secret Key AWS_SECRET_ACCESS_KEY = \"\" # The bucket name for S3 AWS_S3_BUCKET_NAME = \"\" # The default region name AWS_REGION_NAME = \"us-east-1\" #--------- DATABASES URL ---------- #: DB_URL #: Assembly uses Active-Alchemy to work with DB #: format: engine://USERNAME:PASSWORD@HOST:PORT/DB_NAME DB_URL = \"sqlite://// %s /db.db\" % DATA_DIR #: DB_REDIS_URL #: format: USERNAME:PASSWORD@HOST:PORT DB_REDIS_URL = None #--------- ASSETS DELIVERY ---------- # ASSETS DELIVERY allows to serve static files from S3, Cloudfront or other CDN # The delivery method: # - None: will use the local static files # - S3: Will use AWS S3. By default it will use the bucket name set in AWS_S3_BUCKET_NAME # When S3, AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY are required to upload files # - CDN: To use a CDN. ASSETS_DELIVERY_DOMAIN need to have the CDN domain ASSETS_DELIVERY_METHOD = None # Set the base domain of the CDN ASSETS_DELIVERY_DOMAIN = None #--------- SESSION ---------- #: SESSION #: Flask-KVSession is used to save the user's session #: Set the SESSION_URL by using these examples below to set KVSession #: To use local session, just set SESSION_URL to None #: #: Redis: redis://username:password@host:6379/db #: S3: s3://username:password@s3.aws.amazon.com/bucket #: Google Storage: google_storage://username:password@cloud.google.com/bucket #: SQL: postgresql://username:password@host:3306/db #: mysql+pysql://username:password@host:3306/db #: sqlite:// #: Memcached: memcache://host:port #: SESSION_URL = None #--------- STORAGE ---------- #: STORAGE #: Flask-Cloudy is used to save upload on S3, Google Storage, #: Cloudfiles, Azure Blobs, and Local storage #: When using local storage, they can be accessed via http://yoursite/files #: #: STORAGE_PROVIDER: # The provider to use. By default it's 'LOCAL'. # You can use: # LOCAL, S3, GOOGLE_STORAGE, AZURE_BLOBS, CLOUDFILES STORAGE_PROVIDER = \"LOCAL\" #: STORAGE_KEY # The storage key. Leave it blank if PROVIDER is LOCAL STORAGE_KEY = AWS_ACCESS_KEY_ID #: STORAGE_SECRET #: The storage secret key. Leave it blank if PROVIDER is LOCAL STORAGE_SECRET = AWS_SECRET_ACCESS_KEY #: STORAGE_REGION_NAME #: The region for the storage. Leave it blank if PROVIDER is LOCAL STORAGE_REGION_NAME = AWS_REGION_NAME #: STORAGE_CONTAINER #: The Bucket name (for S3, Google storage, Azure, cloudfile) #: or the directory name (LOCAL) to access STORAGE_CONTAINER = os . path . join ( DATA_DIR , \"uploads\" ) #: STORAGE_SERVER #: Bool, to serve local file STORAGE_SERVER = True #: STORAGE_SERVER_URL #: The url suffix for local storage STORAGE_SERVER_URL = \"files\" #:STORAGE_UPLOAD_FILE_PROPS #: A convenient K/V properties for storage.upload to use when using `upload_file()` #: It contains common properties that can passed into the upload function #: ie: upload_file(\"profile-image\", file) STORAGE_UPLOAD_FILE_PROPS = { # To upload regular images \"image\" : { \"extensions\" : [ \"jpg\" , \"png\" , \"gif\" , \"jpeg\" ], \"public\" : True }, # To upload profile image \"profile-image\" : { \"prefix\" : \"profile-image/\" , \"extensions\" : [ \"jpg\" , \"png\" , \"gif\" , \"jpeg\" ], \"public\" : True } } #--------- MAIL ---------- # To send emails # AWS SES # To use AWS SES to send email #: #: - To use the default AWS credentials (AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY) #: set MAIL_URL = \"ses://\" #: * To use a different credential: #: set MAIL_URL = \"ses://{access_key}:{secret_key}@{region}\" #: #: *** uncomment if you are using SMTP instead # MAIL_URL = \"ses://\" # SMTP #: If you are using SMTP, it will use Flask-Mail #: The uri for the smtp connection. It will use Flask-Mail #: format: smtp://USERNAME:PASSWORD@HOST:PORT #: with sll -> smtp+ssl://USERNAME:PASSWORD@HOST:PORT #: with ssl and tls -> smtp+ssl+tls://USERNAME:PASSWORD@HOST:PORT #: #: *** comment out if you are using SES instead # MAIL_URL = \"smtp+ssl://{username}:{password}@{host}:{port}\"\\ # .format(username=\"\", password=\"\", host=\"smtp.gmail.com\", port=465) #: MAIL_SENDER - The sender of the email by default #: For SES, this email must be authorized MAIL_SENDER = ADMIN_EMAIL #: MAIL_REPLY_TO #: The email to reply to by default MAIL_REPLY_TO = ADMIN_EMAIL #: MAIL_TEMPLATE #: a directory that contains the email template or a dict MAIL_TEMPLATE = os . path . join ( DATA_DIR , 'mail-templates' ) #: MAIL_TEMPLATE_CONTEXT #: a dict of all context to pass to the email by default MAIL_TEMPLATE_CONTEXT = { \"params\" : { \"site_name\" : APPLICATION_NAME , \"site_url\" : APPLICATION_URL } } #--------- CACHING ---------- #: Flask-Cache is used to caching #: CACHE_TYPE #: The type of cache to use #: null, simple, redis, filesystem, CACHE_TYPE = \"simple\" #: CACHE_REDIS_URL #: If CHACHE_TYPE is 'redis', set the redis uri #: redis://username:password@host:port/db CACHE_REDIS_URL = \"\" #: CACHE_DIR #: Directory to store cache if CACHE_TYPE is filesystem, it will CACHE_DIR = \"\" # -------------------------- ENVIRONMENT BASED CONFIG --------------------------- \"\"\" The environment based config is what will be loaded. By default it will load the development ## 1. Set environment variables export ASSEMBLY_ENV=Development # for development export ASSEMBLY_APP=default ## 2. Run the wsgi wsgi:app ### **for local server asm-admin server \"\"\" class Development ( BaseConfig ): \"\"\" Config for development environment \"\"\" SERVER_NAME = None DEBUG = True SECRET_KEY = \"PLEASE CHANGE ME\" class Production ( BaseConfig ): \"\"\" Config for Production environment \"\"\" SERVER_NAME = None DEBUG = False SECRET_KEY = None COMPRESS_HTML = True","title":"Default Configurations"},{"location":"deploy/","text":"Deploy Options To get a comprehensive deploy options with Assembly, please follow Deploying Options with Flask. Assembly is actually Flask, so everything on the link is valid for Assembly. Below are some of the options, you would be interested in Gunicorn Gunicorn \u2018Green Unicorn\u2019 is a WSGI HTTP Server for UNIX. It\u2019s a pre-fork worker model ported from Ruby\u2019s Unicorn project. It supports both eventlet and greenlet. gunicorn -w 4 wsgi:app uWSGI uWSGI is a fast application server written in C. It is very configurable which makes it more complicated to setup than gunicorn. uwsgi --http 127.0.0.1:5000 --module wsgi:app Gokku Gokku is a very small PaaS to do git push deployments to your own servers (Digital Ocean, Linode) similar to Heroku. Learn more about Gokku Gokku configuration is already shipped with Assembly, with app.json . The app.json will launch your website from 0 to 100 just like it would on Heroku. At the root of the application, app.json is a manifest format for describing web apps. It declares environment variables, scripts, and other information required to run an app on your server. { \"name\" : \"domain.com\" , \"version\" : \"0.0.1\" , \"description\" : \"my application domain.com\" , \"gokku\" : { \"domain_name\" : \"domain.com\" , \"runtime\" : \"python\" , \"auto_restart\" : true , \"env\" : { \"ASSEMBLY_ENV\" : \"Production\" , \"ASSEMBLY_APP\" : \"default\" } , \"scripts\" : { \"release\" : [ \"asm-admin sync-models\" , \"asm setup\" ] } , \"run\" : { \"web\" : \"wsgi:app\" } } }","title":"Deployment"},{"location":"deploy/#deploy-options","text":"To get a comprehensive deploy options with Assembly, please follow Deploying Options with Flask. Assembly is actually Flask, so everything on the link is valid for Assembly. Below are some of the options, you would be interested in","title":"Deploy Options"},{"location":"deploy/#gunicorn","text":"Gunicorn \u2018Green Unicorn\u2019 is a WSGI HTTP Server for UNIX. It\u2019s a pre-fork worker model ported from Ruby\u2019s Unicorn project. It supports both eventlet and greenlet. gunicorn -w 4 wsgi:app","title":"Gunicorn"},{"location":"deploy/#uwsgi","text":"uWSGI is a fast application server written in C. It is very configurable which makes it more complicated to setup than gunicorn. uwsgi --http 127.0.0.1:5000 --module wsgi:app","title":"uWSGI"},{"location":"deploy/#gokku","text":"Gokku is a very small PaaS to do git push deployments to your own servers (Digital Ocean, Linode) similar to Heroku. Learn more about Gokku Gokku configuration is already shipped with Assembly, with app.json . The app.json will launch your website from 0 to 100 just like it would on Heroku. At the root of the application, app.json is a manifest format for describing web apps. It declares environment variables, scripts, and other information required to run an app on your server. { \"name\" : \"domain.com\" , \"version\" : \"0.0.1\" , \"description\" : \"my application domain.com\" , \"gokku\" : { \"domain_name\" : \"domain.com\" , \"runtime\" : \"python\" , \"auto_restart\" : true , \"env\" : { \"ASSEMBLY_ENV\" : \"Production\" , \"ASSEMBLY_APP\" : \"default\" } , \"scripts\" : { \"release\" : [ \"asm-admin sync-models\" , \"asm setup\" ] } , \"run\" : { \"web\" : \"wsgi:app\" } } }","title":"Gokku"},{"location":"first-app/","text":"If you haven't done so yet, you need to mocha :init in the directory that you want to install mocha : init Once created, you should see a file structure similar to this / ____ | |- brew . py | |- propel . yml | | -- requirements.txt | | -- /application | | -- config.py | | -- models.py | | -- helpers.py | | -- manage.py | | -- views/ | | -- main.py | | -- templates/ | | -- layouts/ | | -- base.jade | | -- main/ | | -- Index/ | | -- index.jade | | -- /static/ | | -- assets.yml | | -- package.json | | -- css/ | | -- js/ | | -- imgs/ | | -- /var/ Description: brew.py is the application entry point propel.yml (optional) A deploy based config file requirements.txt contains your requirements + mocha application/ contains the application's models, config, helpers and manage application/views/ : contains your views modules application/templates/ : contains all templates relative to the views name application/static/ : contains all the app's assets: js, css, imgs, etc... application/var/ : contains var files: database, mail-template, uploads, etc... Your first app Here's what Mocha will do, and expecting: that your views are structured in class the class inherits mocha.Mocha if the class name is Index(Mocha) , it will be the base route as / the methods are the views actions the methods name will become the endpoint url if the method name is index(self) , it will be the entry point of that view methods name with underscore will be dasherized, about_us(self) -> /about-us/ the methods return data as dict type the data returned is passed to your template the template is named after the method name the template is magically included in your layout Mocha brews everything together, and renders the page Views All your view module should be placed in application/views . By default , main.py view is created main.py must contain at a least one class that inherits Mocha . A view module may have multiple classes application/views/main.py from mocha import Mocha , page_attr class Index ( Mocha ): def index ( self ): page_attr ( \"Hello World\" ) return { \"name\" : \"Mocha\" , \"version\" : \"1.0\" } def about_us ( self ): page_attr ( \"About Us\" ) return class Document ( Mocha ): def index ( self ): page_attr ( 'All documents' ) return { \"docs\" : [ { \"id\" : 1 , \"title\" : \"This is a doc title\" }, ... ] } def get ( self , id ): page_attr ( \"This is a doc title\" ) return { \"id\" : id , \"title\" : \"This is a doc title\" , \"content\" : \"My content\" } The main.py module contains two view classes: Index and Document that inherit Mocha . Also imported page_attr , a utility function to set the page title and other page attributes The methods return dict or None The route will be created from the class and method name. If the class name is Index , it will be the root of the domain, in this example / , and other will stay as is, in this instance the Document will have as route /document/ . The following url will be created: Index:index() -> http://localhost:5000/ Index:about_us() -> http://localhost:5000/about-us Document:index() -> http://localhost:5000/document Document:get(id) -> http://localhost:5000/document/1234 Template All your templates should be placed in application/templates . And must follow the same directory structure relative to the view modules. The returned data from the view will be passed to the template. So for application/views/main.py , it is expecting the following template structure / application | | -- templates | | | -- main/ | | -- Index/ | | -- index.jade | | -- about_us.jade | | __ Document / | | -- index.jade | | -- get.jade As you can see, the template structure follows the view structure, where in the view: main.py -> /templates/main main.py:Index() -> templates/main/Index main.py:Index(Mocha):index(self) -> templates/main/Index/index.jade main.py:Index(Mocha):about_us(self) -> templates/main/Index/about_us.jade main.py:Document() -> templates/main/Document main.py:Document(Mocha):index(self) -> templates/main/Document/index.jade main.py:Document(Mocha):get(self) -> templates/main/Document/get.jade Also, you may have noticed that we use .jade template instead of HTML, just for aesthetic, as it looks like python on the templates side. But HTML can also be used. templates/main/Index/index.jade .row .col-md-12.text-center h2 = name small = version Which will be translated into html <div class= \"row\" > <div class= \"col-md-12 text-center\" > <h2> Mocha <small> 1.0 </small></h2> </div> </div> templates/main/Document/index.jade . row . col - md - 12 ul for doc in docs li : a ( href = url_for ( ' views.main.Document:get ' , id = doc . id )) = doc . title Will be translated into html <div class= \"row\" > <div class= \"col-md-12\" > <ul> <li><a href= '/document/1' > This is a doc title </a></li> </ul> </div> </div> Layout By default, layouts are placed in application/templates/layouts , and upon rendering Mocha will glue your view in the layout. The default layout is at: application/templates/layouts/base.jade While you can have extends in your templates, Mocha makes it easy to bypass the repetitive tasks, so you can fully focus on that one page you are working on. - import \"contrib/components/html.html\" as html with context - import \"contrib/components/nav.jade\" as nav with context - import \"contrib/components/forms.html\" as forms with context - import \"contrib/components/widget.html\" as widget with context !!! 5 html ( lang = \"en\" ) head meta ( charset = \"utf-8\" ) meta ( name = \"viewport\" , content = \"width=device-width, initial-scale=1.0\" ) + html . page_title () + html . page_description () + html . opengraph () + html . favicon ( \"favicon.ico\" ) + html . include_jquery () + html . include_bootstrap () + html . include_fontawesome () + html . include_bootswatch_theme ( 'yeti' ) + html . include_css_file ( \"commons.css\" ) + html . include_css_file ( \"styles.css\" ) + html . include_js_file ( \"app.js\" ) + html . google_analytics () body . container - include __template__ footer . container - fluid . row . col - md - 12 . text - center . & copy ; {{ g . __YEAR__ }} {{ config . APPLICATION_NAME }} {{ config . APPLICATION_VERSION }} The most important part of the layout is include __template__ . This where the view template will be injected. There are much more stuff going on it the template, we can tackle them later. Static Static hold your assets: js, css, images. They must be placed in /application/static/ Mocha uses Flask-Assets to manage your assets. Therefor assets.yml is a bundle collection, that allows you to bundle css or js together. assets.yml styles . css : output : \"gen/styles.css\" contents : - css / style . css app . js : output : \"gen/app.js\" contents : - js / app . js And in your template you can call it + html . include_css_file ( \"style.css\" ) + html . include_js_file ( \"app.js\" ) As a convenience, we include a package.json if you want to download 3rd party scripts (js, css). You can either run npm install in static directory, or run mocha :install-assets , which will install your assets in the node_modules Serve Now we are done with our application, all we need to do is serve it. mocha : serve The command above will run brew.py brew.py is the entry point of the application. from mocha import Brew projects = { \"main\" : [ \"main\" ] } app = Brew ( __name__ , projects ) projects is a dict containing all the views to be used. Let's say if we had the views: main.py , account.py , music.py , books.py We could put them into one projects = { \"main\" : [ \"main\" , \"account\" , \"music\" , \"books\" ] } Upon serving the app, it would make all the endpoints available. Let's say we want to run multiple application projects = { \"main\" : [ \"main\" , \"account\" ], \"library\" : [ \"music\" , \"books\" ] } Now we have 2 applications: main and library By default, Mocha will default to main mocha : serve But to run library app = library mocha : serve If two apps are running at the same time, you may need to specify a different port app = library mocha : serve --port 5001","title":"First app"},{"location":"first-app/#your-first-app","text":"Here's what Mocha will do, and expecting: that your views are structured in class the class inherits mocha.Mocha if the class name is Index(Mocha) , it will be the base route as / the methods are the views actions the methods name will become the endpoint url if the method name is index(self) , it will be the entry point of that view methods name with underscore will be dasherized, about_us(self) -> /about-us/ the methods return data as dict type the data returned is passed to your template the template is named after the method name the template is magically included in your layout Mocha brews everything together, and renders the page","title":"Your first app"},{"location":"first-app/#views","text":"All your view module should be placed in application/views . By default , main.py view is created main.py must contain at a least one class that inherits Mocha . A view module may have multiple classes application/views/main.py from mocha import Mocha , page_attr class Index ( Mocha ): def index ( self ): page_attr ( \"Hello World\" ) return { \"name\" : \"Mocha\" , \"version\" : \"1.0\" } def about_us ( self ): page_attr ( \"About Us\" ) return class Document ( Mocha ): def index ( self ): page_attr ( 'All documents' ) return { \"docs\" : [ { \"id\" : 1 , \"title\" : \"This is a doc title\" }, ... ] } def get ( self , id ): page_attr ( \"This is a doc title\" ) return { \"id\" : id , \"title\" : \"This is a doc title\" , \"content\" : \"My content\" } The main.py module contains two view classes: Index and Document that inherit Mocha . Also imported page_attr , a utility function to set the page title and other page attributes The methods return dict or None The route will be created from the class and method name. If the class name is Index , it will be the root of the domain, in this example / , and other will stay as is, in this instance the Document will have as route /document/ . The following url will be created: Index:index() -> http://localhost:5000/ Index:about_us() -> http://localhost:5000/about-us Document:index() -> http://localhost:5000/document Document:get(id) -> http://localhost:5000/document/1234","title":"Views"},{"location":"first-app/#template","text":"All your templates should be placed in application/templates . And must follow the same directory structure relative to the view modules. The returned data from the view will be passed to the template. So for application/views/main.py , it is expecting the following template structure / application | | -- templates | | | -- main/ | | -- Index/ | | -- index.jade | | -- about_us.jade | | __ Document / | | -- index.jade | | -- get.jade As you can see, the template structure follows the view structure, where in the view: main.py -> /templates/main main.py:Index() -> templates/main/Index main.py:Index(Mocha):index(self) -> templates/main/Index/index.jade main.py:Index(Mocha):about_us(self) -> templates/main/Index/about_us.jade main.py:Document() -> templates/main/Document main.py:Document(Mocha):index(self) -> templates/main/Document/index.jade main.py:Document(Mocha):get(self) -> templates/main/Document/get.jade Also, you may have noticed that we use .jade template instead of HTML, just for aesthetic, as it looks like python on the templates side. But HTML can also be used. templates/main/Index/index.jade .row .col-md-12.text-center h2 = name small = version Which will be translated into html <div class= \"row\" > <div class= \"col-md-12 text-center\" > <h2> Mocha <small> 1.0 </small></h2> </div> </div> templates/main/Document/index.jade . row . col - md - 12 ul for doc in docs li : a ( href = url_for ( ' views.main.Document:get ' , id = doc . id )) = doc . title Will be translated into html <div class= \"row\" > <div class= \"col-md-12\" > <ul> <li><a href= '/document/1' > This is a doc title </a></li> </ul> </div> </div>","title":"Template"},{"location":"first-app/#layout","text":"By default, layouts are placed in application/templates/layouts , and upon rendering Mocha will glue your view in the layout. The default layout is at: application/templates/layouts/base.jade While you can have extends in your templates, Mocha makes it easy to bypass the repetitive tasks, so you can fully focus on that one page you are working on. - import \"contrib/components/html.html\" as html with context - import \"contrib/components/nav.jade\" as nav with context - import \"contrib/components/forms.html\" as forms with context - import \"contrib/components/widget.html\" as widget with context !!! 5 html ( lang = \"en\" ) head meta ( charset = \"utf-8\" ) meta ( name = \"viewport\" , content = \"width=device-width, initial-scale=1.0\" ) + html . page_title () + html . page_description () + html . opengraph () + html . favicon ( \"favicon.ico\" ) + html . include_jquery () + html . include_bootstrap () + html . include_fontawesome () + html . include_bootswatch_theme ( 'yeti' ) + html . include_css_file ( \"commons.css\" ) + html . include_css_file ( \"styles.css\" ) + html . include_js_file ( \"app.js\" ) + html . google_analytics () body . container - include __template__ footer . container - fluid . row . col - md - 12 . text - center . & copy ; {{ g . __YEAR__ }} {{ config . APPLICATION_NAME }} {{ config . APPLICATION_VERSION }} The most important part of the layout is include __template__ . This where the view template will be injected. There are much more stuff going on it the template, we can tackle them later.","title":"Layout"},{"location":"first-app/#static","text":"Static hold your assets: js, css, images. They must be placed in /application/static/ Mocha uses Flask-Assets to manage your assets. Therefor assets.yml is a bundle collection, that allows you to bundle css or js together. assets.yml styles . css : output : \"gen/styles.css\" contents : - css / style . css app . js : output : \"gen/app.js\" contents : - js / app . js And in your template you can call it + html . include_css_file ( \"style.css\" ) + html . include_js_file ( \"app.js\" ) As a convenience, we include a package.json if you want to download 3rd party scripts (js, css). You can either run npm install in static directory, or run mocha :install-assets , which will install your assets in the node_modules","title":"Static"},{"location":"first-app/#serve","text":"Now we are done with our application, all we need to do is serve it. mocha : serve The command above will run brew.py brew.py is the entry point of the application. from mocha import Brew projects = { \"main\" : [ \"main\" ] } app = Brew ( __name__ , projects ) projects is a dict containing all the views to be used. Let's say if we had the views: main.py , account.py , music.py , books.py We could put them into one projects = { \"main\" : [ \"main\" , \"account\" , \"music\" , \"books\" ] } Upon serving the app, it would make all the endpoints available. Let's say we want to run multiple application projects = { \"main\" : [ \"main\" , \"account\" ], \"library\" : [ \"music\" , \"books\" ] } Now we have 2 applications: main and library By default, Mocha will default to main mocha : serve But to run library app = library mocha : serve If two apps are running at the same time, you may need to specify a different port app = library mocha : serve --port 5001","title":"Serve"},{"location":"install/","text":"Assembly is a Pythonic Object-Oriented Web Framework built on Flask Requirements Python 3.6+ Virtualenv Install Install Assembly with pip install assembly It is highly recommended to use a virtualenv, in this case let's use VirtualenvWrapper (you can use any that is convenient for you) mkvirtualenv my - first - app workon my - first - app pip install assembly Initialize Initialize Assembly with asm-admin init CD into the folder you intend to create the application, then run asm-admin init . This will setup the structure along with the necessary files to get started cd app - dir asm - admin init Launch first app asm - admin serve","title":"Installation"},{"location":"install/#requirements","text":"Python 3.6+ Virtualenv","title":"Requirements"},{"location":"install/#install","text":"Install Assembly with pip install assembly It is highly recommended to use a virtualenv, in this case let's use VirtualenvWrapper (you can use any that is convenient for you) mkvirtualenv my - first - app workon my - first - app pip install assembly","title":"Install"},{"location":"install/#initialize","text":"Initialize Assembly with asm-admin init CD into the folder you intend to create the application, then run asm-admin init . This will setup the structure along with the necessary files to get started cd app - dir asm - admin init","title":"Initialize"},{"location":"install/#launch-first-app","text":"asm - admin serve","title":"Launch first app"},{"location":"tutorials/","text":"Setup Assembly Install pip install assembly Initialiaze asm-admin init Run Development Server asm-admin serve REST API Generate the view using asm-admin asm-admin gen-api-view my-api This will generate a View package with __init__.py , __models__.py , cli.py . Import in wsgi.py # wsgi . py APPS = { \"default\" : [ \"main\" , \"api\" ] } Edit View # /api/__init__.py from assembly import ( Assembly , request , response , date ) @response.route ( \"/api/\" ) class Index ( Assembly ): @response.json def index ( self ): return { \"date\" : date . utcnow () } @request.post def submit_info ( self ): return { \"message\" : \"Thank you\" } HTML Site Generate the view using asm-admin asm-admin gen-template-view admin This will generate a View package with __init__.py , __models__.py , templates/ , static/ , cli.py . Import in wsgi.py # wsgi . py APPS = { \"default\" : [ \"main\" , \"admin\" ] } Edit your first view # admin/__init__.py from assembly import ( Assembly , response ) @response.route ( \"/admin/\" ) class Index ( Assembly ): index ( self ): return { \"title\" : \"Assembly is awesome\" , \"content\" : \"That is a true fact\" } @response.json api ( self ): return { \"name\" : \"Assembly\" , \"version\" : \"x-to-infinity\" } Edit Index/index.html <!-- admin/templates/Index/index.html --> {% extends 'main/layouts/base.html' %} {% block title %} Welcome to Admin {% endblock %} {% block body %} <div> <h1> {{ title }} </h1> </div> <div> {{ content }} </div> {% endblock %} Serve your first application If everything is all set, all you need to do now is run your site: asm - admin serve It will start serving your application by default at 127.0.0.1:5000 Two endpoints will be available: http://127.0.0.1:5000/admin which will show an HTML http://127.0.0.1:5000/admin/api/ which will a json response Error Handler Work with CORS API Create Custom CLI Work with CSRF Upload Application","title":"Tutorials"},{"location":"tutorials/#setup-assembly","text":"Install pip install assembly Initialiaze asm-admin init Run Development Server asm-admin serve","title":"Setup Assembly"},{"location":"tutorials/#rest-api","text":"Generate the view using asm-admin asm-admin gen-api-view my-api This will generate a View package with __init__.py , __models__.py , cli.py . Import in wsgi.py # wsgi . py APPS = { \"default\" : [ \"main\" , \"api\" ] } Edit View # /api/__init__.py from assembly import ( Assembly , request , response , date ) @response.route ( \"/api/\" ) class Index ( Assembly ): @response.json def index ( self ): return { \"date\" : date . utcnow () } @request.post def submit_info ( self ): return { \"message\" : \"Thank you\" }","title":"REST API"},{"location":"tutorials/#html-site","text":"Generate the view using asm-admin asm-admin gen-template-view admin This will generate a View package with __init__.py , __models__.py , templates/ , static/ , cli.py . Import in wsgi.py # wsgi . py APPS = { \"default\" : [ \"main\" , \"admin\" ] } Edit your first view # admin/__init__.py from assembly import ( Assembly , response ) @response.route ( \"/admin/\" ) class Index ( Assembly ): index ( self ): return { \"title\" : \"Assembly is awesome\" , \"content\" : \"That is a true fact\" } @response.json api ( self ): return { \"name\" : \"Assembly\" , \"version\" : \"x-to-infinity\" } Edit Index/index.html <!-- admin/templates/Index/index.html --> {% extends 'main/layouts/base.html' %} {% block title %} Welcome to Admin {% endblock %} {% block body %} <div> <h1> {{ title }} </h1> </div> <div> {{ content }} </div> {% endblock %} Serve your first application If everything is all set, all you need to do now is run your site: asm - admin serve It will start serving your application by default at 127.0.0.1:5000 Two endpoints will be available: http://127.0.0.1:5000/admin which will show an HTML http://127.0.0.1:5000/admin/api/ which will a json response","title":"HTML Site"},{"location":"tutorials/#error-handler","text":"","title":"Error Handler"},{"location":"tutorials/#work-with-cors-api","text":"","title":"Work with CORS API"},{"location":"tutorials/#create-custom-cli","text":"","title":"Create Custom CLI"},{"location":"tutorials/#work-with-csrf","text":"","title":"Work with CSRF"},{"location":"tutorials/#upload-application","text":"","title":"Upload Application"},{"location":"wsgipy/","text":"wsgi.py is the application's entry point Initialize # wsgi.py from assembly import Assembly APPS = { \"default\" : [ \"main\" ] } app = Assembly . initialize ( __name__ , APPS ) app __name__ APPS Assembly is a multi-application framework, where you can launch different application in the same code base. To achieve this, Assembly requires a list off all the views to be used per app. Upon deploying an app, you can select on by providing the name of it using the environment variable ASSEMBLY_APP . Environment Variables ASSEMBLY_APP ASSEMBLY_ENV","title":"wsgi.py"},{"location":"wsgipy/#initialize","text":"# wsgi.py from assembly import Assembly APPS = { \"default\" : [ \"main\" ] } app = Assembly . initialize ( __name__ , APPS )","title":"Initialize"},{"location":"wsgipy/#app","text":"","title":"app"},{"location":"wsgipy/#9595name__","text":"","title":"__name__"},{"location":"wsgipy/#apps","text":"Assembly is a multi-application framework, where you can launch different application in the same code base. To achieve this, Assembly requires a list off all the views to be used per app. Upon deploying an app, you can select on by providing the name of it using the environment variable ASSEMBLY_APP .","title":"APPS"},{"location":"wsgipy/#environment-variables","text":"","title":"Environment Variables"},{"location":"wsgipy/#assembly_app","text":"","title":"ASSEMBLY_APP"},{"location":"wsgipy/#assembly_env","text":"","title":"ASSEMBLY_ENV"},{"location":"_partials/file-structure/","text":"/ ____ | |- brew . py | |- propel . yml | | -- requirements.txt | | -- /application | | -- config.py | | -- models.py | | -- helpers.py | | -- manage.py | | -- views/ | | -- main.py | | -- templates/ | | -- layouts/ | | -- base.jade | | -- main/ | | -- Index/ | | -- index.jade | | -- /static/ | | -- assets.yml | | -- package.json | | -- css/ | | -- js/ | | -- imgs/ | | -- /var/ Description: brew.py is the application entry point propel.yml (optional) A deploy based config file requirements.txt contains your requirements + mocha application/ contains the application's models, config, helpers and manage application/views/ : contains your views modules application/templates/ : contains all templates relative to the views name application/static/ : contains all the app's assets: js, css, imgs, etc... application/var/ : contains var files: database, mail-template, uploads, etc...","title":"File structure"},{"location":"_xviews/","text":"Location: /application/views Examples from mocha import Mocha class Index ( Mocha ): def index ( self ): return","title":"Home"},{"location":"_xviews/abort/","text":"","title":"Abort"},{"location":"_xviews/decorators/","text":"Decorators Mocha exposes decorators to simplify your app development Render Cache Flask-Caching is used for caching cache from mocha.ext import cache class Index ( Mocha ): @cache.cached ( 500 ) def my_cache_view ( self ): return memoize CSRF All POST methods are required to receive _csrf_token from the application. It it fails, the user will not be able to use it. exempt_csrf In some cases you will want to bypass a POST method CSRF check, to do, we have to exempt that method from mocha.ext import csrf import mocha.decorators as deco class Index ( Mocha ): @csrf.exempt @deco.accept_post def my_exempted_csrf_post ( self ): return nav_menu @nav_menu creates a navigation menu for UI from mocha import nav_menu view_parser @view_parser from mocha import view_parser","title":"Decorators"},{"location":"_xviews/decorators/#decorators","text":"Mocha exposes decorators to simplify your app development","title":"Decorators"},{"location":"_xviews/decorators/#render","text":"","title":"Render"},{"location":"_xviews/decorators/#cache","text":"Flask-Caching is used for caching","title":"Cache"},{"location":"_xviews/decorators/#cache_1","text":"from mocha.ext import cache class Index ( Mocha ): @cache.cached ( 500 ) def my_cache_view ( self ): return","title":"cache"},{"location":"_xviews/decorators/#memoize","text":"","title":"memoize"},{"location":"_xviews/decorators/#csrf","text":"All POST methods are required to receive _csrf_token from the application. It it fails, the user will not be able to use it.","title":"CSRF"},{"location":"_xviews/decorators/#exempt_csrf","text":"In some cases you will want to bypass a POST method CSRF check, to do, we have to exempt that method from mocha.ext import csrf import mocha.decorators as deco class Index ( Mocha ): @csrf.exempt @deco.accept_post def my_exempted_csrf_post ( self ): return","title":"exempt_csrf"},{"location":"_xviews/decorators/#nav_menu","text":"@nav_menu creates a navigation menu for UI from mocha import nav_menu","title":"nav_menu"},{"location":"_xviews/decorators/#view_parser","text":"@view_parser from mocha import view_parser","title":"view_parser"},{"location":"_xviews/helpers/","text":"Utils are functions or objects that are exposed to the applications. They can be shortcuts, or from Flask itself. Some of them may extend some functionalities. config page_attr send_mail get_env set_env get_env_app get_env_config models views register_package init_app import_module register_models send_mail upload storage","title":"Helpers"},{"location":"_xviews/helpers/#config","text":"","title":"config"},{"location":"_xviews/helpers/#page_attr","text":"","title":"page_attr"},{"location":"_xviews/helpers/#send_mail","text":"","title":"send_mail"},{"location":"_xviews/helpers/#get_env","text":"","title":"get_env"},{"location":"_xviews/helpers/#set_env","text":"","title":"set_env"},{"location":"_xviews/helpers/#get_env_app","text":"","title":"get_env_app"},{"location":"_xviews/helpers/#get_env_config","text":"","title":"get_env_config"},{"location":"_xviews/helpers/#models","text":"","title":"models"},{"location":"_xviews/helpers/#views","text":"","title":"views"},{"location":"_xviews/helpers/#register_package","text":"","title":"register_package"},{"location":"_xviews/helpers/#init_app","text":"","title":"init_app"},{"location":"_xviews/helpers/#import_module","text":"","title":"import_module"},{"location":"_xviews/helpers/#register_models","text":"","title":"register_models"},{"location":"_xviews/helpers/#send_mail_1","text":"","title":"send_mail"},{"location":"_xviews/helpers/#upload","text":"","title":"upload"},{"location":"_xviews/helpers/#storage","text":"","title":"storage"},{"location":"_xviews/logging/","text":"Configuration","title":"Logging"},{"location":"_xviews/logging/#configuration","text":"","title":"Configuration"},{"location":"_xviews/redirect/","text":"As it is in Flask, redirect just redirects to another endpoint or url. However, Mocha put a little bit of convenience in, by doing self reference or Import from mocha import redirect Usage class Index ( Mocha ) : def index ( self ) : pass def post ( self ) : return redirect ( self . index ) With other views If you will be redirecting in views that are not in the same module, yo will need to import the views object along with redirect from mocha import redirect , views Usage # views/main.py from mocha import redirect , views , request class Index ( Mocha ): @request.post def save_data (): return redirect ( views . account . Index . info ) - # views / account . py @request . route ( \"/account\" ) class Index ( Mocha ) : def index ( self ) : pass def info ( self ) : pass","title":"Redirect"},{"location":"_xviews/redirect/#import","text":"from mocha import redirect","title":"Import"},{"location":"_xviews/redirect/#usage","text":"class Index ( Mocha ) : def index ( self ) : pass def post ( self ) : return redirect ( self . index )","title":"Usage"},{"location":"_xviews/redirect/#with-other-views","text":"If you will be redirecting in views that are not in the same module, yo will need to import the views object along with redirect from mocha import redirect , views","title":"With other views"},{"location":"_xviews/redirect/#usage_1","text":"# views/main.py from mocha import redirect , views , request class Index ( Mocha ): @request.post def save_data (): return redirect ( views . account . Index . info ) - # views / account . py @request . route ( \"/account\" ) class Index ( Mocha ) : def index ( self ) : pass def info ( self ) : pass","title":"Usage"},{"location":"_xviews/render/","text":"This module contains decorators that will alter the rendering of the view. It can change the response, or add new elements on the page, ie: json will turn the endpoint into a json response, while template will change the default template page to display, and nav will create a menu title. Import from mocha import render Response By default, the responses will render normal HTML. But if you want to return JSON, or XML data, the methods below will conveniently help you do that. N.B.: The methods must return DICT for them to benefit from multiple response format json It return a dict into JSON. Good for API endpoint. class Index ( Mocha ) : @ render . json def my_data ( self ) : return { \" name \" : \" Mocha \" , \" version \" : \" xxx \" } jsonp It return a dict into JSON for JSONP. class Index ( Mocha ) : @ render . jsonp def my_data ( self ) : return { \" name \" : \" Mocha \" , \" version \" : \" xxx \" } xml It return a dict into XML. class Index ( Mocha ) : @ render . xml def my_data ( self ) : return { \" name \" : \" Mocha \" , \" version \" : \" xxx \" } html There is no decorator for HTML, as it will fall back to it if a view is not decorated with json or xml Template This decorator allows you to change the view template or layout It can be applied on both class based or method based Params: template(page, markup=\"jade\") page: the path of the new layout or template markup: the markup to use for all pages: jade or html Class based This will change the default layout to another one. @ render . template ( ' /layouts/my-new-layouts.jade ' ) class Index ( Mocha ) : def index ( self ) : return def hello ( self ) : return Method based By default the template for method is based on its name, to use a different template, specify the full path class Index ( Mocha ) : def index ( self ) : return @ render . template ( ' /my-path/new-world.html ' , markup = ' html ' ) def hello ( self ) : return Navigation","title":"Render"},{"location":"_xviews/render/#import","text":"from mocha import render","title":"Import"},{"location":"_xviews/render/#response","text":"By default, the responses will render normal HTML. But if you want to return JSON, or XML data, the methods below will conveniently help you do that. N.B.: The methods must return DICT for them to benefit from multiple response format","title":"Response"},{"location":"_xviews/render/#json","text":"It return a dict into JSON. Good for API endpoint. class Index ( Mocha ) : @ render . json def my_data ( self ) : return { \" name \" : \" Mocha \" , \" version \" : \" xxx \" }","title":"json"},{"location":"_xviews/render/#jsonp","text":"It return a dict into JSON for JSONP. class Index ( Mocha ) : @ render . jsonp def my_data ( self ) : return { \" name \" : \" Mocha \" , \" version \" : \" xxx \" }","title":"jsonp"},{"location":"_xviews/render/#xml","text":"It return a dict into XML. class Index ( Mocha ) : @ render . xml def my_data ( self ) : return { \" name \" : \" Mocha \" , \" version \" : \" xxx \" }","title":"xml"},{"location":"_xviews/render/#html","text":"There is no decorator for HTML, as it will fall back to it if a view is not decorated with json or xml","title":"html"},{"location":"_xviews/render/#template","text":"This decorator allows you to change the view template or layout It can be applied on both class based or method based Params: template(page, markup=\"jade\") page: the path of the new layout or template markup: the markup to use for all pages: jade or html","title":"Template"},{"location":"_xviews/render/#class-based","text":"This will change the default layout to another one. @ render . template ( ' /layouts/my-new-layouts.jade ' ) class Index ( Mocha ) : def index ( self ) : return def hello ( self ) : return","title":"Class based"},{"location":"_xviews/render/#method-based","text":"By default the template for method is based on its name, to use a different template, specify the full path class Index ( Mocha ) : def index ( self ) : return @ render . template ( ' /my-path/new-world.html ' , markup = ' html ' ) def hello ( self ) : return","title":"Method based"},{"location":"_xviews/render/#navigation","text":"","title":"Navigation"},{"location":"_xviews/route/","text":"Allows you to apply a route on a view class or a single method Import from mocha import request Class based When applied to a view class, all methods will be prefixed with the toute The following code will use the /account/ route, and /account/hello @request . route ( \"/account/\" ) class Index ( Mocha ) : def index ( self ) : pass def hello ( self ) : pass Method based Method based route only applies the route to the method. The code below will expose /hello-world . By default Index and index will reference to the root, unless a route is applied class Index ( Mocha ) : def index ( self ) : pass @request . route ( \"hello-world\" ) def hello ( self ) : pass Class and Method You can combine both class and method based. The code below will now be accessed at: /account/ , /account/hello-world @request . route ( \"/account/\" ) class Index ( Mocha ) : def index ( self ) : pass @request . route ( \"/hello-world\" ) def hello ( self ) : pass","title":"Route"},{"location":"_xviews/route/#import","text":"from mocha import request","title":"Import"},{"location":"_xviews/route/#class-based","text":"When applied to a view class, all methods will be prefixed with the toute The following code will use the /account/ route, and /account/hello @request . route ( \"/account/\" ) class Index ( Mocha ) : def index ( self ) : pass def hello ( self ) : pass","title":"Class based"},{"location":"_xviews/route/#method-based","text":"Method based route only applies the route to the method. The code below will expose /hello-world . By default Index and index will reference to the root, unless a route is applied class Index ( Mocha ) : def index ( self ) : pass @request . route ( \"hello-world\" ) def hello ( self ) : pass","title":"Method based"},{"location":"_xviews/route/#class-and-method","text":"You can combine both class and method based. The code below will now be accessed at: /account/ , /account/hello-world @request . route ( \"/account/\" ) class Index ( Mocha ) : def index ( self ) : pass @request . route ( \"/hello-world\" ) def hello ( self ) : pass","title":"Class and Method"},{"location":"_xviews/session-flash/","text":"Session Mocha natively uses Flask session, with the addition of having the ability to use as backend either: Redis, Memcache, S3, CloudStorage Config #: SESSION #: Flask - KVSession is used to save the user ' s session #: Set the SESSION_URL by using these examples below to set KVSession #: To use local session , just set SESSION_URL to None #: #: Redis : redis : // username : password @host : 6379 / db #: S3 : s3 : // username : password @s3 . aws . amazon . com / bucket #: Google Storage : google_storage : // username : password @cloud . google . com / bucket #: SQL : postgresql : // username : password @host : 3306 / db #: mysql + pysql : // username : password @host : 3306 / db #: sqlite : // #: Memcached : memcache : // host : port #: SESSION_URL = None Usage from mocha import session Flash The Flash provides single-use string storage. It useful for implementing the Post/Redirect/Get pattern, or for transient \"Operation Successful!\" or \"Operation Failed!\" messages You can import the flash as is, but for convenience, we provided some special message pattern: flash_info , flash_success , flash_error to indicate a info, success and error message respectively. Flash Message Import from mocha import flash_info , flash_success , flash_error Usage class Index ( Mocha ) : def index ( self ) : flash_info ( \" You need to provide your account info \" ) return def post ( self ) : try : # do something flash_success ( ' Account info saved successfully! ' ) except Exception as ex : flash_error ( ' An error occured while saving your info ' ) return redirect ( self . index ) Flash Data Same as flash message, you can also flash data Import from mocha import flash_data , get_flash_data Usage class Index ( Mocha ): def index ( self ): flash_data ({ \"temp\" : 70 }) def get ( self , id ): temp = get_flash_data (). get ( \"temp\" )","title":"Session flash"},{"location":"_xviews/session-flash/#session","text":"Mocha natively uses Flask session, with the addition of having the ability to use as backend either: Redis, Memcache, S3, CloudStorage","title":"Session"},{"location":"_xviews/session-flash/#config","text":"#: SESSION #: Flask - KVSession is used to save the user ' s session #: Set the SESSION_URL by using these examples below to set KVSession #: To use local session , just set SESSION_URL to None #: #: Redis : redis : // username : password @host : 6379 / db #: S3 : s3 : // username : password @s3 . aws . amazon . com / bucket #: Google Storage : google_storage : // username : password @cloud . google . com / bucket #: SQL : postgresql : // username : password @host : 3306 / db #: mysql + pysql : // username : password @host : 3306 / db #: sqlite : // #: Memcached : memcache : // host : port #: SESSION_URL = None","title":"Config"},{"location":"_xviews/session-flash/#usage","text":"from mocha import session","title":"Usage"},{"location":"_xviews/session-flash/#flash","text":"The Flash provides single-use string storage. It useful for implementing the Post/Redirect/Get pattern, or for transient \"Operation Successful!\" or \"Operation Failed!\" messages You can import the flash as is, but for convenience, we provided some special message pattern: flash_info , flash_success , flash_error to indicate a info, success and error message respectively.","title":"Flash"},{"location":"_xviews/session-flash/#flash-message","text":"","title":"Flash Message"},{"location":"_xviews/session-flash/#import","text":"from mocha import flash_info , flash_success , flash_error","title":"Import"},{"location":"_xviews/session-flash/#usage_1","text":"class Index ( Mocha ) : def index ( self ) : flash_info ( \" You need to provide your account info \" ) return def post ( self ) : try : # do something flash_success ( ' Account info saved successfully! ' ) except Exception as ex : flash_error ( ' An error occured while saving your info ' ) return redirect ( self . index )","title":"Usage"},{"location":"_xviews/session-flash/#flash-data","text":"Same as flash message, you can also flash data","title":"Flash Data"},{"location":"_xviews/session-flash/#import_1","text":"from mocha import flash_data , get_flash_data","title":"Import"},{"location":"_xviews/session-flash/#usage_2","text":"class Index ( Mocha ): def index ( self ): flash_data ({ \"temp\" : 70 }) def get ( self , id ): temp = get_flash_data (). get ( \"temp\" )","title":"Usage"},{"location":"_xviews/url_for/","text":"url_for use a view endpoint to create a full url Mocha adds a little flavor in it, to reference other views by their reference. Import from mocha import url_for Usage class Index ( Mocha ) : def index ( self ) : doc_1_url = url_for ( self . doc , id = 1 ) full_url_account_info = url_for ( views . account . Index . info , _external = True ) return { \" urls \" : { \" doc_1 \" : doc_1_url , \" full_url \" : full_url_account_info } } def doc ( self , id ) : pass","title":"Url for"},{"location":"_xviews/url_for/#import","text":"from mocha import url_for","title":"Import"},{"location":"_xviews/url_for/#usage","text":"class Index ( Mocha ) : def index ( self ) : doc_1_url = url_for ( self . doc , id = 1 ) full_url_account_info = url_for ( views . account . Index . info , _external = True ) return { \" urls \" : { \" doc_1 \" : doc_1_url , \" full_url \" : full_url_account_info } } def doc ( self , id ) : pass","title":"Usage"},{"location":"advanced/bcrypt/","text":"bcrypt from the passlib library is used to hash and verify password. Import from mocha import bcrypt Hash password Hash a password for storage my_string_pass = \"mypass123\" my_hash = bcrypt . hash ( my_string_pass ) Verify password Verify a password by using the string provided to hash, and the hash that was created previously. It returns a bool. bcrypt . verify ( my_string_pass , my_hash ) Config bcrypt can be used with no configuration as it will fall back to its default. But if you want you can have the following config BCRYPT_SALT = \"\" BCRYPT_ROUNDS = 12 BCRYPT_INDENT = \"\"","title":"Bcrypt"},{"location":"advanced/bcrypt/#import","text":"from mocha import bcrypt","title":"Import"},{"location":"advanced/bcrypt/#hash-password","text":"Hash a password for storage my_string_pass = \"mypass123\" my_hash = bcrypt . hash ( my_string_pass )","title":"Hash password"},{"location":"advanced/bcrypt/#verify-password","text":"Verify a password by using the string provided to hash, and the hash that was created previously. It returns a bool. bcrypt . verify ( my_string_pass , my_hash )","title":"Verify password"},{"location":"advanced/bcrypt/#config","text":"bcrypt can be used with no configuration as it will fall back to its default. But if you want you can have the following config BCRYPT_SALT = \"\" BCRYPT_ROUNDS = 12 BCRYPT_INDENT = \"\"","title":"Config"},{"location":"advanced/caching/","text":"Overview Assembly uses flask-caching to cache the endpoint responses. It allows to use different backend, ie: Redis, Memcache, etc. The Cache configuration can be set in the config.py file. Extension: flask-caching Usage Assembly exposes @response.cache to cache enpoint. The decorator will use request.path by default for the cache_key from assembly import Assembly , response , date class Index ( Assembly ): @response.json def index ( self ): return { \"description\" : \"not cached\" , \"date\" : date . utcnow () } @response.cache ( 10 ) @response.json def cached ( self ): return { \"description\" : \"cached\" , \"date\" : date . utcnow () } Configuration Set the configuration below in your config.py file. #: CACHE_TYPE #: The type of cache to use #: null , simple , redis , filesystem , CACHE_TYPE = \" simple \" #: CACHE_REDIS_URL #: If CHACHE_TYPE is ' redis ' , set the redis uri #: redis : // username : password @ host : port / db CACHE_REDIS_URL = \"\" #: CACHE_DIR #: Directory to store cache if CACHE_TYPE is filesystem , it will CACHE_DIR = \"\"","title":"Caching"},{"location":"advanced/caching/#overview","text":"Assembly uses flask-caching to cache the endpoint responses. It allows to use different backend, ie: Redis, Memcache, etc. The Cache configuration can be set in the config.py file. Extension: flask-caching","title":"Overview"},{"location":"advanced/caching/#usage","text":"Assembly exposes @response.cache to cache enpoint. The decorator will use request.path by default for the cache_key from assembly import Assembly , response , date class Index ( Assembly ): @response.json def index ( self ): return { \"description\" : \"not cached\" , \"date\" : date . utcnow () } @response.cache ( 10 ) @response.json def cached ( self ): return { \"description\" : \"cached\" , \"date\" : date . utcnow () }","title":"Usage"},{"location":"advanced/caching/#configuration","text":"Set the configuration below in your config.py file. #: CACHE_TYPE #: The type of cache to use #: null , simple , redis , filesystem , CACHE_TYPE = \" simple \" #: CACHE_REDIS_URL #: If CHACHE_TYPE is ' redis ' , set the redis uri #: redis : // username : password @ host : port / db CACHE_REDIS_URL = \"\" #: CACHE_DIR #: Directory to store cache if CACHE_TYPE is filesystem , it will CACHE_DIR = \"\"","title":"Configuration"},{"location":"advanced/csrf/","text":"Overview Assembly uses flask-seasurf to prevent cross-site request forgery (CSRF) Extension: flask-seasurf Usage Automatically all POST, UPDATE methods will require a CSRF token, unless explicitly exempt . (That's a good thing) This includes POST from FORMS or AJAX calls. HTML Forms In HTML, csrf_token() needs to be added for any POST forms. <input type='hidden' name=\"_csrf_token\" value=' {{ csrf_token () }} '> Example: <h1> Upload </h1> <form id= \"uploadbanner\" action= \"/upload/\" enctype= \"multipart/form-data\" method= \"post\" > <input type= 'hidden' name= \"_csrf_token\" value= ' {{ csrf_token () }} ' > <input id= \"fileupload\" name= \"file\" type= \"file\" /> <input type= \"submit\" value= \"Upload\" id= \"submit\" /> </form> Validation Implicitely CSRF gets validated if _csrf_token was part of the POST call. If CSRF fails to validate, it will throw a Forbidden/403 error. Validate CSRF To validate CSRF, use request.csrf . If CSRF fails to validate, it will throw a Forbidden/403 error. from assembly import Assembly , request class Index ( Assembly ): def post ( self ): if request . csrf . validate (): # everything is good here pass Exempt CSRF Assembly exposes @request.csrf.exempt to exclude a view from CSRF validation. from assembly import Assembly , request class Index ( Assembly ): def post ( self ): # this will require csrf @request.post @request.csrf.exempt def exempt_this ( self ): # this will not require CSFR In the example above, when POSTing to /post/ it will require the CSRF token, however POSTing to /exempt-this/ will not requires it. Configuration Set the configuration below in your config.py file. CSRF_COOKIE_NAME = \"_csrf_token\" CSRF_HEADER_NAME = \"X-CSRFToken\" CSRF_DISABLE CSRF_COOKIE_TIMEOUT CSRF_COOKIE_SECURE CSRF_COOKIE_HTTPONLY CSRF_COOKIE_DOMAIN CSRF_CHECK_REFERER SEASURF_INCLUDE_OR_EXEMPT_VIEWS","title":"CSFR"},{"location":"advanced/csrf/#overview","text":"Assembly uses flask-seasurf to prevent cross-site request forgery (CSRF) Extension: flask-seasurf","title":"Overview"},{"location":"advanced/csrf/#usage","text":"Automatically all POST, UPDATE methods will require a CSRF token, unless explicitly exempt . (That's a good thing) This includes POST from FORMS or AJAX calls.","title":"Usage"},{"location":"advanced/csrf/#html-forms","text":"In HTML, csrf_token() needs to be added for any POST forms. <input type='hidden' name=\"_csrf_token\" value=' {{ csrf_token () }} '> Example: <h1> Upload </h1> <form id= \"uploadbanner\" action= \"/upload/\" enctype= \"multipart/form-data\" method= \"post\" > <input type= 'hidden' name= \"_csrf_token\" value= ' {{ csrf_token () }} ' > <input id= \"fileupload\" name= \"file\" type= \"file\" /> <input type= \"submit\" value= \"Upload\" id= \"submit\" /> </form>","title":"HTML Forms"},{"location":"advanced/csrf/#validation","text":"Implicitely CSRF gets validated if _csrf_token was part of the POST call. If CSRF fails to validate, it will throw a Forbidden/403 error.","title":"Validation"},{"location":"advanced/csrf/#validate-csrf","text":"To validate CSRF, use request.csrf . If CSRF fails to validate, it will throw a Forbidden/403 error. from assembly import Assembly , request class Index ( Assembly ): def post ( self ): if request . csrf . validate (): # everything is good here pass","title":"Validate CSRF"},{"location":"advanced/csrf/#exempt-csrf","text":"Assembly exposes @request.csrf.exempt to exclude a view from CSRF validation. from assembly import Assembly , request class Index ( Assembly ): def post ( self ): # this will require csrf @request.post @request.csrf.exempt def exempt_this ( self ): # this will not require CSFR In the example above, when POSTing to /post/ it will require the CSRF token, however POSTing to /exempt-this/ will not requires it.","title":"Exempt CSRF"},{"location":"advanced/csrf/#configuration","text":"Set the configuration below in your config.py file. CSRF_COOKIE_NAME = \"_csrf_token\" CSRF_HEADER_NAME = \"X-CSRFToken\" CSRF_DISABLE CSRF_COOKIE_TIMEOUT CSRF_COOKIE_SECURE CSRF_COOKIE_HTTPONLY CSRF_COOKIE_DOMAIN CSRF_CHECK_REFERER SEASURF_INCLUDE_OR_EXEMPT_VIEWS","title":"Configuration"},{"location":"advanced/date/","text":"Overview Arrow is used as the date library in Assembly, an date is the alias available. Arrow helps you work with dates and times with fewer imports and a lot less code. Extension: Arrow Usage Import from assembly import date Usage from assembly import date date . get ( '2013-05-11T21:23:58.970460+07:00' ) #-> <Arrow [2013-05-11T21:23:58.970460+07:00]> utc = date . utcnow () #-> <Arrow [2013-05-11T21:23:58.970460+00:00]> utc = utc . shift ( hours =- 1 ) #-> <Arrow [2013-05-11T20:23:58.970460+00:00]> local = utc . to ( 'US/Pacific' ) #-> <Arrow [2013-05-11T13:23:58.970460-07:00]> local . timestamp #-> 1368303838 local . format () #-> '2013-05-11 13:23:58 -07:00' local . format ( 'YYYY-MM-DD HH:mm:ss ZZ' ) #-> '2013-05-11 13:23:58 -07:00' local . humanize () # 'an hour ago' or along with config from assembly import date , config local = utc . to ( config . get ( 'TIMEZONE' )) local . format ( config . get ( 'DATE_FORMAT.default' )) Supported Tokens Use the following tokens in parsing and formatting. Note that they\u2019re not the same as the tokens for strptime. View all supported tokens ie : local = utc . to ( ' US/Pacific ' ) local . format ( ' YYYY-MM-DD HH:mm:ss ' ) ** Year ** -- YYYY ( 2019 , 2020 ) -- YY ( 19 , 20 ) ** Month ** -- MMMM ( January , February ,... ) -- MMM ( Jan , Feb , ... ) -- MM ( 01 , 02 , ... ) -- M ( 1 , 2 , ... ) ** Dat of Year ** -- DDDD ( 001 , 002 , ..., 364 , 365 ) --- DDD ( 01 , 02 , 364 , 365 ) ** Day of Month ** -- DD ( 01 , 02 , ..., 30 , 31 ) -- D ( 1 , 2 ,..., 30 , 31 ) -- Do ( 1 st , 2 nd , ..., 30 th , 31 st ) ** Day of Week ** -- dddd ( Monday , Tuesday ) -- dd ( Mon , Tues ) -- d ( 1 , 2 , ..., 6 , 7 ) ** Hour ** -- HH ( 00 , 01 , ... 23 ) -- H ( 1 , 23 ) -- hh ( 01 , 02 , ..., 11 , 12 ) -- h ( 1 , 2 , ..., 11 , 12 ) ** AM / PM ** -- A ( AM , PM ) -- a ( am , pm ) ** Minute ** -- mm ( 00 , 01 , ..., 59 ) -- m ( 0 , 1 , ..., 59 ) ** Second ** -- ss ( 00 , 01 , ..., 59 ) -- s ( 0 , 1 , ..., 59 )","title":"Date"},{"location":"advanced/date/#overview","text":"Arrow is used as the date library in Assembly, an date is the alias available. Arrow helps you work with dates and times with fewer imports and a lot less code. Extension: Arrow","title":"Overview"},{"location":"advanced/date/#usage","text":"","title":"Usage"},{"location":"advanced/date/#import","text":"from assembly import date","title":"Import"},{"location":"advanced/date/#usage_1","text":"from assembly import date date . get ( '2013-05-11T21:23:58.970460+07:00' ) #-> <Arrow [2013-05-11T21:23:58.970460+07:00]> utc = date . utcnow () #-> <Arrow [2013-05-11T21:23:58.970460+00:00]> utc = utc . shift ( hours =- 1 ) #-> <Arrow [2013-05-11T20:23:58.970460+00:00]> local = utc . to ( 'US/Pacific' ) #-> <Arrow [2013-05-11T13:23:58.970460-07:00]> local . timestamp #-> 1368303838 local . format () #-> '2013-05-11 13:23:58 -07:00' local . format ( 'YYYY-MM-DD HH:mm:ss ZZ' ) #-> '2013-05-11 13:23:58 -07:00' local . humanize () # 'an hour ago' or along with config from assembly import date , config local = utc . to ( config . get ( 'TIMEZONE' )) local . format ( config . get ( 'DATE_FORMAT.default' ))","title":"Usage"},{"location":"advanced/date/#supported-tokens","text":"Use the following tokens in parsing and formatting. Note that they\u2019re not the same as the tokens for strptime. View all supported tokens ie : local = utc . to ( ' US/Pacific ' ) local . format ( ' YYYY-MM-DD HH:mm:ss ' ) ** Year ** -- YYYY ( 2019 , 2020 ) -- YY ( 19 , 20 ) ** Month ** -- MMMM ( January , February ,... ) -- MMM ( Jan , Feb , ... ) -- MM ( 01 , 02 , ... ) -- M ( 1 , 2 , ... ) ** Dat of Year ** -- DDDD ( 001 , 002 , ..., 364 , 365 ) --- DDD ( 01 , 02 , 364 , 365 ) ** Day of Month ** -- DD ( 01 , 02 , ..., 30 , 31 ) -- D ( 1 , 2 ,..., 30 , 31 ) -- Do ( 1 st , 2 nd , ..., 30 th , 31 st ) ** Day of Week ** -- dddd ( Monday , Tuesday ) -- dd ( Mon , Tues ) -- d ( 1 , 2 , ..., 6 , 7 ) ** Hour ** -- HH ( 00 , 01 , ... 23 ) -- H ( 1 , 23 ) -- hh ( 01 , 02 , ..., 11 , 12 ) -- h ( 1 , 2 , ..., 11 , 12 ) ** AM / PM ** -- A ( AM , PM ) -- a ( am , pm ) ** Minute ** -- mm ( 00 , 01 , ..., 59 ) -- m ( 0 , 1 , ..., 59 ) ** Second ** -- ss ( 00 , 01 , ..., 59 ) -- s ( 0 , 1 , ..., 59 )","title":"Supported Tokens"},{"location":"advanced/error-handling/","text":"Overview Assembly allows you to handle your errors beautifully. _error_handler A special method _error_handler can be added in your view class to capture any HTTPException. A template with the name error_handler.html will be used. Only one _error_handler can exist in the application. _error_handler will take precedence over the other error handlers. To use specific error handler, omit _error_handler instead use the _error_$errorCode for example _error_404 # error/__init__.py from assembly import Assembly , HTTPError class Index ( Assembly ): def _error_handler ( self , e ): return { \"e\" : e } Template: <!-- error/templates/Index/error_handler.html --> {% extends 'main/layouts/base.html' %} {% block title %} Error {{ e.code }} {% endblock %} {% block body %} <h1> Error: {{ e.code }} </h1> <h4> {{ e.description }} </h4> {% endblock %} _error_$errorCode Only one _error_handler can exist in the application. _error_handler will take precedence over the other error handlers. To use specific error handler, omit _error_handler instead use the _error_$errorCode for example _error_404 $errorCode is valid HTTP Error Code. Invalid code will throw an error A template with the name error_$errorCode.html will be used. # error/__init__.py from assembly import Assembly , HTTPError class Index ( Assembly ): def _error_404 ( self , e ): return { \"e\" : e } def _error_500 ( self , e ): return { \"e\" : e } Template: <!-- error/templates/Index/error_404.html --> {% extends 'main/layouts/base.html' %} {% block title %} Error {{ e.code }} {% endblock %} {% block body %} <h1> Error: {{ e.code }} </h1> <h4> {{ e.description }} </h4> {% endblock %} <!-- error/templates/Index/error_500.html --> {% extends 'main/layouts/base.html' %} {% block title %} Error {{ e.code }} {% endblock %} {% block body %} <h1> Error: {{ e.code }} </h1> <h4> {{ e.description }} </h4> {% endblock %} Error Method Usage from assembly import Assembly , HTTPError class Index ( Assembly ): def index ( self ): raise HTTPError . Unauthorized () def trigger_404 ( self ): raise HTTPError . NotFound () abort abort can also be used to trigger error from assembly import Assembly , HTTPError class Index ( Assembly ): def index ( self ): raise HTTPError . abort ( 401 ) def trigger_404 ( self ): raise HTTPError . abort ( 404 ) Available Methods BadRequest: 400 Unauthorized: 401 Forbidden: 403 NotFound: 404 MethodNotAllowed: 405 NotAcceptable: 406 RequestTimeout: 408 Conflict: 409 Gone: 410 LengthRequired: 411 PreconditionFailed: 412 RequestEntityTooLarge: 413 RequestURITooLarge: 414 UnsupportedMediaType: 415 RequestedRangeNotSatisfiable: 416 ExpectationFailed: 417 ImATeapot: 418 UnprocessableEntity: 422 Locked: 423 FailedDependency: 424 PreconditionRequired: 428 TooManyRequests: 429 RequestHeaderFieldsTooLarge: 431 UnavailableForLegalReasons: 451 InternalServerError: 500 NotImplemented: 501 BadGateway: 502 ServiceUnavailable: 503 GatewayTimeout: 504 HTTPVersionNotSupported: 505 ClientDisconnected SecurityError","title":"Error Handling"},{"location":"advanced/error-handling/#overview","text":"Assembly allows you to handle your errors beautifully.","title":"Overview"},{"location":"advanced/error-handling/#_error_handler","text":"A special method _error_handler can be added in your view class to capture any HTTPException. A template with the name error_handler.html will be used. Only one _error_handler can exist in the application. _error_handler will take precedence over the other error handlers. To use specific error handler, omit _error_handler instead use the _error_$errorCode for example _error_404 # error/__init__.py from assembly import Assembly , HTTPError class Index ( Assembly ): def _error_handler ( self , e ): return { \"e\" : e } Template: <!-- error/templates/Index/error_handler.html --> {% extends 'main/layouts/base.html' %} {% block title %} Error {{ e.code }} {% endblock %} {% block body %} <h1> Error: {{ e.code }} </h1> <h4> {{ e.description }} </h4> {% endblock %}","title":"_error_handler"},{"location":"advanced/error-handling/#_error95errorcode","text":"Only one _error_handler can exist in the application. _error_handler will take precedence over the other error handlers. To use specific error handler, omit _error_handler instead use the _error_$errorCode for example _error_404 $errorCode is valid HTTP Error Code. Invalid code will throw an error A template with the name error_$errorCode.html will be used. # error/__init__.py from assembly import Assembly , HTTPError class Index ( Assembly ): def _error_404 ( self , e ): return { \"e\" : e } def _error_500 ( self , e ): return { \"e\" : e } Template: <!-- error/templates/Index/error_404.html --> {% extends 'main/layouts/base.html' %} {% block title %} Error {{ e.code }} {% endblock %} {% block body %} <h1> Error: {{ e.code }} </h1> <h4> {{ e.description }} </h4> {% endblock %} <!-- error/templates/Index/error_500.html --> {% extends 'main/layouts/base.html' %} {% block title %} Error {{ e.code }} {% endblock %} {% block body %} <h1> Error: {{ e.code }} </h1> <h4> {{ e.description }} </h4> {% endblock %}","title":"_error_$errorCode"},{"location":"advanced/error-handling/#error-method-usage","text":"from assembly import Assembly , HTTPError class Index ( Assembly ): def index ( self ): raise HTTPError . Unauthorized () def trigger_404 ( self ): raise HTTPError . NotFound ()","title":"Error Method Usage"},{"location":"advanced/error-handling/#abort","text":"abort can also be used to trigger error from assembly import Assembly , HTTPError class Index ( Assembly ): def index ( self ): raise HTTPError . abort ( 401 ) def trigger_404 ( self ): raise HTTPError . abort ( 404 )","title":"abort"},{"location":"advanced/error-handling/#available-methods","text":"","title":"Available Methods"},{"location":"advanced/error-handling/#badrequest-400","text":"","title":"BadRequest: 400"},{"location":"advanced/error-handling/#unauthorized-401","text":"","title":"Unauthorized: 401"},{"location":"advanced/error-handling/#forbidden-403","text":"","title":"Forbidden: 403"},{"location":"advanced/error-handling/#notfound-404","text":"","title":"NotFound: 404"},{"location":"advanced/error-handling/#methodnotallowed-405","text":"","title":"MethodNotAllowed: 405"},{"location":"advanced/error-handling/#notacceptable-406","text":"","title":"NotAcceptable: 406"},{"location":"advanced/error-handling/#requesttimeout-408","text":"","title":"RequestTimeout: 408"},{"location":"advanced/error-handling/#conflict-409","text":"","title":"Conflict: 409"},{"location":"advanced/error-handling/#gone-410","text":"","title":"Gone: 410"},{"location":"advanced/error-handling/#lengthrequired-411","text":"","title":"LengthRequired: 411"},{"location":"advanced/error-handling/#preconditionfailed-412","text":"","title":"PreconditionFailed: 412"},{"location":"advanced/error-handling/#requestentitytoolarge-413","text":"","title":"RequestEntityTooLarge: 413"},{"location":"advanced/error-handling/#requesturitoolarge-414","text":"","title":"RequestURITooLarge: 414"},{"location":"advanced/error-handling/#unsupportedmediatype-415","text":"","title":"UnsupportedMediaType: 415"},{"location":"advanced/error-handling/#requestedrangenotsatisfiable-416","text":"","title":"RequestedRangeNotSatisfiable: 416"},{"location":"advanced/error-handling/#expectationfailed-417","text":"","title":"ExpectationFailed: 417"},{"location":"advanced/error-handling/#imateapot-418","text":"","title":"ImATeapot: 418"},{"location":"advanced/error-handling/#unprocessableentity-422","text":"","title":"UnprocessableEntity: 422"},{"location":"advanced/error-handling/#locked-423","text":"","title":"Locked: 423"},{"location":"advanced/error-handling/#faileddependency-424","text":"","title":"FailedDependency: 424"},{"location":"advanced/error-handling/#preconditionrequired-428","text":"","title":"PreconditionRequired: 428"},{"location":"advanced/error-handling/#toomanyrequests-429","text":"","title":"TooManyRequests: 429"},{"location":"advanced/error-handling/#requestheaderfieldstoolarge-431","text":"","title":"RequestHeaderFieldsTooLarge: 431"},{"location":"advanced/error-handling/#unavailableforlegalreasons-451","text":"","title":"UnavailableForLegalReasons: 451"},{"location":"advanced/error-handling/#internalservererror-500","text":"","title":"InternalServerError: 500"},{"location":"advanced/error-handling/#notimplemented-501","text":"","title":"NotImplemented: 501"},{"location":"advanced/error-handling/#badgateway-502","text":"","title":"BadGateway: 502"},{"location":"advanced/error-handling/#serviceunavailable-503","text":"","title":"ServiceUnavailable: 503"},{"location":"advanced/error-handling/#gatewaytimeout-504","text":"","title":"GatewayTimeout: 504"},{"location":"advanced/error-handling/#httpversionnotsupported-505","text":"","title":"HTTPVersionNotSupported: 505"},{"location":"advanced/error-handling/#clientdisconnected","text":"","title":"ClientDisconnected"},{"location":"advanced/error-handling/#securityerror","text":"","title":"SecurityError"},{"location":"advanced/flash/","text":"","title":"Flash"},{"location":"advanced/mail/","text":"Overview Assembly allows you to send email from your application using SMTP or AWS SES. Extension: Flask-Mail SES-Mailer Usage Set Sender In the config file, set the MAIL_SENDER and MAIL_REPLY_TO. # config . py #: MAIL_SENDER - The sender of the email by default #: For SES , this email must be authorized MAIL_SENDER = \" me@myemail.com \" #: MAIL_REPLY_TO #: The email to reply to by default MAIL_REPLY_TO = \" me@myemail.com \" Import from assembly import asm send_mail is a function in the asm module. asm.send_mail will be used to send the email Send Simple Email To send basic email from assembly import asm to = \"user@email.com\" subject = \"Welcome\" body = \"Welcome to our site\" asm . send_mail ( to = to , subject = subject , body = body ) Send Template Email Having a template like this... # welcome . txt { % block subject % } Welcome {{ name }} to our site { % endblock % } { % block body % } Dear {{ name }} this is the content of the message Thank you very much for your visiting us { % endblock % } Send email with vars from assembly import asm asm . send_mail ( to = \"x@y.com\" , template = \"welcome.txt\" , name = \"Mardix\" ) Signal The mail also emit a signal, which can be used to pre and post process information from assembly import asm @asm.send_mail.post def process_email_sent ( result , ** kwargs ): if result : print ( \"Email sent successfully!\" ) Templates You can have pre-made templates to send email. It's easier to customize, and instead of having messages all over the place, you can now have a central place to put the messages that will be sent. The template must be a Jinja template, containing at least the following blocks: subject body Example of a template Having a template file called welcome.txt , we will create two Jinja blocks: 'subject', 'body'. We can also use {{...}} to assign variables. # welcome . txt { % block subject % } Welcome {{ name }} to our site { % endblock % } { % block body % } Dear {{ name }} this is the content of the message Thank you very much for your visiting us { % endblock % } File Templates File base templates is supported. Place the templates in a directory. By default, Assembly places them in ./__data__/emails-templates/ Place your templates files in there. The files name will be used to retrieve the template. inside of the config.py, # config . py MAIL_TEMPLATES_DIR = os . path . join ( DATA_DIR , \"mail-templates\" ) Structure of the templates directory / __data__ / email - templates | | _ welcome . txt | | _ lost - password . txt Dictionary based templates If you don't want to create files, you can dictionary based templates # config.py MAIL_TEMPLATES_DICT = { \"welcome.txt\": \"\"\" {% block subject %} I'm subject {% endblock %} {% block body %} How are you {{ name }} ? {% endblock %} \"\"\", \"lost-password.txt\": \"\"\" {% block subject %} Lost Password {% endblock %} {% block body %} Hello {{ name }} . Here's your new password: {{ new_password }} {% endblock %} \"\"\", } Send Email For either files or dictionary based templates: # welcome asm . send_mail ( to = \"x@y.com\" , template = \"welcome.txt\" , name = \"Mardix\" ) # lost - password asm . send_mail ( to = \"x@y.com\" , template = \"lost-password.txt\" , name = \"Mardix\" , new_password = \"mynewpassword\" ) Configuration # AWS SES # To use AWS SES to send email #: #: - To use the default AWS credentials ( AWS_ACCESS_KEY_ID , AWS_SECRET_ACCESS_KEY ) #: set MAIL_URI = \" ses:// \" #: * To use a different credential : #: set MAIL_URI = \" ses://{access_key}:{secret_key}@{region} \" #: #: *** comment out if you are using SMTP instead MAIL_URI = \" ses:// \" # SMTP #: If you are using SMTP , it will use Flask - Mail #: The uri for the smtp connection . It will use Flask - Mail #: format : smtp : // USERNAME : PASSWORD @ HOST : PORT #: with sll -> smtp + ssl : // USERNAME : PASSWORD @ HOST : PORT #: with ssl and tls -> smtp + ssl + tls : // USERNAME : PASSWORD @ HOST : PORT #: #: *** comment out if you are using SES instead # MAIL_URI = \" smtp+ssl://{username}:{password}@{host}:{port} \" \\ # . format ( username = \"\" , password = \"\" , host = \" smtp.gmail.com \" , port = 465 ) #: MAIL_SENDER - The sender of the email by default #: For SES , this email must be authorized MAIL_SENDER = APPLICATION_ADMIN_EMAIL #: MAIL_REPLY_TO #: The email to reply to by default MAIL_REPLY_TO = APPLICATION_ADMIN_EMAIL #: MAIL_TEMPLATE #: a directory that contains the email template or a dict MAIL_TEMPLATE = os . path . join ( DATA_DIR , \" mail-templates \" ) #: MAIL_TEMPLATE_CONTEXT #: a dict of all context to pass to the email by default MAIL_TEMPLATE_CONTEXT = { \" site_name \" : APPLICATION_NAME , \" site_url \" : APPLICATION_URL } API For the core functionalities of Flask-Mail or SES-Mailer, import the extension that was set from assembly import ext mail.mail is the object in the ext to use. For SES-Mailer from assembly import ext ext . mail . mail . send ( * args , ** kw ) ext . mail . mail . send_template ( * args , ** kw ) For Flask-Mail from assembly import ext ext . mail . mail . send_message ( * args , ** kw )","title":"Mail"},{"location":"advanced/mail/#overview","text":"Assembly allows you to send email from your application using SMTP or AWS SES. Extension: Flask-Mail SES-Mailer","title":"Overview"},{"location":"advanced/mail/#usage","text":"","title":"Usage"},{"location":"advanced/mail/#set-sender","text":"In the config file, set the MAIL_SENDER and MAIL_REPLY_TO. # config . py #: MAIL_SENDER - The sender of the email by default #: For SES , this email must be authorized MAIL_SENDER = \" me@myemail.com \" #: MAIL_REPLY_TO #: The email to reply to by default MAIL_REPLY_TO = \" me@myemail.com \"","title":"Set Sender"},{"location":"advanced/mail/#import","text":"from assembly import asm send_mail is a function in the asm module. asm.send_mail will be used to send the email","title":"Import"},{"location":"advanced/mail/#send-simple-email","text":"To send basic email from assembly import asm to = \"user@email.com\" subject = \"Welcome\" body = \"Welcome to our site\" asm . send_mail ( to = to , subject = subject , body = body )","title":"Send Simple Email"},{"location":"advanced/mail/#send-template-email","text":"Having a template like this... # welcome . txt { % block subject % } Welcome {{ name }} to our site { % endblock % } { % block body % } Dear {{ name }} this is the content of the message Thank you very much for your visiting us { % endblock % } Send email with vars from assembly import asm asm . send_mail ( to = \"x@y.com\" , template = \"welcome.txt\" , name = \"Mardix\" )","title":"Send Template Email"},{"location":"advanced/mail/#signal","text":"The mail also emit a signal, which can be used to pre and post process information from assembly import asm @asm.send_mail.post def process_email_sent ( result , ** kwargs ): if result : print ( \"Email sent successfully!\" )","title":"Signal"},{"location":"advanced/mail/#templates","text":"You can have pre-made templates to send email. It's easier to customize, and instead of having messages all over the place, you can now have a central place to put the messages that will be sent. The template must be a Jinja template, containing at least the following blocks: subject body","title":"Templates"},{"location":"advanced/mail/#example-of-a-template","text":"Having a template file called welcome.txt , we will create two Jinja blocks: 'subject', 'body'. We can also use {{...}} to assign variables. # welcome . txt { % block subject % } Welcome {{ name }} to our site { % endblock % } { % block body % } Dear {{ name }} this is the content of the message Thank you very much for your visiting us { % endblock % }","title":"Example of a template"},{"location":"advanced/mail/#file-templates","text":"File base templates is supported. Place the templates in a directory. By default, Assembly places them in ./__data__/emails-templates/ Place your templates files in there. The files name will be used to retrieve the template. inside of the config.py, # config . py MAIL_TEMPLATES_DIR = os . path . join ( DATA_DIR , \"mail-templates\" ) Structure of the templates directory / __data__ / email - templates | | _ welcome . txt | | _ lost - password . txt","title":"File Templates"},{"location":"advanced/mail/#dictionary-based-templates","text":"If you don't want to create files, you can dictionary based templates # config.py MAIL_TEMPLATES_DICT = { \"welcome.txt\": \"\"\" {% block subject %} I'm subject {% endblock %} {% block body %} How are you {{ name }} ? {% endblock %} \"\"\", \"lost-password.txt\": \"\"\" {% block subject %} Lost Password {% endblock %} {% block body %} Hello {{ name }} . Here's your new password: {{ new_password }} {% endblock %} \"\"\", }","title":"Dictionary based templates"},{"location":"advanced/mail/#send-email","text":"For either files or dictionary based templates: # welcome asm . send_mail ( to = \"x@y.com\" , template = \"welcome.txt\" , name = \"Mardix\" ) # lost - password asm . send_mail ( to = \"x@y.com\" , template = \"lost-password.txt\" , name = \"Mardix\" , new_password = \"mynewpassword\" )","title":"Send Email"},{"location":"advanced/mail/#configuration","text":"# AWS SES # To use AWS SES to send email #: #: - To use the default AWS credentials ( AWS_ACCESS_KEY_ID , AWS_SECRET_ACCESS_KEY ) #: set MAIL_URI = \" ses:// \" #: * To use a different credential : #: set MAIL_URI = \" ses://{access_key}:{secret_key}@{region} \" #: #: *** comment out if you are using SMTP instead MAIL_URI = \" ses:// \" # SMTP #: If you are using SMTP , it will use Flask - Mail #: The uri for the smtp connection . It will use Flask - Mail #: format : smtp : // USERNAME : PASSWORD @ HOST : PORT #: with sll -> smtp + ssl : // USERNAME : PASSWORD @ HOST : PORT #: with ssl and tls -> smtp + ssl + tls : // USERNAME : PASSWORD @ HOST : PORT #: #: *** comment out if you are using SES instead # MAIL_URI = \" smtp+ssl://{username}:{password}@{host}:{port} \" \\ # . format ( username = \"\" , password = \"\" , host = \" smtp.gmail.com \" , port = 465 ) #: MAIL_SENDER - The sender of the email by default #: For SES , this email must be authorized MAIL_SENDER = APPLICATION_ADMIN_EMAIL #: MAIL_REPLY_TO #: The email to reply to by default MAIL_REPLY_TO = APPLICATION_ADMIN_EMAIL #: MAIL_TEMPLATE #: a directory that contains the email template or a dict MAIL_TEMPLATE = os . path . join ( DATA_DIR , \" mail-templates \" ) #: MAIL_TEMPLATE_CONTEXT #: a dict of all context to pass to the email by default MAIL_TEMPLATE_CONTEXT = { \" site_name \" : APPLICATION_NAME , \" site_url \" : APPLICATION_URL }","title":"Configuration"},{"location":"advanced/mail/#api","text":"For the core functionalities of Flask-Mail or SES-Mailer, import the extension that was set from assembly import ext mail.mail is the object in the ext to use.","title":"API"},{"location":"advanced/mail/#for-ses-mailer","text":"from assembly import ext ext . mail . mail . send ( * args , ** kw ) ext . mail . mail . send_template ( * args , ** kw )","title":"For SES-Mailer"},{"location":"advanced/mail/#for-flask-mail","text":"from assembly import ext ext . mail . mail . send_message ( * args , ** kw )","title":"For Flask-Mail"},{"location":"advanced/pagination/","text":"Overview Assembly uses the Paginator to paginate iterable items Extension: Paginator Usage Paginate Models Paginate models from assembly import Assembly , models , request class Index ( Assembly ): def posts ( self ): per_page = 10 page = int ( request . args . get ( \"page\" , 1 )) posts = models . Posts . query () posts = posts . paginate ( page = page , per_page = per_page ) return { \"posts\" : posts } Paginate List To paginate a list of items from assembly import Assembly , request from paginator import Paginator class Index ( Assembly ): def posts ( self ): per_page = 10 page = int ( request . args . get ( \"page\" , 1 )) items = range ( 1 , 1000 ) items = Paginator ( items , page = page , per_page = per_page ) return { \"items\" : [ i for i in items ] } API Paginator(query, page=1, per_page=10, total=None, padding=0, callback=None, static_query=False) :param query : Iterable to paginate . Can be a query object , list or any iterables :param page : current page :param per_page : max number of items per page :param total : Max number of items . If not provided , it will use the query to count :param padding : Number of elements of the next page to show :param callback : a function to callback on each item being iterated . :param static_query : bool - When True it will return the query as is , without slicing / limit . Usally when using the paginator to just create the pagination . :return : Properties total_pages has_prev has_next next_page_number prev_page_number pages_range items pages (iterables) Create Jinja Macro {#: PAGINATION -------------------------------------------------------------- #} {# : paginator : iterator : endpoint : : prev : Text for previous button : next : Text for Next button : class_ : A class name for pagination if customed . If you are extending the class best to add the original class and your custom class ie : ' pagination my_custom_pagination ' or ' pager my_custom_page ' : pager : If true it will show a pager instead of numbered pagination #} { % macro pagination ( paginator , endpoint = None , prev = \"\" , next = \"\" , class_ = None , pager = False ) % } { % if not endpoint % } { % set endpoint = request . endpoint % } { % endif % } { % if \" page \" in kwargs % } { % set _ = kwargs . pop ( \" page \" ) % } { % endif % } { % if not class_ % } { % set class_ = \" pagination \" % } { % if pager % } { % set class_ = \" pager \" % } { % endif % } { % endif % } { % set _prev_btn = \" <span aria-hidden='true'>&larr;</span> %s \" % prev % } { % set _next_btn = \" <span aria-hidden='true'>&rarr;</span> %s \" % next % } < nav > < ul class = \" {{ class_ }} \" > { %- if paginator . has_prev % } < li class = \" previous \" > < a href = \" {{ url_for(endpoint, page=paginator.prev_page_number, **kwargs) }} \" > {{ _prev_btn | safe }} </ a > </ li > { % else % } < li class = \" disabled previous \" > < a href = \" # \" > {{ _prev_btn | safe }} </ a > </ li > { %- endif % } { % if not pager % } { %- for page in paginator . iter_pages () % } { % if page % } { % if page != paginator . page % } < li >< a href = \" {{ url_for(endpoint, page=page, **kwargs) }} \" rel = \" me \" > {{ page }} </ a ></ li > { % else % } < li class = \" active \" >< span > {{ page }} </ span ></ li > { % endif % } { % else % } < li >< span class = ellipsis > \u2026 </ span ></ li > { % endif % } { %- endfor % } { % endif % } { %- if paginator . has_next % } < li class = \" next \" > < a href = \" {{ url_for(endpoint, page=paginator.next_page_number, **kwargs) }} \" > {{ _next_btn | safe }} </ a > </ li > { % else % } < li class = \" disabled next \" > < a href = \" # \" > {{ _next_btn | safe }} </ a > </ li > { %- endif % } </ ul > </ nav > { % endmacro % }","title":"Pagination"},{"location":"advanced/pagination/#overview","text":"Assembly uses the Paginator to paginate iterable items Extension: Paginator","title":"Overview"},{"location":"advanced/pagination/#usage","text":"","title":"Usage"},{"location":"advanced/pagination/#paginate-models","text":"Paginate models from assembly import Assembly , models , request class Index ( Assembly ): def posts ( self ): per_page = 10 page = int ( request . args . get ( \"page\" , 1 )) posts = models . Posts . query () posts = posts . paginate ( page = page , per_page = per_page ) return { \"posts\" : posts }","title":"Paginate Models"},{"location":"advanced/pagination/#paginate-list","text":"To paginate a list of items from assembly import Assembly , request from paginator import Paginator class Index ( Assembly ): def posts ( self ): per_page = 10 page = int ( request . args . get ( \"page\" , 1 )) items = range ( 1 , 1000 ) items = Paginator ( items , page = page , per_page = per_page ) return { \"items\" : [ i for i in items ] }","title":"Paginate List"},{"location":"advanced/pagination/#api","text":"Paginator(query, page=1, per_page=10, total=None, padding=0, callback=None, static_query=False) :param query : Iterable to paginate . Can be a query object , list or any iterables :param page : current page :param per_page : max number of items per page :param total : Max number of items . If not provided , it will use the query to count :param padding : Number of elements of the next page to show :param callback : a function to callback on each item being iterated . :param static_query : bool - When True it will return the query as is , without slicing / limit . Usally when using the paginator to just create the pagination . :return :","title":"API"},{"location":"advanced/pagination/#properties","text":"total_pages has_prev has_next next_page_number prev_page_number pages_range items pages (iterables)","title":"Properties"},{"location":"advanced/pagination/#create-jinja-macro","text":"{#: PAGINATION -------------------------------------------------------------- #} {# : paginator : iterator : endpoint : : prev : Text for previous button : next : Text for Next button : class_ : A class name for pagination if customed . If you are extending the class best to add the original class and your custom class ie : ' pagination my_custom_pagination ' or ' pager my_custom_page ' : pager : If true it will show a pager instead of numbered pagination #} { % macro pagination ( paginator , endpoint = None , prev = \"\" , next = \"\" , class_ = None , pager = False ) % } { % if not endpoint % } { % set endpoint = request . endpoint % } { % endif % } { % if \" page \" in kwargs % } { % set _ = kwargs . pop ( \" page \" ) % } { % endif % } { % if not class_ % } { % set class_ = \" pagination \" % } { % if pager % } { % set class_ = \" pager \" % } { % endif % } { % endif % } { % set _prev_btn = \" <span aria-hidden='true'>&larr;</span> %s \" % prev % } { % set _next_btn = \" <span aria-hidden='true'>&rarr;</span> %s \" % next % } < nav > < ul class = \" {{ class_ }} \" > { %- if paginator . has_prev % } < li class = \" previous \" > < a href = \" {{ url_for(endpoint, page=paginator.prev_page_number, **kwargs) }} \" > {{ _prev_btn | safe }} </ a > </ li > { % else % } < li class = \" disabled previous \" > < a href = \" # \" > {{ _prev_btn | safe }} </ a > </ li > { %- endif % } { % if not pager % } { %- for page in paginator . iter_pages () % } { % if page % } { % if page != paginator . page % } < li >< a href = \" {{ url_for(endpoint, page=page, **kwargs) }} \" rel = \" me \" > {{ page }} </ a ></ li > { % else % } < li class = \" active \" >< span > {{ page }} </ span ></ li > { % endif % } { % else % } < li >< span class = ellipsis > \u2026 </ span ></ li > { % endif % } { %- endfor % } { % endif % } { %- if paginator . has_next % } < li class = \" next \" > < a href = \" {{ url_for(endpoint, page=paginator.next_page_number, **kwargs) }} \" > {{ _next_btn | safe }} </ a > </ li > { % else % } < li class = \" disabled next \" > < a href = \" # \" > {{ _next_btn | safe }} </ a > </ li > { %- endif % } </ ul > </ nav > { % endmacro % }","title":"Create Jinja Macro"},{"location":"advanced/sessions/","text":"from assembly import session","title":"Sessions"},{"location":"advanced/signals/","text":"Overview Signals help you decouple applications by sending notifications when actions occur elsewhere in the appliation. In short, signals allow certain senders to notify subscribers that something happened. Assembly uses Blinker to provide a fast dispatching system that allows any number of interested parties to subscribe to events, or \u201csignals\u201d. Extension: Blinker Usage Import from assembly import signal Create a signal Import and use the @signal decorator on the function to send signal from. It will add a @pre and @post decorators on that function to be used by other function that will listens it. Whenever the function with the @signal get executed, all functions with @pre and @post will be executed before and after the @signal function is executed repectively. from assembly import signal @signal def hello_world ( name ): return \"Hello World %s \" % s Listens to a signal Now hello_world has @hello_world.pre and @hello_world.post . These decorators can attached to functions. @ hello_world . pre def before_hello_world ( * a , ** kw ) : \"\"\" This will be executed before \"\"\" @ hello_world . post def after_hello_world ( result , * kw ) : \"\"\" This will be executed after \"\"\" if result : print ( result ) @ hello_world . post def after_another_hello_world ( result , * kw ) : \"\"\" This will be executed after \"\"\" if result : print ( result ) Full Example Now we can run the functions and our signals will be executed from assembly import signal # Emit the signal @signal def hello_world ( name ): return \"Hello World %s \" % s # Listeners @hello_world.pre def before_hello_world ( * a , ** kw ): \"\"\"This will be executed before\"\"\" @hello_world.post def after_hello_world ( result , * kw ): \"\"\"This will be executed after\"\"\" if result : print ( result ) @hello_world.post def after_another_hello_world ( result , * kw ): \"\"\"This will be executed after\"\"\" if result : print ( result ) hello_world ( 'Assembly' ) hello_world ( 'Mardix' ) API @signal @pre Functions with @pre will be executed before the signaled functions is executed. The function receiving the signal, must have 1 args: - * a - ** kwargs : args : * a , kwargs : ** kw , name : the name of the signal , signal : the signal ' s instance Example @myfn . pre def post_action ( * a , ** kw ) : pass @post Functions with @post will be executed after the signaled functions is finished. The function receiving the signal, must have 2 args: - result : that 's the result sent from the signal - **kwargs: args: *a, kwargs: **kw, name: the name of the signal, signal: the signal' s instance Example @ myfn . post def post_action ( result , ** kw ) : if result : print ( \" Done! \" ) @pre_ and @post_ To fully utilize Blinker functionalities, use post_ and pre_ , for example @do_something.post_.connect , @do_something.pre_.connect","title":"Signals"},{"location":"advanced/signals/#overview","text":"Signals help you decouple applications by sending notifications when actions occur elsewhere in the appliation. In short, signals allow certain senders to notify subscribers that something happened. Assembly uses Blinker to provide a fast dispatching system that allows any number of interested parties to subscribe to events, or \u201csignals\u201d. Extension: Blinker","title":"Overview"},{"location":"advanced/signals/#usage","text":"","title":"Usage"},{"location":"advanced/signals/#import","text":"from assembly import signal","title":"Import"},{"location":"advanced/signals/#create-a-signal","text":"Import and use the @signal decorator on the function to send signal from. It will add a @pre and @post decorators on that function to be used by other function that will listens it. Whenever the function with the @signal get executed, all functions with @pre and @post will be executed before and after the @signal function is executed repectively. from assembly import signal @signal def hello_world ( name ): return \"Hello World %s \" % s","title":"Create a signal"},{"location":"advanced/signals/#listens-to-a-signal","text":"Now hello_world has @hello_world.pre and @hello_world.post . These decorators can attached to functions. @ hello_world . pre def before_hello_world ( * a , ** kw ) : \"\"\" This will be executed before \"\"\" @ hello_world . post def after_hello_world ( result , * kw ) : \"\"\" This will be executed after \"\"\" if result : print ( result ) @ hello_world . post def after_another_hello_world ( result , * kw ) : \"\"\" This will be executed after \"\"\" if result : print ( result )","title":"Listens to a signal"},{"location":"advanced/signals/#full-example","text":"Now we can run the functions and our signals will be executed from assembly import signal # Emit the signal @signal def hello_world ( name ): return \"Hello World %s \" % s # Listeners @hello_world.pre def before_hello_world ( * a , ** kw ): \"\"\"This will be executed before\"\"\" @hello_world.post def after_hello_world ( result , * kw ): \"\"\"This will be executed after\"\"\" if result : print ( result ) @hello_world.post def after_another_hello_world ( result , * kw ): \"\"\"This will be executed after\"\"\" if result : print ( result ) hello_world ( 'Assembly' ) hello_world ( 'Mardix' )","title":"Full Example"},{"location":"advanced/signals/#api","text":"","title":"API"},{"location":"advanced/signals/#signal","text":"","title":"@signal"},{"location":"advanced/signals/#pre","text":"Functions with @pre will be executed before the signaled functions is executed. The function receiving the signal, must have 1 args: - * a - ** kwargs : args : * a , kwargs : ** kw , name : the name of the signal , signal : the signal ' s instance Example @myfn . pre def post_action ( * a , ** kw ) : pass","title":"@pre"},{"location":"advanced/signals/#post","text":"Functions with @post will be executed after the signaled functions is finished. The function receiving the signal, must have 2 args: - result : that 's the result sent from the signal - **kwargs: args: *a, kwargs: **kw, name: the name of the signal, signal: the signal' s instance Example @ myfn . post def post_action ( result , ** kw ) : if result : print ( \" Done! \" )","title":"@post"},{"location":"advanced/signals/#pre_-and-post_","text":"To fully utilize Blinker functionalities, use post_ and pre_ , for example @do_something.post_.connect , @do_something.pre_.connect","title":"@pre_ and @post_"},{"location":"advanced/storage/","text":"Overview Aseembly uses Flask-Cloudy to let you access, upload, download, save and delete files on cloud storage providers such as: AWS S3, Google Storage, Microsoft Azure, Rackspace Cloudfiles, and even Local file system. Extension: flask-cloudy Usage from assembly import asm get_file , upload_file , download_file , delete_file are functions in the asm module. Get file asm.get_file will return a Storage Object. from assembly import asm myfile = asm . get_file ( \"hello.txt\" ) myfile . name # return The file name myfile . size # returns file size myfile . full_url # the full url of the file Upload file asm.upload_file to save or upload a file in the container Example of file upload # main/__init__.py from assembly import Assembly , asm , request , redirect class Index ( Assembly ): def index ( self ): return @request.post def upload ( self ): file = request . files . get ( \"file\" ) if file : profile_image = asm . upload_file ( file , name = utils . gen_uuid (), prefix = \"img.\" , public = True , extensions = [ \"jpg\" , \"jpeg\" , \"png\" , \"gif\" ]) return redirect ( self . upload_success ) def upload_success ( self ): return \"Upload successful!\" Template <!-- main/templates/Index/index.html --> {% extends 'main/layouts/base.html' %} {% block title %} Upload {% endblock %} {% block body %} <h1> Upload </h1> <form id= \"uploadbanner\" action= \"/upload/\" enctype= \"multipart/form-data\" method= \"post\" > <input type= 'hidden' name= \"_csrf_token\" value= ' {{ csrf_token () }} ' > <input id= \"fileupload\" name= \"file\" type= \"file\" /> <input type= \"submit\" value= \"Upload\" id= \"submit\" /> </form> {% endblock %} Note : Since this will call a POST, we also add the CSRF token in the form <input type='hidden' name=\"_csrf_token\" value=' {{ csrf_token () }} '> Signal asm.upload_file emits a signal to be used from assembly import asm @asm.upload_file.post def file_uploaded ( result , ** kw ): if result : print ( \"File uploaded successfully!\" ) Download File asm.download_file to download a file to the user. You will need to redirect to that path. from assembly import Assembly , asm , redirect class Index ( Assembly ): def dowload ( self ): filename = \"hello.txt\" name = \"new-name-hello\" url = asm . download_file ( filename , name = name , timeout = 60 ) redirect ( url ) Signal asm.download_file emits a signal to be used from assembly import asm @asm.download_file.post def file_downloaded ( result , ** kw ): if result : print ( \"File uploaded successfully!\" ) Delete File asm.delete_file deletes a file from storage from assembly import asm asm . delete_file ( \"hello.txt\" ) Signal asm.delete_file emits a signal to be used from assembly import asm @asm.delete_file.post def file_deleted ( result , ** kw ): if result : print ( \"File deleted successfully!\" ) Config # config . py #: STORAGE_PROVIDER : # The provider to use . By default it ' s ' LOCAL ' . # You can use : # LOCAL , S3 , GOOGLE_STORAGE , AZURE_BLOBS , CLOUDFILES STORAGE_PROVIDER = \" LOCAL \" #: STORAGE_KEY # The storage key . Leave it blank if PROVIDER is LOCAL STORAGE_KEY = AWS_ACCESS_KEY_ID #: STORAGE_SECRET #: The storage secret key . Leave it blank if PROVIDER is LOCAL STORAGE_SECRET = AWS_SECRET_ACCESS_KEY #: STORAGE_REGION_NAME #: The region for the storage . Leave it blank if PROVIDER is LOCAL STORAGE_REGION_NAME = AWS_REGION_NAME #: STORAGE_CONTAINER #: The Bucket name ( for S3 , Google storage , Azure , cloudfile ) #: or the directory name ( LOCAL ) to access STORAGE_CONTAINER = os . path . join ( DATA_DIR , \" uploads \" ) #: STORAGE_SERVER #: Bool , to serve local file STORAGE_SERVER = True #: STORAGE_SERVER_URL #: The url suffix for local storage STORAGE_SERVER_URL = \" files \" Storage Object The class Object is an entity of an object in the container. Usually, you will get a cloud object by accessing an object in the container. my_object = asm . get_file ( \"my_object.txt\" ) Properties and Methods: Object.name: The name of the object Object.size: The size in bytes of the object Object.extension: The extension of the object Object.url: Return the url of the object Object.full_url: Returns the full url of the object Object.secure_url:Return a secured url, with https:// Object.path: The path of the object relative to the container Object.full_path: For Local, it will show the full path of the object, otherwise it just returns the Object.path Object.provider_name: The provider name: ie: Local, S3,... Object.type: The type of the object, ie: IMAGE, AUDIO, TEXT,... OTHER Object.info: Returns a dict of the object name, extension, url, etc. This can be saved in a DB Object.save_to: (method) to save to a destination Object.download_url: (method) Return a URL that triggers the browser download of the file. On cloud providers it will return a signed url.","title":"Storage"},{"location":"advanced/storage/#overview","text":"Aseembly uses Flask-Cloudy to let you access, upload, download, save and delete files on cloud storage providers such as: AWS S3, Google Storage, Microsoft Azure, Rackspace Cloudfiles, and even Local file system. Extension: flask-cloudy","title":"Overview"},{"location":"advanced/storage/#usage","text":"from assembly import asm get_file , upload_file , download_file , delete_file are functions in the asm module.","title":"Usage"},{"location":"advanced/storage/#get-file","text":"asm.get_file will return a Storage Object. from assembly import asm myfile = asm . get_file ( \"hello.txt\" ) myfile . name # return The file name myfile . size # returns file size myfile . full_url # the full url of the file","title":"Get file"},{"location":"advanced/storage/#upload-file","text":"asm.upload_file to save or upload a file in the container","title":"Upload file"},{"location":"advanced/storage/#example-of-file-upload","text":"# main/__init__.py from assembly import Assembly , asm , request , redirect class Index ( Assembly ): def index ( self ): return @request.post def upload ( self ): file = request . files . get ( \"file\" ) if file : profile_image = asm . upload_file ( file , name = utils . gen_uuid (), prefix = \"img.\" , public = True , extensions = [ \"jpg\" , \"jpeg\" , \"png\" , \"gif\" ]) return redirect ( self . upload_success ) def upload_success ( self ): return \"Upload successful!\" Template <!-- main/templates/Index/index.html --> {% extends 'main/layouts/base.html' %} {% block title %} Upload {% endblock %} {% block body %} <h1> Upload </h1> <form id= \"uploadbanner\" action= \"/upload/\" enctype= \"multipart/form-data\" method= \"post\" > <input type= 'hidden' name= \"_csrf_token\" value= ' {{ csrf_token () }} ' > <input id= \"fileupload\" name= \"file\" type= \"file\" /> <input type= \"submit\" value= \"Upload\" id= \"submit\" /> </form> {% endblock %} Note : Since this will call a POST, we also add the CSRF token in the form <input type='hidden' name=\"_csrf_token\" value=' {{ csrf_token () }} '>","title":"Example of file upload"},{"location":"advanced/storage/#signal","text":"asm.upload_file emits a signal to be used from assembly import asm @asm.upload_file.post def file_uploaded ( result , ** kw ): if result : print ( \"File uploaded successfully!\" )","title":"Signal"},{"location":"advanced/storage/#download-file","text":"asm.download_file to download a file to the user. You will need to redirect to that path. from assembly import Assembly , asm , redirect class Index ( Assembly ): def dowload ( self ): filename = \"hello.txt\" name = \"new-name-hello\" url = asm . download_file ( filename , name = name , timeout = 60 ) redirect ( url )","title":"Download File"},{"location":"advanced/storage/#signal_1","text":"asm.download_file emits a signal to be used from assembly import asm @asm.download_file.post def file_downloaded ( result , ** kw ): if result : print ( \"File uploaded successfully!\" )","title":"Signal"},{"location":"advanced/storage/#delete-file","text":"asm.delete_file deletes a file from storage from assembly import asm asm . delete_file ( \"hello.txt\" )","title":"Delete File"},{"location":"advanced/storage/#signal_2","text":"asm.delete_file emits a signal to be used from assembly import asm @asm.delete_file.post def file_deleted ( result , ** kw ): if result : print ( \"File deleted successfully!\" )","title":"Signal"},{"location":"advanced/storage/#config","text":"# config . py #: STORAGE_PROVIDER : # The provider to use . By default it ' s ' LOCAL ' . # You can use : # LOCAL , S3 , GOOGLE_STORAGE , AZURE_BLOBS , CLOUDFILES STORAGE_PROVIDER = \" LOCAL \" #: STORAGE_KEY # The storage key . Leave it blank if PROVIDER is LOCAL STORAGE_KEY = AWS_ACCESS_KEY_ID #: STORAGE_SECRET #: The storage secret key . Leave it blank if PROVIDER is LOCAL STORAGE_SECRET = AWS_SECRET_ACCESS_KEY #: STORAGE_REGION_NAME #: The region for the storage . Leave it blank if PROVIDER is LOCAL STORAGE_REGION_NAME = AWS_REGION_NAME #: STORAGE_CONTAINER #: The Bucket name ( for S3 , Google storage , Azure , cloudfile ) #: or the directory name ( LOCAL ) to access STORAGE_CONTAINER = os . path . join ( DATA_DIR , \" uploads \" ) #: STORAGE_SERVER #: Bool , to serve local file STORAGE_SERVER = True #: STORAGE_SERVER_URL #: The url suffix for local storage STORAGE_SERVER_URL = \" files \"","title":"Config"},{"location":"advanced/storage/#storage-object","text":"The class Object is an entity of an object in the container. Usually, you will get a cloud object by accessing an object in the container. my_object = asm . get_file ( \"my_object.txt\" ) Properties and Methods: Object.name: The name of the object Object.size: The size in bytes of the object Object.extension: The extension of the object Object.url: Return the url of the object Object.full_url: Returns the full url of the object Object.secure_url:Return a secured url, with https:// Object.path: The path of the object relative to the container Object.full_path: For Local, it will show the full path of the object, otherwise it just returns the Object.path Object.provider_name: The provider name: ie: Local, S3,... Object.type: The type of the object, ie: IMAGE, AUDIO, TEXT,... OTHER Object.info: Returns a dict of the object name, extension, url, etc. This can be saved in a DB Object.save_to: (method) to save to a destination Object.download_url: (method) Return a URL that triggers the browser download of the file. On cloud providers it will return a signed url.","title":"Storage Object"},{"location":"advanced/utils/","text":"Utils contains some common functionw and also exposes under the utils namespace some 3rd party function for convenience Functions Import the utils as follow: from assembly import utils gen_md5 gen_uuid gen_uuid_hex to_json chunk_list in_any_list dict_replace list_replace DotDict is_valid_email is_valid_password is_valid_username -- is_valid_url -- slugify from lib: slugify Inflection utils camelize titleize dasherize underscore plurialize singularize ordinalize ordinal","title":"Utils"},{"location":"advanced/utils/#functions","text":"Import the utils as follow: from assembly import utils","title":"Functions"},{"location":"advanced/utils/#gen_md5","text":"","title":"gen_md5"},{"location":"advanced/utils/#gen_uuid","text":"","title":"gen_uuid"},{"location":"advanced/utils/#gen_uuid_hex","text":"","title":"gen_uuid_hex"},{"location":"advanced/utils/#to_json","text":"","title":"to_json"},{"location":"advanced/utils/#chunk_list","text":"","title":"chunk_list"},{"location":"advanced/utils/#in_any_list","text":"","title":"in_any_list"},{"location":"advanced/utils/#dict_replace","text":"","title":"dict_replace"},{"location":"advanced/utils/#list_replace","text":"","title":"list_replace"},{"location":"advanced/utils/#dotdict","text":"","title":"DotDict"},{"location":"advanced/utils/#is_valid_email","text":"","title":"is_valid_email"},{"location":"advanced/utils/#is_valid_password","text":"","title":"is_valid_password"},{"location":"advanced/utils/#is_valid_username","text":"--","title":"is_valid_username"},{"location":"advanced/utils/#is_valid_url","text":"--","title":"is_valid_url"},{"location":"advanced/utils/#slugify","text":"from lib: slugify","title":"slugify"},{"location":"advanced/utils/#inflection-utils","text":"","title":"Inflection utils"},{"location":"advanced/utils/#camelize","text":"","title":"camelize"},{"location":"advanced/utils/#titleize","text":"","title":"titleize"},{"location":"advanced/utils/#dasherize","text":"","title":"dasherize"},{"location":"advanced/utils/#underscore","text":"","title":"underscore"},{"location":"advanced/utils/#plurialize","text":"","title":"plurialize"},{"location":"advanced/utils/#singularize","text":"","title":"singularize"},{"location":"advanced/utils/#ordinalize","text":"","title":"ordinalize"},{"location":"advanced/utils/#ordinal","text":"","title":"ordinal"},{"location":"application/core/","text":"\"Assembly\" , \"g\" , \"db\" , \"env\" , \"ext\" , \"date\" , \"views\" , \"flash\" , \"config\" , \"models\" , \"session\" , \"extends\" , \"url_for\" , \"redirect\" , \"HTTPError\"","title":"Core"},{"location":"application/models/","text":"Path: $$APP_NAME/__models__.py CONVENTION By convention, Assembly expects you to have one models file per application. And the file must be named models .py , for it to be loaded automatically. Configuration db model Types Special Types Beside the default SQLAlchemy column types, SQLAlchemy-Utils DateTime Alias to ArrowType, which provides way of saving Arrow objects into database. It automatically changes Arrow objects to datetime objects on the way in and datetime objects back to Arrow objects on the way out (when querying database). Example from mocha import db class Article ( db . Model ): title = db . Column ( db . String ( 255 )) published_at = db . Column ( db . DateTime ) Create from mocha import utc_now , models models . Article . create ( title = 'Hi' , published_at = utc_now ) Read from mocha import models article = models . Article . get ( 1 ) article . created_at = article . created_at . replace ( hours =- 1 ) article . created_at . humanize () # 'an hour ago' Links ArrowType Arrow Arrow Tokens StorageObjectType StorageObjectType offers way of saving Storage.Object data structures to database. It automatically changes Arrow objects to JSON objects on the way in and Storage.Object objects back on the way out (when querying database). Example from mocha import db class Article ( db . Model ): title = db . Column ( db . String ( 255 )) published_at = db . Column ( db . DateTime ) image = db . Column ( db . StorageObjectType ) Create from mocha import utc_now , models , upload_file image_file = \"file/xyz.jpg\" image = upload_file ( image_file ) models . Article . create ( title = 'Hi' , published_at = utc_now , image = image ) Read from mocha import models article = models . Article . get ( 1 ) article . image . url article . image . size article . image . download () EmailType Provides a way for storing emails in a lower case. Example from mocha import db class Article ( db . Model ): title = db . Column ( db . String ( 255 )) published_at = db . Column ( db . DateTime ) email = db . Column ( db . EmailType ) Link: EmailType JSONType JSONType offers way of saving JSON data structures to database. On PostgreSQL the underlying implementation of this data type is \u2018json\u2019 while on other databases its simply \u2018text\u2019. Example from mocha import db class Article ( db . Model ): title = db . Column ( db . String ( 255 )) published_at = db . Column ( db . DateTime ) data = db . Column ( db . JSONType ) Create from mocha import models , utc_now models . Article . create ( title = 'Hello' , published_at = utc_now , data = { \"reference\" : \"blah\" , \"tags\" : [ \"A\" , \"B\" , \"C\" ] }) Read article = models . Article . get ( 1 ) article . data . get ( \"reference\" ) # blah article . data . get ( \"tags\" ) # [ \"A\" , \"B\" , \"C\" ] article . data . get ( \"location\" , \"Charlotte\" ) # Charlotte Link: JSONType Generic Types SQLAlchemy-Utils Types If you want to use the other types from SQLAlchemy-Utils ArrowType ChoiceType ColorType CountryType CurrencyType EmailType EncryptedType JSONType LocaleType LtreeType IPAddressType PasswordType PhoneNumberType ScalarListType TimezoneType TSVectorType URLType UUIDType WeekDaysType","title":"Models"},{"location":"application/models/#convention","text":"By convention, Assembly expects you to have one models file per application. And the file must be named models .py , for it to be loaded automatically.","title":"CONVENTION"},{"location":"application/models/#configuration","text":"","title":"Configuration"},{"location":"application/models/#db","text":"","title":"db"},{"location":"application/models/#model","text":"","title":"model"},{"location":"application/models/#types","text":"","title":"Types"},{"location":"application/models/#special-types","text":"Beside the default SQLAlchemy column types, SQLAlchemy-Utils","title":"Special Types"},{"location":"application/models/#datetime","text":"Alias to ArrowType, which provides way of saving Arrow objects into database. It automatically changes Arrow objects to datetime objects on the way in and datetime objects back to Arrow objects on the way out (when querying database). Example from mocha import db class Article ( db . Model ): title = db . Column ( db . String ( 255 )) published_at = db . Column ( db . DateTime ) Create from mocha import utc_now , models models . Article . create ( title = 'Hi' , published_at = utc_now ) Read from mocha import models article = models . Article . get ( 1 ) article . created_at = article . created_at . replace ( hours =- 1 ) article . created_at . humanize () # 'an hour ago' Links ArrowType Arrow Arrow Tokens","title":"DateTime"},{"location":"application/models/#storageobjecttype","text":"StorageObjectType offers way of saving Storage.Object data structures to database. It automatically changes Arrow objects to JSON objects on the way in and Storage.Object objects back on the way out (when querying database). Example from mocha import db class Article ( db . Model ): title = db . Column ( db . String ( 255 )) published_at = db . Column ( db . DateTime ) image = db . Column ( db . StorageObjectType ) Create from mocha import utc_now , models , upload_file image_file = \"file/xyz.jpg\" image = upload_file ( image_file ) models . Article . create ( title = 'Hi' , published_at = utc_now , image = image ) Read from mocha import models article = models . Article . get ( 1 ) article . image . url article . image . size article . image . download ()","title":"StorageObjectType"},{"location":"application/models/#emailtype","text":"Provides a way for storing emails in a lower case. Example from mocha import db class Article ( db . Model ): title = db . Column ( db . String ( 255 )) published_at = db . Column ( db . DateTime ) email = db . Column ( db . EmailType ) Link: EmailType","title":"EmailType"},{"location":"application/models/#jsontype","text":"JSONType offers way of saving JSON data structures to database. On PostgreSQL the underlying implementation of this data type is \u2018json\u2019 while on other databases its simply \u2018text\u2019. Example from mocha import db class Article ( db . Model ): title = db . Column ( db . String ( 255 )) published_at = db . Column ( db . DateTime ) data = db . Column ( db . JSONType ) Create from mocha import models , utc_now models . Article . create ( title = 'Hello' , published_at = utc_now , data = { \"reference\" : \"blah\" , \"tags\" : [ \"A\" , \"B\" , \"C\" ] }) Read article = models . Article . get ( 1 ) article . data . get ( \"reference\" ) # blah article . data . get ( \"tags\" ) # [ \"A\" , \"B\" , \"C\" ] article . data . get ( \"location\" , \"Charlotte\" ) # Charlotte Link: JSONType","title":"JSONType"},{"location":"application/models/#generic-types","text":"","title":"Generic Types"},{"location":"application/models/#sqlalchemy-utils-types","text":"If you want to use the other types from SQLAlchemy-Utils ArrowType ChoiceType ColorType CountryType CurrencyType EmailType EncryptedType JSONType LocaleType LtreeType IPAddressType PasswordType PhoneNumberType ScalarListType TimezoneType TSVectorType URLType UUIDType WeekDaysType","title":"SQLAlchemy-Utils Types"},{"location":"application/request/","text":"request is a proxy to flask.request object, with some additional decorators and attributes Import from mocha import request Methods get @request.get set a view to accept only GET method class Index ( Mocha ) : @ request . get def index ( self ) : # do something post @request.post set a view to accept only POST method class Index ( Mocha ) : @ request . post def index ( self ) : # do something put @request.put set a view to accept only PUT method class Index ( Mocha ) : @ request . put def index ( self ) : # do something delete @request.delete set a view to accept only DELETE method class Index ( Mocha ) : @ request . delete def index ( self ) : # do something all @request.all set a view to accept only ALL methods. It will accept: GET, POST, PUT, DELETE, OPTIONS class Index ( Mocha ) : @ request . all def index ( self ) : # do something Combine An alternative to @all is to use all methods as class Index ( Mocha ) : @ request . get @ request . post @ request . put @ request . delete @ request . options def index ( self ) : # do something Test Method Usually if a view method accept more than one request method, it is best to test for the method IS_GET request.IS_GET tests if the request method is GET class Index ( Mocha ) : def index ( self ) : if request . IS_GET : # do something It is equivalent to request.method == 'GET' IS_POST request.IS_GET tests if the request method is POST class Index ( Mocha ) : def index ( self ) : if request . IS_POST : # do something It is equivalent to request.method == 'POST' Same as above for PUT and DELETE IS_PUT IS_DELETE Args & Forms This is already part of Flask. It is added as a reference args request.args.get lets you get the query vars # http://127.0.0.1/?name=Mocha class Index ( Mocha ): def index ( self ): name = request . args . get ( \"name\" ) form request.form.get lets you get the data that was sent in a post form class Index ( Mocha ): def index ( self ): name = request . form . get ( \"name\" ) getlist request.form.getlist returns a list of all the items with the same name that was posted in a form < input type = 'checkbox' name = 'options' value = 'apple' > < input type = 'checkbox' name = 'options' value = 'orange' > < input type = 'checkbox' name = 'options' value = 'grapes' > Python class Index ( Mocha ): def index ( self ): my_options = request . form . getlist ( \"options\" ) files.get request.files.get allow you to retrieve a file that was uploaded HTML < input type = file name = \"file\" > Python class Index ( Mocha ): def index ( self ): file = request . files . get ( \"file\" ) files.getlist request.files.getlist allow you to retrieve multiple files uploaded with the same name HTML < input type = file name = \"file\" > < input type = file name = \"file\" > < input type = file name = \"file\" > Python class Index ( Mocha ): def index ( self ): files = request . files . getlist ( \"file\" ) Save uploaded file Here's a snippet on how to upload a file. from mocha import request , upload_file class Index ( Mocha ): @request.post def upload_file ( self ): image_file = request . files . get ( \"file\" ) upload_file ( \"image\" , file )","title":"Request"},{"location":"application/request/#import","text":"from mocha import request","title":"Import"},{"location":"application/request/#methods","text":"","title":"Methods"},{"location":"application/request/#get","text":"@request.get set a view to accept only GET method class Index ( Mocha ) : @ request . get def index ( self ) : # do something","title":"get"},{"location":"application/request/#post","text":"@request.post set a view to accept only POST method class Index ( Mocha ) : @ request . post def index ( self ) : # do something","title":"post"},{"location":"application/request/#put","text":"@request.put set a view to accept only PUT method class Index ( Mocha ) : @ request . put def index ( self ) : # do something","title":"put"},{"location":"application/request/#delete","text":"@request.delete set a view to accept only DELETE method class Index ( Mocha ) : @ request . delete def index ( self ) : # do something","title":"delete"},{"location":"application/request/#all","text":"@request.all set a view to accept only ALL methods. It will accept: GET, POST, PUT, DELETE, OPTIONS class Index ( Mocha ) : @ request . all def index ( self ) : # do something","title":"all"},{"location":"application/request/#combine","text":"An alternative to @all is to use all methods as class Index ( Mocha ) : @ request . get @ request . post @ request . put @ request . delete @ request . options def index ( self ) : # do something","title":"Combine"},{"location":"application/request/#test-method","text":"Usually if a view method accept more than one request method, it is best to test for the method","title":"Test Method"},{"location":"application/request/#is_get","text":"request.IS_GET tests if the request method is GET class Index ( Mocha ) : def index ( self ) : if request . IS_GET : # do something It is equivalent to request.method == 'GET'","title":"IS_GET"},{"location":"application/request/#is_post","text":"request.IS_GET tests if the request method is POST class Index ( Mocha ) : def index ( self ) : if request . IS_POST : # do something It is equivalent to request.method == 'POST' Same as above for PUT and DELETE","title":"IS_POST"},{"location":"application/request/#is_put","text":"","title":"IS_PUT"},{"location":"application/request/#is_delete","text":"","title":"IS_DELETE"},{"location":"application/request/#args-forms","text":"This is already part of Flask. It is added as a reference","title":"Args &amp; Forms"},{"location":"application/request/#args","text":"request.args.get lets you get the query vars # http://127.0.0.1/?name=Mocha class Index ( Mocha ): def index ( self ): name = request . args . get ( \"name\" )","title":"args"},{"location":"application/request/#form","text":"request.form.get lets you get the data that was sent in a post form class Index ( Mocha ): def index ( self ): name = request . form . get ( \"name\" )","title":"form"},{"location":"application/request/#getlist","text":"request.form.getlist returns a list of all the items with the same name that was posted in a form < input type = 'checkbox' name = 'options' value = 'apple' > < input type = 'checkbox' name = 'options' value = 'orange' > < input type = 'checkbox' name = 'options' value = 'grapes' > Python class Index ( Mocha ): def index ( self ): my_options = request . form . getlist ( \"options\" )","title":"getlist"},{"location":"application/request/#filesget","text":"request.files.get allow you to retrieve a file that was uploaded HTML < input type = file name = \"file\" > Python class Index ( Mocha ): def index ( self ): file = request . files . get ( \"file\" )","title":"files.get"},{"location":"application/request/#filesgetlist","text":"request.files.getlist allow you to retrieve multiple files uploaded with the same name HTML < input type = file name = \"file\" > < input type = file name = \"file\" > < input type = file name = \"file\" > Python class Index ( Mocha ): def index ( self ): files = request . files . getlist ( \"file\" )","title":"files.getlist"},{"location":"application/request/#save-uploaded-file","text":"Here's a snippet on how to upload a file. from mocha import request , upload_file class Index ( Mocha ): @request.post def upload_file ( self ): image_file = request . files . get ( \"file\" ) upload_file ( \"image\" , file )","title":"Save uploaded file"},{"location":"application/static/","text":"Path: $$APP_NAME/static/ CONVENTION By convention, Assembly expects you to have one static directory per application. And the file must be named $$APP_NAME/static/ , for it to be loaded automatically.","title":"Static"},{"location":"application/static/#convention","text":"By convention, Assembly expects you to have one static directory per application. And the file must be named $$APP_NAME/static/ , for it to be loaded automatically.","title":"CONVENTION"},{"location":"application/templates/","text":"Path: $$APP_NAME/templates/ CONVENTION By convention, Assembly expects you to have one templates directory per application. And the file must be named $$APP_NAME/templates/ , for it to be loaded automatically.","title":"Templates"},{"location":"application/templates/#convention","text":"By convention, Assembly expects you to have one templates directory per application. And the file must be named $$APP_NAME/templates/ , for it to be loaded automatically.","title":"CONVENTION"},{"location":"application/views/","text":"Path: $$APP_NAME/__views__.py CONVENTION By convention, Assembly expects you to have one view file per application. And the file must be named views .py , for it to be loaded automatically. Examples from assembly import Assembly class Index ( Assembly ): def index ( self ): return","title":"Views"},{"location":"application/views/#convention","text":"By convention, Assembly expects you to have one view file per application. And the file must be named views .py , for it to be loaded automatically. Examples from assembly import Assembly class Index ( Assembly ): def index ( self ): return","title":"CONVENTION"}]}