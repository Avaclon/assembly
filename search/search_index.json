{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"local_florist Assembly local_florist A Pythonic Object-Oriented Web Framework built on Flask About Assembly is a pythonic object-oriented, mid stack, batteries included framework built on Flask, that adds structure to your Flask application, and group your routes by class. Assembly allows you to build web applications in much the same way you would build any other object-oriented Python program. Assembly helps you create small to enterprise level applications easily. Assembly Makes Flask Great Again! Installation Guide Why Assembly ? Flask is very easy and simple. It's fun to put a few endpoints in a single file. However when your application starts growing into an endless of endpoints, tons of models and views, or your team is having more people, it is very necessary to have some sort of structure in your application. And that's what Assembly does. Assembly adds structure to Flask application. Assembly removes a lot of Flask boilerplate. Assembly makes your Flask application scalable and easy to work with. Instead of having loose endpoints per functions, Assembly organizes all groups of endpoints per class. Instead of each time rendering the template for each endpoint manually, Assembly matches the name of the method of the class, to the name of the template file, making it a one-one match. Assembly automatically loads your models and configuration. Assembly is very extensible, as every View is it's own package. Making it easy to add and remove. Assembly Makes Flask Great Again! Quick Start This quickstart will allow us to go with Assembly from 0 to 100! 1. Install Assembly Install Assembly with pip install assembly It is highly recommended to use a virtualenv, in this case let's use VirtualenvWrapper (you can use any that is convenient for you) mkvirtualenv my - first - app workon my - first - app pip install assembly 2. Initialize your application Initialize Assembly with asm-admin init CD into the folder you intend to create the application, then run asm-admin init . This will setup the structure along with the necessary files to get started cd app - dir asm - admin init Upon initialization you should have a structure similar to this: -- / |- wsgi . py |- config . py |- requirements . txt |- main |- __init__ . py |- __models__ . py |- templates |- Index |- index . html |- layouts |- base . html |- static |- cli . py |- _data / 3. Edit your first view # main/__init__.py from assembly import ( Assembly , response ) class Index ( Assembly ): def index ( self ): return { \"title\" : \"Assembly is awesome\" , \"content\" : \"That is a true fact\" } @response.json def api ( self ): return { \"name\" : \"Assembly\" , \"version\" : \"x-to-infinity\" } 4. Edit your template 4.0 Edit base layout <!-- main/templates/layouts/base.html --> <!doctype html> <html lang= \"en\" > <head> <title> {% block title %}{% endblock %} </title> </head> <body> <div class= \"container\" > {% block body %}{% endblock %} </div> </body> </html> 4.1 Edit Index/index.html <!-- main/templates/Index/index.html --> {% extends 'main/layouts/base.html' %} {% block title %} Welcome to my Assembly Site {% endblock %} {% block body %} <div> <h1> {{ title }} </h1> </div> <div> {{ content }} </div> {% endblock %} 5. Serve your first application If everything is all set, all you need to do now is run your site: asm - admin serve It will start serving your application by default at 127.0.0.1:5000 Two endpoints will be available: http://127.0.0.1:5000/ which will show an HTML http://127.0.0.1:5000/api/ which will a json response Features List Smart routing: automatically generates routes based on the classes and methods in your views Class name as the base url, ie: class UserAccount will be accessed at '/user-account' Class methods (action) could be accessed: hello_world(self) becomes 'hello-world' RESTful API Automatic view rendering Auto route can be edited with @route() Markdown friendly. Inclusion of a markdown file will turn into HTML BCRYPT is chosen as the password hasher Session: Redis, AWS S3, Google Storage, SQLite, MySQL, PostgreSQL Database/ORM: Active-Alchemy (SQLALchemy wrapper) CSRF on all POST Idiomatic HTTP error responses Storage: Local, S3, Google Storage Flask-Cloudy Mailer (SES or SMTP) Arrow for date and time Caching JWT Pagination Signals: to dispatch messages and data to other part of the application Markdown Jinja2 for templating language Multi application Web Assets CLI Inbuilt development server Image Credit - License: Non-commercial Use : https://imgbin.com/png/q2HLy9Kx/flower-watercolor-painting-png","title":"Overview"},{"location":"#about","text":"Assembly is a pythonic object-oriented, mid stack, batteries included framework built on Flask, that adds structure to your Flask application, and group your routes by class. Assembly allows you to build web applications in much the same way you would build any other object-oriented Python program. Assembly helps you create small to enterprise level applications easily. Assembly Makes Flask Great Again! Installation Guide","title":"About"},{"location":"#why-assembly","text":"Flask is very easy and simple. It's fun to put a few endpoints in a single file. However when your application starts growing into an endless of endpoints, tons of models and views, or your team is having more people, it is very necessary to have some sort of structure in your application. And that's what Assembly does. Assembly adds structure to Flask application. Assembly removes a lot of Flask boilerplate. Assembly makes your Flask application scalable and easy to work with. Instead of having loose endpoints per functions, Assembly organizes all groups of endpoints per class. Instead of each time rendering the template for each endpoint manually, Assembly matches the name of the method of the class, to the name of the template file, making it a one-one match. Assembly automatically loads your models and configuration. Assembly is very extensible, as every View is it's own package. Making it easy to add and remove. Assembly Makes Flask Great Again!","title":"Why Assembly ?"},{"location":"#quick-start","text":"This quickstart will allow us to go with Assembly from 0 to 100!","title":"Quick Start"},{"location":"#1-install-assembly","text":"Install Assembly with pip install assembly It is highly recommended to use a virtualenv, in this case let's use VirtualenvWrapper (you can use any that is convenient for you) mkvirtualenv my - first - app workon my - first - app pip install assembly","title":"1. Install Assembly"},{"location":"#2-initialize-your-application","text":"Initialize Assembly with asm-admin init CD into the folder you intend to create the application, then run asm-admin init . This will setup the structure along with the necessary files to get started cd app - dir asm - admin init Upon initialization you should have a structure similar to this: -- / |- wsgi . py |- config . py |- requirements . txt |- main |- __init__ . py |- __models__ . py |- templates |- Index |- index . html |- layouts |- base . html |- static |- cli . py |- _data /","title":"2. Initialize your application"},{"location":"#3-edit-your-first-view","text":"# main/__init__.py from assembly import ( Assembly , response ) class Index ( Assembly ): def index ( self ): return { \"title\" : \"Assembly is awesome\" , \"content\" : \"That is a true fact\" } @response.json def api ( self ): return { \"name\" : \"Assembly\" , \"version\" : \"x-to-infinity\" }","title":"3. Edit your first view"},{"location":"#4-edit-your-template","text":"","title":"4. Edit your template"},{"location":"#40-edit-base-layout","text":"<!-- main/templates/layouts/base.html --> <!doctype html> <html lang= \"en\" > <head> <title> {% block title %}{% endblock %} </title> </head> <body> <div class= \"container\" > {% block body %}{% endblock %} </div> </body> </html>","title":"4.0 Edit base layout"},{"location":"#41-edit-indexindexhtml","text":"<!-- main/templates/Index/index.html --> {% extends 'main/layouts/base.html' %} {% block title %} Welcome to my Assembly Site {% endblock %} {% block body %} <div> <h1> {{ title }} </h1> </div> <div> {{ content }} </div> {% endblock %}","title":"4.1  Edit Index/index.html"},{"location":"#5-serve-your-first-application","text":"If everything is all set, all you need to do now is run your site: asm - admin serve It will start serving your application by default at 127.0.0.1:5000 Two endpoints will be available: http://127.0.0.1:5000/ which will show an HTML http://127.0.0.1:5000/api/ which will a json response","title":"5. Serve your first application"},{"location":"#features-list","text":"Smart routing: automatically generates routes based on the classes and methods in your views Class name as the base url, ie: class UserAccount will be accessed at '/user-account' Class methods (action) could be accessed: hello_world(self) becomes 'hello-world' RESTful API Automatic view rendering Auto route can be edited with @route() Markdown friendly. Inclusion of a markdown file will turn into HTML BCRYPT is chosen as the password hasher Session: Redis, AWS S3, Google Storage, SQLite, MySQL, PostgreSQL Database/ORM: Active-Alchemy (SQLALchemy wrapper) CSRF on all POST Idiomatic HTTP error responses Storage: Local, S3, Google Storage Flask-Cloudy Mailer (SES or SMTP) Arrow for date and time Caching JWT Pagination Signals: to dispatch messages and data to other part of the application Markdown Jinja2 for templating language Multi application Web Assets CLI Inbuilt development server Image Credit - License: Non-commercial Use : https://imgbin.com/png/q2HLy9Kx/flower-watercolor-painting-png","title":"Features List"},{"location":"architecture/","text":"Overview Assembly tries to keep it simple by providing a flat structure for your application and gives you the freedom to do whatever else. It lays out a basic layout, so the application can be consistent. Structure A basic application structure looks like this -- / |- wsgi . py |- config . py |- requirements . txt |- app . json |- _data |- main |- __init__ . py |- __models__ . py |- templates |- Index |- index . html |- layouts |- base . html |- static |- cli . py Base files Base files are at the root of the application. And wsgi.py , config.py are required by Assembly. -- / |- wsgi . py |- config . py |- requirements . txt |- app . json |- _data wsgi.py is the application object. (required) config.py : contains class based configurations (required) requirements.txt : contains application dependencies including assembly app.json : Application manifest to deploy using Gokku _data : A variable directory, to put misc files, uploads, etc. View Package Structure View Package are simply a package/directory that contains at least __init__.py and can be imported into the APPS list in the wsgi.py file. Additionally, you can find __models__.py , templates/ , static/ The view name is the folder. The example below show the main view. |- main |- __init__ . py |- __models__ . py |- templates |- Index |- index . html |- layouts |- base . html |- static |- cli . py main view directory __init__.py contains all the View classes __models__.py contains all the Models for that View templates contains templates for the each endpoint in the View classes static contain the static files, images, css, js, etc. cli.py Custom CLI for that view. __init__.py , __models__.py , templates/ , static/ will be loaded implicitely by Assemby. Only __init__.py is required. __init__.py is also served as files containing all the view classes. View Class structure You can place your view classes in __init__.py . Assembly will automatically load them when they are added in the APPS list. Aside from importing the assembly package, nothing special needs to be done in the View. Just work on your application like you would in your normal Python file. As a matter of fact this is a normal Python file. # main/__init__ from assembly import Assembly class Index ( Assembly ): def index ( self ): return Multiple Classes It's ok to have multiple classes in a single view file, __init__.py . They will be treated properly with the proper endpoint. # main/__init__ from assembly import Assembly , request # responds to / class Index ( Assembly ): index ( self ): return # responds to /api/ class Api ( Assembly ): index ( self ): return # responds to /admin/ class Admin ( Assembly ): index ( self ): return Namespace Everything is properly namespaced, however the only time you may have some clashes is when more than one class has the same class name. To fix that, just use a different route endpoint for the class. # main/__init__ from assembly import Assembly # responds to / class Index ( Assembly ): index ( self ): return --- # admin/__init__ from assembly import Assembly , request # responds to /admin/ @request.route ( \"/admin/\" ) class Index ( Assembly ): index ( self ): return View Templates Assembly uses Jinja as templating language. Templates are mapped by their class and method name in the view. Having a View like this... # admin/__init__.py from assembly import Assembly class Index ( Assembly ): def index ( self ): return def login ( self ): return class Articles ( Assembly ): def index ( self ): return def all ( self ): return class Movies ( Assembly ): def index ( self ): return def guide ( self ): return def channels ( self ): return will map to templates below |- admin |- __init__ . py |- __models__ . py |- templates |- Index |- index . html |- login . html |- Articles |- index . html |- all . html |- Movies |- index . html |- guide . html |- channels . html |- static |- cli . py View Static Assembly uses Flask-Assets to help manage static assets, ie: images, js, css in your application","title":"Architecture"},{"location":"architecture/#overview","text":"Assembly tries to keep it simple by providing a flat structure for your application and gives you the freedom to do whatever else. It lays out a basic layout, so the application can be consistent.","title":"Overview"},{"location":"architecture/#structure","text":"A basic application structure looks like this -- / |- wsgi . py |- config . py |- requirements . txt |- app . json |- _data |- main |- __init__ . py |- __models__ . py |- templates |- Index |- index . html |- layouts |- base . html |- static |- cli . py","title":"Structure"},{"location":"architecture/#base-files","text":"Base files are at the root of the application. And wsgi.py , config.py are required by Assembly. -- / |- wsgi . py |- config . py |- requirements . txt |- app . json |- _data wsgi.py is the application object. (required) config.py : contains class based configurations (required) requirements.txt : contains application dependencies including assembly app.json : Application manifest to deploy using Gokku _data : A variable directory, to put misc files, uploads, etc.","title":"Base files"},{"location":"architecture/#view-package-structure","text":"View Package are simply a package/directory that contains at least __init__.py and can be imported into the APPS list in the wsgi.py file. Additionally, you can find __models__.py , templates/ , static/ The view name is the folder. The example below show the main view. |- main |- __init__ . py |- __models__ . py |- templates |- Index |- index . html |- layouts |- base . html |- static |- cli . py main view directory __init__.py contains all the View classes __models__.py contains all the Models for that View templates contains templates for the each endpoint in the View classes static contain the static files, images, css, js, etc. cli.py Custom CLI for that view. __init__.py , __models__.py , templates/ , static/ will be loaded implicitely by Assemby. Only __init__.py is required. __init__.py is also served as files containing all the view classes.","title":"View Package Structure"},{"location":"architecture/#view-class-structure","text":"You can place your view classes in __init__.py . Assembly will automatically load them when they are added in the APPS list. Aside from importing the assembly package, nothing special needs to be done in the View. Just work on your application like you would in your normal Python file. As a matter of fact this is a normal Python file. # main/__init__ from assembly import Assembly class Index ( Assembly ): def index ( self ): return","title":"View Class structure"},{"location":"architecture/#multiple-classes","text":"It's ok to have multiple classes in a single view file, __init__.py . They will be treated properly with the proper endpoint. # main/__init__ from assembly import Assembly , request # responds to / class Index ( Assembly ): index ( self ): return # responds to /api/ class Api ( Assembly ): index ( self ): return # responds to /admin/ class Admin ( Assembly ): index ( self ): return","title":"Multiple Classes"},{"location":"architecture/#namespace","text":"Everything is properly namespaced, however the only time you may have some clashes is when more than one class has the same class name. To fix that, just use a different route endpoint for the class. # main/__init__ from assembly import Assembly # responds to / class Index ( Assembly ): index ( self ): return --- # admin/__init__ from assembly import Assembly , request # responds to /admin/ @request.route ( \"/admin/\" ) class Index ( Assembly ): index ( self ): return","title":"Namespace"},{"location":"architecture/#view-templates","text":"Assembly uses Jinja as templating language. Templates are mapped by their class and method name in the view. Having a View like this... # admin/__init__.py from assembly import Assembly class Index ( Assembly ): def index ( self ): return def login ( self ): return class Articles ( Assembly ): def index ( self ): return def all ( self ): return class Movies ( Assembly ): def index ( self ): return def guide ( self ): return def channels ( self ): return will map to templates below |- admin |- __init__ . py |- __models__ . py |- templates |- Index |- index . html |- login . html |- Articles |- index . html |- all . html |- Movies |- index . html |- guide . html |- channels . html |- static |- cli . py","title":"View Templates"},{"location":"architecture/#view-static","text":"Assembly uses Flask-Assets to help manage static assets, ie: images, js, css in your application","title":"View Static"},{"location":"cli/","text":"Overview Assembly provides a CLI tool and framework based on Click library Extension: Click Usage Upon installing Assembly via pip install assembly , two commands will be available for the command line: asm : for custom command list asm-admin : for Assembly specific commands Admin CLI: asm-admin This command allows you to access Assembly specific commands init To initialize Assembly for the first time in the current directory cd my - dir asm - admin init serve To run the development server. asm - admin serve or changing environment export ASSEMBLY_ENV = Staging asm - admin serve or changing environment and app export ASSEMBLY_ENV = Testing export ASSEMBLY_APP = api asm - admin serve sync-models To sync database models to create new tables. Models that extended db.Model will be created. asm - admin sync - models gen-api-view To create a view that can be used as API endpoint asm - admin gen - api - view $ view - name ie: asm - admin gen - api - view api It will create a new view at the root. gen-template-view To create a view that contains template asm - admin gen - template - view $ view - name ie: asm - admin gen - api - view admin It will create a new view admin at the root. upload-assets-s3 If you are serving your assets via CDN or S3, you need to upload them before deploying the application. When config.ASSETS_DELIVERY_METHOD is S3 , this util will allow you to upload your assets to S3, and the application will automatically point all your assets to S3. asm - admin upload - assets - s3 version Return the version of Assembly asm - admin version Custom CLI: asm Assembly also allows you to create your own CLI scripts, to use with your application. You probably need CLI to run some routines and setup outside of the web environment, ie: setup database, run worker/task, cronjob, scheduler, etc... 1. Create CLI Functions Assembly CLI is based on Click library. Inside of your view, create cli.py (named so for discoverability). NOTE: @command is the alias to the custom command. Use it, otherwise your CLI scripts won't be available. Learn more about Click # main/cli.py from assembly.cli import ( command , option , argument , click ) @command def hello (): print ( \"Hello world!\" ) @command ( 'do-something' ) @argument ( name ) def do_something ( name ): print ( \"Hello %s \" % name ) 2. Import in wsgi.py # wsgi.py from assembly import Assembly #->>> Import your CLI in the wsgi.py import admin.cli APPS = { \"default\" : [ \"main\" ] } app = Assembly . init ( __name__ , APPS ) 3. Execute Commands Commands can easily be executed by invoking asm followed by the name of the function that had @command Example: # main/cli.py from assembly.cli import ( command , option , argument , click ) @command def hello (): print ( \"Hello world!\" ) >> asm hello @command ( 'do-something' ) @argument ( name ) def do_something ( name ): print ( \"Hello %s \" % name ) >> asm do - something Assembly it will print out : `Hello Assembly`","title":"CLI"},{"location":"cli/#overview","text":"Assembly provides a CLI tool and framework based on Click library Extension: Click","title":"Overview"},{"location":"cli/#usage","text":"Upon installing Assembly via pip install assembly , two commands will be available for the command line: asm : for custom command list asm-admin : for Assembly specific commands","title":"Usage"},{"location":"cli/#admin-cli-asm-admin","text":"This command allows you to access Assembly specific commands","title":"Admin CLI: asm-admin"},{"location":"cli/#init","text":"To initialize Assembly for the first time in the current directory cd my - dir asm - admin init","title":"init"},{"location":"cli/#serve","text":"To run the development server. asm - admin serve or changing environment export ASSEMBLY_ENV = Staging asm - admin serve or changing environment and app export ASSEMBLY_ENV = Testing export ASSEMBLY_APP = api asm - admin serve","title":"serve"},{"location":"cli/#sync-models","text":"To sync database models to create new tables. Models that extended db.Model will be created. asm - admin sync - models","title":"sync-models"},{"location":"cli/#gen-api-view","text":"To create a view that can be used as API endpoint asm - admin gen - api - view $ view - name ie: asm - admin gen - api - view api It will create a new view at the root.","title":"gen-api-view"},{"location":"cli/#gen-template-view","text":"To create a view that contains template asm - admin gen - template - view $ view - name ie: asm - admin gen - api - view admin It will create a new view admin at the root.","title":"gen-template-view"},{"location":"cli/#upload-assets-s3","text":"If you are serving your assets via CDN or S3, you need to upload them before deploying the application. When config.ASSETS_DELIVERY_METHOD is S3 , this util will allow you to upload your assets to S3, and the application will automatically point all your assets to S3. asm - admin upload - assets - s3","title":"upload-assets-s3"},{"location":"cli/#version","text":"Return the version of Assembly asm - admin version","title":"version"},{"location":"cli/#custom-cli-asm","text":"Assembly also allows you to create your own CLI scripts, to use with your application. You probably need CLI to run some routines and setup outside of the web environment, ie: setup database, run worker/task, cronjob, scheduler, etc...","title":"Custom CLI: asm"},{"location":"cli/#1-create-cli-functions","text":"Assembly CLI is based on Click library. Inside of your view, create cli.py (named so for discoverability). NOTE: @command is the alias to the custom command. Use it, otherwise your CLI scripts won't be available. Learn more about Click # main/cli.py from assembly.cli import ( command , option , argument , click ) @command def hello (): print ( \"Hello world!\" ) @command ( 'do-something' ) @argument ( name ) def do_something ( name ): print ( \"Hello %s \" % name )","title":"1. Create CLI Functions"},{"location":"cli/#2-import-in-wsgipy","text":"# wsgi.py from assembly import Assembly #->>> Import your CLI in the wsgi.py import admin.cli APPS = { \"default\" : [ \"main\" ] } app = Assembly . init ( __name__ , APPS )","title":"2. Import in wsgi.py"},{"location":"cli/#3-execute-commands","text":"Commands can easily be executed by invoking asm followed by the name of the function that had @command Example: # main/cli.py from assembly.cli import ( command , option , argument , click ) @command def hello (): print ( \"Hello world!\" ) >> asm hello @command ( 'do-something' ) @argument ( name ) def do_something ( name ): print ( \"Hello %s \" % name ) >> asm do - something Assembly it will print out : `Hello Assembly`","title":"3. Execute Commands"},{"location":"config/","text":"Overview ./config.py contains class-based configurations. This file must exist at the root of the application where wsgi.py exists. It is recommended to have a base class, BaseConfig , and your environment classes Development , Production which are subclasses of the BaseConfig , this way they can share some common config. The environment classes will be loaded on Assembly startup. By default, and in development, Assembly will attempt to load the Development if one isn't provided. To switch to a different config, you have to set the environment variable, or in production export ASSEMBLY_ENV = Production export ASSEMBLY_APP = default or to set the application along with the environment ASSEMBLY_ENV = Production ASSEMBLY_APP = default asm - admin serve The code above will load the Production config. One main advantage of having your config like that, is that you have the ability of using different config for different environment, could be for testing, prod, dev, etc. Config Accessor Assembly exposes config to access variable from your config environment. config is a subset of dict, and also has dot notation accessor, where can access variable using the dot notation, ie: config.get('key.val1.val2.val3') Import from assembly import config Usage from assembly import ( Assembly , config ) class Index ( Assembly ): def index ( self ): return { \"version\" : config . get ( \"APPLICATION_VERSION\" ), \"version2\" : config [ \"APPLICATION_VERSION\" ], } As DotNotation from assembly import ( Assembly , config ) class Index ( Assembly ): def index ( self ): return { \"default_date_format\" : config . get ( \"DATE_FORMAT.default\" ) } Class Based Configuration Each class corresponds to an environment that you will be able to use for either 'Development', 'Production', 'Testing', 'Staging' etc. class BaseConf ( object ): \"\"\" That will be default class base, which other classes will extends from \"\"\" APPLICATION_NAME = \"Assembly\" class Development ( BaseConf ): DEBUG = True class Production ( BaseConf ): DEBUG = False class Testing ( BaseConf ): DEBUG = True Select Environment When you are ready to serve your application, set the environment variable ASSEMBLY_ENV to the class name you want to use. Example: export ASSEMBLY_ENV=Production -> for Production export ASSEMBLY_ENV=Staging -> for Staging By default Assembly will load the Development class during development. Default Configurations Assembly uses class-based configuration, and the config will be loaded implicitely. ./config.py is required at the root of the application. # config.py import os # The root dir ROOT_DIR = os . path . dirname ( __file__ ) # Data directory DATA_DIR = os . path . join ( ROOT_DIR , \"_data\" ) class BaseConfig ( object ): \"\"\" Base configuration \"\"\" #: Site's name or Name of the application APPLICATION_NAME = \"Assembly\" #: The application url APPLICATION_URL = \"\" #: Version of application APPLICATION_VERSION = \"0.0.1\" #: Google Analytics ID GOOGLE_ANALYTICS_ID = \"\" #: Required to setup. This email will have SUPER USER role ADMIN_EMAIL = None #: The address to receive email when using the contact page CONTACT_EMAIL = None #: PAGINATION_PER_PAGE : Total entries to display per page PAGINATION_PER_PAGE = 20 # MAX_CONTENT_LENGTH # If set to a value in bytes, Flask will reject incoming requests with a # content length greater than this by returning a 413 status code MAX_CONTENT_LENGTH = 2 * 1024 * 1024 # To remove whitespace off the HTML result COMPRESS_HTML = False # Data directory DATA_DIR = DATA_DIR #------------------- DATE FORMAT and TIMEZONE ------------- # Arrow is used as date parser # from assembly import date # http://crsmithdev.com/arrow # To view tokens: http://crsmithdev.com/arrow/#tokens # Timezone to use when dealing with date. # Example # date.now().to(config.get(\"TIMEZONE\")) # Timezone TIMEZONE = \"US/Eastern\" # Date format # Dict of dates format # Example # date.now().format(config.get(\"DATE_FORMAT.default\")) DATE_FORMAT = { \"default\" : \"MM/DD/YYYY\" , \"date\" : \"MM/DD/YYYY\" , \"datetime\" : \"MM/DD/YYYY hh:mm a\" , \"time\" : \"hh:mm a\" , \"long_datetime\" : \"dddd, MMMM D, YYYY hh:mm a\" , } #--------- AWS Credentials ---------- #: AWS Credentials # AWS is used by lots of extensions # For: S3, SES Mailer, flask S3. # The AWS Access KEY AWS_ACCESS_KEY_ID = \"\" # Secret Key AWS_SECRET_ACCESS_KEY = \"\" # The bucket name for S3 AWS_S3_BUCKET_NAME = \"\" # The default region name AWS_REGION_NAME = \"us-east-1\" #--------- DATABASES URL ---------- #: DB_URL #: Assembly uses Active-Alchemy to work with DB #: format: engine://USERNAME:PASSWORD@HOST:PORT/DB_NAME DB_URL = \"sqlite://// %s /db.db\" % DATA_DIR #: DB_REDIS_URL #: format: USERNAME:PASSWORD@HOST:PORT DB_REDIS_URL = None #--------- ASSETS DELIVERY ---------- # ASSETS DELIVERY allows to serve static files from S3, Cloudfront or other CDN # The delivery method: # - None: will use the local static files # - S3: Will use AWS S3. By default it will use the bucket name set in AWS_S3_BUCKET_NAME # When S3, AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY are required to upload files # - CDN: To use a CDN. ASSETS_DELIVERY_DOMAIN need to have the CDN domain ASSETS_DELIVERY_METHOD = None # Set the base domain of the CDN ASSETS_DELIVERY_DOMAIN = None #--------- SESSION ---------- #: SESSION #: Flask-KVSession is used to save the user's session #: Set the SESSION_URL by using these examples below to set KVSession #: To use local session, just set SESSION_URL to None #: #: Redis: redis://username:password@host:6379/db #: S3: s3://username:password@s3.aws.amazon.com/bucket #: Google Storage: google_storage://username:password@cloud.google.com/bucket #: SQL: postgresql://username:password@host:3306/db #: mysql+pysql://username:password@host:3306/db #: sqlite:// #: Memcached: memcache://host:port #: SESSION_URL = None #--------- STORAGE ---------- #: STORAGE #: Flask-Cloudy is used to save upload on S3, Google Storage, #: Cloudfiles, Azure Blobs, and Local storage #: When using local storage, they can be accessed via http://yoursite/files #: #: STORAGE_PROVIDER: # The provider to use. By default it's 'LOCAL'. # You can use: # LOCAL, S3, GOOGLE_STORAGE, AZURE_BLOBS, CLOUDFILES STORAGE_PROVIDER = \"LOCAL\" #: STORAGE_KEY # The storage key. Leave it blank if PROVIDER is LOCAL STORAGE_KEY = AWS_ACCESS_KEY_ID #: STORAGE_SECRET #: The storage secret key. Leave it blank if PROVIDER is LOCAL STORAGE_SECRET = AWS_SECRET_ACCESS_KEY #: STORAGE_REGION_NAME #: The region for the storage. Leave it blank if PROVIDER is LOCAL STORAGE_REGION_NAME = AWS_REGION_NAME #: STORAGE_CONTAINER #: The Bucket name (for S3, Google storage, Azure, cloudfile) #: or the directory name (LOCAL) to access STORAGE_CONTAINER = os . path . join ( DATA_DIR , \"uploads\" ) #: STORAGE_SERVER #: Bool, to serve local file STORAGE_SERVER = True #: STORAGE_SERVER_URL #: The url suffix for local storage STORAGE_SERVER_URL = \"files\" #:STORAGE_UPLOAD_FILE_PROPS #: A convenient K/V properties for storage.upload to use when using `upload_file()` #: It contains common properties that can passed into the upload function #: ie: upload_file(\"profile-image\", file) STORAGE_UPLOAD_FILE_PROPS = { # To upload regular images \"image\" : { \"extensions\" : [ \"jpg\" , \"png\" , \"gif\" , \"jpeg\" ], \"public\" : True }, # To upload profile image \"profile-image\" : { \"prefix\" : \"profile-image/\" , \"extensions\" : [ \"jpg\" , \"png\" , \"gif\" , \"jpeg\" ], \"public\" : True } } #--------- MAIL ---------- # To send emails # AWS SES # To use AWS SES to send email #: #: - To use the default AWS credentials (AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY) #: set MAIL_URL = \"ses://\" #: * To use a different credential: #: set MAIL_URL = \"ses://{access_key}:{secret_key}@{region}\" #: #: *** uncomment if you are using SMTP instead # MAIL_URL = \"ses://\" # SMTP #: If you are using SMTP, it will use Flask-Mail #: The uri for the smtp connection. It will use Flask-Mail #: format: smtp://USERNAME:PASSWORD@HOST:PORT #: with sll -> smtp+ssl://USERNAME:PASSWORD@HOST:PORT #: with ssl and tls -> smtp+ssl+tls://USERNAME:PASSWORD@HOST:PORT #: #: *** comment out if you are using SES instead # MAIL_URL = \"smtp+ssl://{username}:{password}@{host}:{port}\"\\ # .format(username=\"\", password=\"\", host=\"smtp.gmail.com\", port=465) #: MAIL_SENDER - The sender of the email by default #: For SES, this email must be authorized MAIL_SENDER = ADMIN_EMAIL #: MAIL_REPLY_TO #: The email to reply to by default MAIL_REPLY_TO = ADMIN_EMAIL #: MAIL_TEMPLATE #: a directory that contains the email template or a dict MAIL_TEMPLATE = os . path . join ( DATA_DIR , 'mail-templates' ) #: MAIL_TEMPLATE_CONTEXT #: a dict of all context to pass to the email by default MAIL_TEMPLATE_CONTEXT = { \"params\" : { \"site_name\" : APPLICATION_NAME , \"site_url\" : APPLICATION_URL } } #--------- CACHING ---------- #: Flask-Cache is used to caching #: CACHE_TYPE #: The type of cache to use #: null, simple, redis, filesystem, CACHE_TYPE = \"simple\" #: CACHE_REDIS_URL #: If CHACHE_TYPE is 'redis', set the redis uri #: redis://username:password@host:port/db CACHE_REDIS_URL = \"\" #: CACHE_DIR #: Directory to store cache if CACHE_TYPE is filesystem, it will CACHE_DIR = \"\" # -------------------------- ENVIRONMENT BASED CONFIG --------------------------- \"\"\" The environment based config is what will be loaded. By default it will load the development ## 1. Set environment variables export ASSEMBLY_ENV=Development # for development export ASSEMBLY_APP=default ## 2. Run the wsgi wsgi:app ### **for local server asm-admin server \"\"\" class Development ( BaseConfig ): \"\"\" Config for development environment \"\"\" SERVER_NAME = None DEBUG = True SECRET_KEY = \"PLEASE CHANGE ME\" class Production ( BaseConfig ): \"\"\" Config for Production environment \"\"\" SERVER_NAME = None DEBUG = False SECRET_KEY = None COMPRESS_HTML = True","title":"Configuration"},{"location":"config/#overview","text":"./config.py contains class-based configurations. This file must exist at the root of the application where wsgi.py exists. It is recommended to have a base class, BaseConfig , and your environment classes Development , Production which are subclasses of the BaseConfig , this way they can share some common config. The environment classes will be loaded on Assembly startup. By default, and in development, Assembly will attempt to load the Development if one isn't provided. To switch to a different config, you have to set the environment variable, or in production export ASSEMBLY_ENV = Production export ASSEMBLY_APP = default or to set the application along with the environment ASSEMBLY_ENV = Production ASSEMBLY_APP = default asm - admin serve The code above will load the Production config. One main advantage of having your config like that, is that you have the ability of using different config for different environment, could be for testing, prod, dev, etc.","title":"Overview"},{"location":"config/#config-accessor","text":"Assembly exposes config to access variable from your config environment. config is a subset of dict, and also has dot notation accessor, where can access variable using the dot notation, ie: config.get('key.val1.val2.val3')","title":"Config Accessor"},{"location":"config/#import","text":"from assembly import config","title":"Import"},{"location":"config/#usage","text":"from assembly import ( Assembly , config ) class Index ( Assembly ): def index ( self ): return { \"version\" : config . get ( \"APPLICATION_VERSION\" ), \"version2\" : config [ \"APPLICATION_VERSION\" ], } As DotNotation from assembly import ( Assembly , config ) class Index ( Assembly ): def index ( self ): return { \"default_date_format\" : config . get ( \"DATE_FORMAT.default\" ) }","title":"Usage"},{"location":"config/#class-based-configuration","text":"Each class corresponds to an environment that you will be able to use for either 'Development', 'Production', 'Testing', 'Staging' etc. class BaseConf ( object ): \"\"\" That will be default class base, which other classes will extends from \"\"\" APPLICATION_NAME = \"Assembly\" class Development ( BaseConf ): DEBUG = True class Production ( BaseConf ): DEBUG = False class Testing ( BaseConf ): DEBUG = True","title":"Class Based Configuration"},{"location":"config/#select-environment","text":"When you are ready to serve your application, set the environment variable ASSEMBLY_ENV to the class name you want to use. Example: export ASSEMBLY_ENV=Production -> for Production export ASSEMBLY_ENV=Staging -> for Staging By default Assembly will load the Development class during development.","title":"Select Environment"},{"location":"config/#default-configurations","text":"Assembly uses class-based configuration, and the config will be loaded implicitely. ./config.py is required at the root of the application. # config.py import os # The root dir ROOT_DIR = os . path . dirname ( __file__ ) # Data directory DATA_DIR = os . path . join ( ROOT_DIR , \"_data\" ) class BaseConfig ( object ): \"\"\" Base configuration \"\"\" #: Site's name or Name of the application APPLICATION_NAME = \"Assembly\" #: The application url APPLICATION_URL = \"\" #: Version of application APPLICATION_VERSION = \"0.0.1\" #: Google Analytics ID GOOGLE_ANALYTICS_ID = \"\" #: Required to setup. This email will have SUPER USER role ADMIN_EMAIL = None #: The address to receive email when using the contact page CONTACT_EMAIL = None #: PAGINATION_PER_PAGE : Total entries to display per page PAGINATION_PER_PAGE = 20 # MAX_CONTENT_LENGTH # If set to a value in bytes, Flask will reject incoming requests with a # content length greater than this by returning a 413 status code MAX_CONTENT_LENGTH = 2 * 1024 * 1024 # To remove whitespace off the HTML result COMPRESS_HTML = False # Data directory DATA_DIR = DATA_DIR #------------------- DATE FORMAT and TIMEZONE ------------- # Arrow is used as date parser # from assembly import date # http://crsmithdev.com/arrow # To view tokens: http://crsmithdev.com/arrow/#tokens # Timezone to use when dealing with date. # Example # date.now().to(config.get(\"TIMEZONE\")) # Timezone TIMEZONE = \"US/Eastern\" # Date format # Dict of dates format # Example # date.now().format(config.get(\"DATE_FORMAT.default\")) DATE_FORMAT = { \"default\" : \"MM/DD/YYYY\" , \"date\" : \"MM/DD/YYYY\" , \"datetime\" : \"MM/DD/YYYY hh:mm a\" , \"time\" : \"hh:mm a\" , \"long_datetime\" : \"dddd, MMMM D, YYYY hh:mm a\" , } #--------- AWS Credentials ---------- #: AWS Credentials # AWS is used by lots of extensions # For: S3, SES Mailer, flask S3. # The AWS Access KEY AWS_ACCESS_KEY_ID = \"\" # Secret Key AWS_SECRET_ACCESS_KEY = \"\" # The bucket name for S3 AWS_S3_BUCKET_NAME = \"\" # The default region name AWS_REGION_NAME = \"us-east-1\" #--------- DATABASES URL ---------- #: DB_URL #: Assembly uses Active-Alchemy to work with DB #: format: engine://USERNAME:PASSWORD@HOST:PORT/DB_NAME DB_URL = \"sqlite://// %s /db.db\" % DATA_DIR #: DB_REDIS_URL #: format: USERNAME:PASSWORD@HOST:PORT DB_REDIS_URL = None #--------- ASSETS DELIVERY ---------- # ASSETS DELIVERY allows to serve static files from S3, Cloudfront or other CDN # The delivery method: # - None: will use the local static files # - S3: Will use AWS S3. By default it will use the bucket name set in AWS_S3_BUCKET_NAME # When S3, AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY are required to upload files # - CDN: To use a CDN. ASSETS_DELIVERY_DOMAIN need to have the CDN domain ASSETS_DELIVERY_METHOD = None # Set the base domain of the CDN ASSETS_DELIVERY_DOMAIN = None #--------- SESSION ---------- #: SESSION #: Flask-KVSession is used to save the user's session #: Set the SESSION_URL by using these examples below to set KVSession #: To use local session, just set SESSION_URL to None #: #: Redis: redis://username:password@host:6379/db #: S3: s3://username:password@s3.aws.amazon.com/bucket #: Google Storage: google_storage://username:password@cloud.google.com/bucket #: SQL: postgresql://username:password@host:3306/db #: mysql+pysql://username:password@host:3306/db #: sqlite:// #: Memcached: memcache://host:port #: SESSION_URL = None #--------- STORAGE ---------- #: STORAGE #: Flask-Cloudy is used to save upload on S3, Google Storage, #: Cloudfiles, Azure Blobs, and Local storage #: When using local storage, they can be accessed via http://yoursite/files #: #: STORAGE_PROVIDER: # The provider to use. By default it's 'LOCAL'. # You can use: # LOCAL, S3, GOOGLE_STORAGE, AZURE_BLOBS, CLOUDFILES STORAGE_PROVIDER = \"LOCAL\" #: STORAGE_KEY # The storage key. Leave it blank if PROVIDER is LOCAL STORAGE_KEY = AWS_ACCESS_KEY_ID #: STORAGE_SECRET #: The storage secret key. Leave it blank if PROVIDER is LOCAL STORAGE_SECRET = AWS_SECRET_ACCESS_KEY #: STORAGE_REGION_NAME #: The region for the storage. Leave it blank if PROVIDER is LOCAL STORAGE_REGION_NAME = AWS_REGION_NAME #: STORAGE_CONTAINER #: The Bucket name (for S3, Google storage, Azure, cloudfile) #: or the directory name (LOCAL) to access STORAGE_CONTAINER = os . path . join ( DATA_DIR , \"uploads\" ) #: STORAGE_SERVER #: Bool, to serve local file STORAGE_SERVER = True #: STORAGE_SERVER_URL #: The url suffix for local storage STORAGE_SERVER_URL = \"files\" #:STORAGE_UPLOAD_FILE_PROPS #: A convenient K/V properties for storage.upload to use when using `upload_file()` #: It contains common properties that can passed into the upload function #: ie: upload_file(\"profile-image\", file) STORAGE_UPLOAD_FILE_PROPS = { # To upload regular images \"image\" : { \"extensions\" : [ \"jpg\" , \"png\" , \"gif\" , \"jpeg\" ], \"public\" : True }, # To upload profile image \"profile-image\" : { \"prefix\" : \"profile-image/\" , \"extensions\" : [ \"jpg\" , \"png\" , \"gif\" , \"jpeg\" ], \"public\" : True } } #--------- MAIL ---------- # To send emails # AWS SES # To use AWS SES to send email #: #: - To use the default AWS credentials (AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY) #: set MAIL_URL = \"ses://\" #: * To use a different credential: #: set MAIL_URL = \"ses://{access_key}:{secret_key}@{region}\" #: #: *** uncomment if you are using SMTP instead # MAIL_URL = \"ses://\" # SMTP #: If you are using SMTP, it will use Flask-Mail #: The uri for the smtp connection. It will use Flask-Mail #: format: smtp://USERNAME:PASSWORD@HOST:PORT #: with sll -> smtp+ssl://USERNAME:PASSWORD@HOST:PORT #: with ssl and tls -> smtp+ssl+tls://USERNAME:PASSWORD@HOST:PORT #: #: *** comment out if you are using SES instead # MAIL_URL = \"smtp+ssl://{username}:{password}@{host}:{port}\"\\ # .format(username=\"\", password=\"\", host=\"smtp.gmail.com\", port=465) #: MAIL_SENDER - The sender of the email by default #: For SES, this email must be authorized MAIL_SENDER = ADMIN_EMAIL #: MAIL_REPLY_TO #: The email to reply to by default MAIL_REPLY_TO = ADMIN_EMAIL #: MAIL_TEMPLATE #: a directory that contains the email template or a dict MAIL_TEMPLATE = os . path . join ( DATA_DIR , 'mail-templates' ) #: MAIL_TEMPLATE_CONTEXT #: a dict of all context to pass to the email by default MAIL_TEMPLATE_CONTEXT = { \"params\" : { \"site_name\" : APPLICATION_NAME , \"site_url\" : APPLICATION_URL } } #--------- CACHING ---------- #: Flask-Cache is used to caching #: CACHE_TYPE #: The type of cache to use #: null, simple, redis, filesystem, CACHE_TYPE = \"simple\" #: CACHE_REDIS_URL #: If CHACHE_TYPE is 'redis', set the redis uri #: redis://username:password@host:port/db CACHE_REDIS_URL = \"\" #: CACHE_DIR #: Directory to store cache if CACHE_TYPE is filesystem, it will CACHE_DIR = \"\" # -------------------------- ENVIRONMENT BASED CONFIG --------------------------- \"\"\" The environment based config is what will be loaded. By default it will load the development ## 1. Set environment variables export ASSEMBLY_ENV=Development # for development export ASSEMBLY_APP=default ## 2. Run the wsgi wsgi:app ### **for local server asm-admin server \"\"\" class Development ( BaseConfig ): \"\"\" Config for development environment \"\"\" SERVER_NAME = None DEBUG = True SECRET_KEY = \"PLEASE CHANGE ME\" class Production ( BaseConfig ): \"\"\" Config for Production environment \"\"\" SERVER_NAME = None DEBUG = False SECRET_KEY = None COMPRESS_HTML = True","title":"Default Configurations"},{"location":"contribute/","text":"Overview Assembly is a community-maintained, open-source project hosted at Github. The project actively encourages aspiring and experienced users to dive in and add their best contribution to the project. How can you contribute? Search the docs and the issues page to see if someone has already reported your issue. Versioning: Semver Assembly adheres to Semver (semantic version), for the a. Version will be X.Y.Z (X=Major, Y=Minor, Z=Patch) Bug Reports If you find a bug, an issue where the product doesn\u2019t behave as you expect, you may file a bug report at the issues page . Be sure to include what your expectation was, what happened instead, details about your system that might be relevant, and steps that someone else could take to replicate your finding. The more detailed and exact your description, the better one of the volunteers on the project may be able to help resolve. Pull Requests To contribute, first read How to write the perfect pull request and file your contribution with the Assembly page. Build the docs The documentation is built with MkDocs /docs contains all the MD files that will be present for build. mkdocs.yml contains the manifest of the site, including the navigation under pages Install pip install - r requirements - docs . txt Serve local mkdocs serve Deploy to Github mkdocs gh - deploy --clean Edit Docs & pull requests Edit the files that need updates or need to be created under /docs . Files are in Markdown format. If you are adding a new doc file, you may want to put it in mkdocs.yml under pages so it can be shown in the menu. Then commit and push your code in master to make a pull request. make sure /site folder is in the .gitignore . Because this folder is generated by MkDocs. Do not COMMIT or PUSH the /site directory generated by MkDocs.","title":"Contribute"},{"location":"contribute/#overview","text":"Assembly is a community-maintained, open-source project hosted at Github. The project actively encourages aspiring and experienced users to dive in and add their best contribution to the project. How can you contribute? Search the docs and the issues page to see if someone has already reported your issue.","title":"Overview"},{"location":"contribute/#versioning-semver","text":"Assembly adheres to Semver (semantic version), for the a. Version will be X.Y.Z (X=Major, Y=Minor, Z=Patch)","title":"Versioning: Semver"},{"location":"contribute/#bug-reports","text":"If you find a bug, an issue where the product doesn\u2019t behave as you expect, you may file a bug report at the issues page . Be sure to include what your expectation was, what happened instead, details about your system that might be relevant, and steps that someone else could take to replicate your finding. The more detailed and exact your description, the better one of the volunteers on the project may be able to help resolve.","title":"Bug Reports"},{"location":"contribute/#pull-requests","text":"To contribute, first read How to write the perfect pull request and file your contribution with the Assembly page.","title":"Pull Requests"},{"location":"contribute/#build-the-docs","text":"The documentation is built with MkDocs /docs contains all the MD files that will be present for build. mkdocs.yml contains the manifest of the site, including the navigation under pages","title":"Build the docs"},{"location":"contribute/#install","text":"pip install - r requirements - docs . txt","title":"Install"},{"location":"contribute/#serve-local","text":"mkdocs serve","title":"Serve local"},{"location":"contribute/#deploy-to-github","text":"mkdocs gh - deploy --clean","title":"Deploy to Github"},{"location":"contribute/#edit-docs-pull-requests","text":"Edit the files that need updates or need to be created under /docs . Files are in Markdown format. If you are adding a new doc file, you may want to put it in mkdocs.yml under pages so it can be shown in the menu. Then commit and push your code in master to make a pull request. make sure /site folder is in the .gitignore . Because this folder is generated by MkDocs. Do not COMMIT or PUSH the /site directory generated by MkDocs.","title":"Edit Docs &amp; pull requests"},{"location":"deploy/","text":"Deploy Options To get a comprehensive deploy options with Assembly, please follow Deploying Options with Flask. Assembly is actually Flask, so everything on the link is valid for Assembly. Below are some of the options, you would be interested in. Environment Variable Note : When deploying, make sure you set the right environment export ASSEMBLY_APP = default export ASSEMBLY_ENV = Development Gunicorn Gunicorn \u2018Green Unicorn\u2019 is a WSGI HTTP Server for UNIX. It\u2019s a pre-fork worker model ported from Ruby\u2019s Unicorn project. It supports both eventlet and greenlet. export ASSEMBLY_APP = default export ASSEMBLY_ENV = Production gunicorn - w 4 wsgi : app uWSGI uWSGI is a fast application server written in C. It is very configurable which makes it more complicated to setup than gunicorn. export ASSEMBLY_APP = default export ASSEMBLY_ENV = Production uwsgi --http 127.0.0.1:5000 --module wsgi:app Gokku Gokku is a very small PaaS to do git push deployments to your own servers (Digital Ocean, Linode) similar to Heroku. Learn more about Gokku Gokku configuration is already shipped with Assembly, with app.json . The app.json will launch your website from 0 to 100 just like it would on Heroku. At the root of the application, app.json is a manifest format for describing web apps. It declares environment variables, scripts, and other information required to run an app on your server. { \"gokku\" : { \"domain_name\" : \"myapp.domain.com\" , \"env\" : { \"ASSEMBLY_ENV\" : \"Production\" , \"ASSEMBLY_APP\" : \"default\" } , \"scripts\" : { \"release\" : [ \"asm-admin sync-models\" , \"asm setup\" ] } , \"run\" : { \"web\" : \"wsgi:app\" } } }","title":"Deployment"},{"location":"deploy/#deploy-options","text":"To get a comprehensive deploy options with Assembly, please follow Deploying Options with Flask. Assembly is actually Flask, so everything on the link is valid for Assembly. Below are some of the options, you would be interested in.","title":"Deploy Options"},{"location":"deploy/#environment-variable","text":"Note : When deploying, make sure you set the right environment export ASSEMBLY_APP = default export ASSEMBLY_ENV = Development","title":"Environment Variable"},{"location":"deploy/#gunicorn","text":"Gunicorn \u2018Green Unicorn\u2019 is a WSGI HTTP Server for UNIX. It\u2019s a pre-fork worker model ported from Ruby\u2019s Unicorn project. It supports both eventlet and greenlet. export ASSEMBLY_APP = default export ASSEMBLY_ENV = Production gunicorn - w 4 wsgi : app","title":"Gunicorn"},{"location":"deploy/#uwsgi","text":"uWSGI is a fast application server written in C. It is very configurable which makes it more complicated to setup than gunicorn. export ASSEMBLY_APP = default export ASSEMBLY_ENV = Production uwsgi --http 127.0.0.1:5000 --module wsgi:app","title":"uWSGI"},{"location":"deploy/#gokku","text":"Gokku is a very small PaaS to do git push deployments to your own servers (Digital Ocean, Linode) similar to Heroku. Learn more about Gokku Gokku configuration is already shipped with Assembly, with app.json . The app.json will launch your website from 0 to 100 just like it would on Heroku. At the root of the application, app.json is a manifest format for describing web apps. It declares environment variables, scripts, and other information required to run an app on your server. { \"gokku\" : { \"domain_name\" : \"myapp.domain.com\" , \"env\" : { \"ASSEMBLY_ENV\" : \"Production\" , \"ASSEMBLY_APP\" : \"default\" } , \"scripts\" : { \"release\" : [ \"asm-admin sync-models\" , \"asm setup\" ] } , \"run\" : { \"web\" : \"wsgi:app\" } } }","title":"Gokku"},{"location":"first-app/","text":"If you haven't done so yet, you need to mocha :init in the directory that you want to install mocha : init Once created, you should see a file structure similar to this Your first app Here's what Mocha will do, and expecting: that your views are structured in class the class inherits mocha.Mocha if the class name is Index(Mocha) , it will be the base route as / the methods are the views actions the methods name will become the endpoint url if the method name is index(self) , it will be the entry point of that view methods name with underscore will be dasherized, about_us(self) -> /about-us/ the methods return data as dict type the data returned is passed to your template the template is named after the method name the template is magically included in your layout Mocha brews everything together, and renders the page Views All your view module should be placed in application/views . By default , main.py view is created main.py must contain at a least one class that inherits Mocha . A view module may have multiple classes application/views/main.py from mocha import Mocha , page_attr class Index ( Mocha ): def index ( self ): page_attr ( \"Hello World\" ) return { \"name\" : \"Mocha\" , \"version\" : \"1.0\" } def about_us ( self ): page_attr ( \"About Us\" ) return class Document ( Mocha ): def index ( self ): page_attr ( 'All documents' ) return { \"docs\" : [ { \"id\" : 1 , \"title\" : \"This is a doc title\" }, ... ] } def get ( self , id ): page_attr ( \"This is a doc title\" ) return { \"id\" : id , \"title\" : \"This is a doc title\" , \"content\" : \"My content\" } The main.py module contains two view classes: Index and Document that inherit Mocha . Also imported page_attr , a utility function to set the page title and other page attributes The methods return dict or None The route will be created from the class and method name. If the class name is Index , it will be the root of the domain, in this example / , and other will stay as is, in this instance the Document will have as route /document/ . The following url will be created: Index:index() -> http://localhost:5000/ Index:about_us() -> http://localhost:5000/about-us Document:index() -> http://localhost:5000/document Document:get(id) -> http://localhost:5000/document/1234 Template All your templates should be placed in application/templates . And must follow the same directory structure relative to the view modules. The returned data from the view will be passed to the template. So for application/views/main.py , it is expecting the following template structure / application | | -- templates | | | -- main/ | | -- Index/ | | -- index.jade | | -- about_us.jade | | __ Document / | | -- index.jade | | -- get.jade As you can see, the template structure follows the view structure, where in the view: main.py -> /templates/main main.py:Index() -> templates/main/Index main.py:Index(Mocha):index(self) -> templates/main/Index/index.jade main.py:Index(Mocha):about_us(self) -> templates/main/Index/about_us.jade main.py:Document() -> templates/main/Document main.py:Document(Mocha):index(self) -> templates/main/Document/index.jade main.py:Document(Mocha):get(self) -> templates/main/Document/get.jade Also, you may have noticed that we use .jade template instead of HTML, just for aesthetic, as it looks like python on the templates side. But HTML can also be used. templates/main/Index/index.jade .row .col-md-12.text-center h2 = name small = version Which will be translated into html <div class= \"row\" > <div class= \"col-md-12 text-center\" > <h2> Mocha <small> 1.0 </small></h2> </div> </div> templates/main/Document/index.jade . row . col - md - 12 ul for doc in docs li : a ( href = url_for ( ' views.main.Document:get ' , id = doc . id )) = doc . title Will be translated into html <div class= \"row\" > <div class= \"col-md-12\" > <ul> <li><a href= '/document/1' > This is a doc title </a></li> </ul> </div> </div> Layout By default, layouts are placed in application/templates/layouts , and upon rendering Mocha will glue your view in the layout. The default layout is at: application/templates/layouts/base.jade While you can have extends in your templates, Mocha makes it easy to bypass the repetitive tasks, so you can fully focus on that one page you are working on. - import \"contrib/components/html.html\" as html with context - import \"contrib/components/nav.jade\" as nav with context - import \"contrib/components/forms.html\" as forms with context - import \"contrib/components/widget.html\" as widget with context !!! 5 html ( lang = \"en\" ) head meta ( charset = \"utf-8\" ) meta ( name = \"viewport\" , content = \"width=device-width, initial-scale=1.0\" ) + html . page_title () + html . page_description () + html . opengraph () + html . favicon ( \"favicon.ico\" ) + html . include_jquery () + html . include_bootstrap () + html . include_fontawesome () + html . include_bootswatch_theme ( 'yeti' ) + html . include_css_file ( \"commons.css\" ) + html . include_css_file ( \"styles.css\" ) + html . include_js_file ( \"app.js\" ) + html . google_analytics () body . container - include __template__ footer . container - fluid . row . col - md - 12 . text - center . & copy ; {{ g . __YEAR__ }} {{ config . APPLICATION_NAME }} {{ config . APPLICATION_VERSION }} The most important part of the layout is include __template__ . This where the view template will be injected. There are much more stuff going on it the template, we can tackle them later. Static Static hold your assets: js, css, images. They must be placed in /application/static/ Mocha uses Flask-Assets to manage your assets. Therefor assets.yml is a bundle collection, that allows you to bundle css or js together. assets.yml styles . css : output : \"gen/styles.css\" contents : - css / style . css app . js : output : \"gen/app.js\" contents : - js / app . js And in your template you can call it + html . include_css_file ( \"style.css\" ) + html . include_js_file ( \"app.js\" ) As a convenience, we include a package.json if you want to download 3rd party scripts (js, css). You can either run npm install in static directory, or run mocha :install-assets , which will install your assets in the node_modules Serve Now we are done with our application, all we need to do is serve it. mocha : serve The command above will run brew.py brew.py is the entry point of the application. from mocha import Brew projects = { \"main\" : [ \"main\" ] } app = Brew ( __name__ , projects ) projects is a dict containing all the views to be used. Let's say if we had the views: main.py , account.py , music.py , books.py We could put them into one projects = { \"main\" : [ \"main\" , \"account\" , \"music\" , \"books\" ] } Upon serving the app, it would make all the endpoints available. Let's say we want to run multiple application projects = { \"main\" : [ \"main\" , \"account\" ], \"library\" : [ \"music\" , \"books\" ] } Now we have 2 applications: main and library By default, Mocha will default to main mocha : serve But to run library app = library mocha : serve If two apps are running at the same time, you may need to specify a different port app = library mocha : serve --port 5001","title":"First app"},{"location":"first-app/#your-first-app","text":"Here's what Mocha will do, and expecting: that your views are structured in class the class inherits mocha.Mocha if the class name is Index(Mocha) , it will be the base route as / the methods are the views actions the methods name will become the endpoint url if the method name is index(self) , it will be the entry point of that view methods name with underscore will be dasherized, about_us(self) -> /about-us/ the methods return data as dict type the data returned is passed to your template the template is named after the method name the template is magically included in your layout Mocha brews everything together, and renders the page","title":"Your first app"},{"location":"first-app/#views","text":"All your view module should be placed in application/views . By default , main.py view is created main.py must contain at a least one class that inherits Mocha . A view module may have multiple classes application/views/main.py from mocha import Mocha , page_attr class Index ( Mocha ): def index ( self ): page_attr ( \"Hello World\" ) return { \"name\" : \"Mocha\" , \"version\" : \"1.0\" } def about_us ( self ): page_attr ( \"About Us\" ) return class Document ( Mocha ): def index ( self ): page_attr ( 'All documents' ) return { \"docs\" : [ { \"id\" : 1 , \"title\" : \"This is a doc title\" }, ... ] } def get ( self , id ): page_attr ( \"This is a doc title\" ) return { \"id\" : id , \"title\" : \"This is a doc title\" , \"content\" : \"My content\" } The main.py module contains two view classes: Index and Document that inherit Mocha . Also imported page_attr , a utility function to set the page title and other page attributes The methods return dict or None The route will be created from the class and method name. If the class name is Index , it will be the root of the domain, in this example / , and other will stay as is, in this instance the Document will have as route /document/ . The following url will be created: Index:index() -> http://localhost:5000/ Index:about_us() -> http://localhost:5000/about-us Document:index() -> http://localhost:5000/document Document:get(id) -> http://localhost:5000/document/1234","title":"Views"},{"location":"first-app/#template","text":"All your templates should be placed in application/templates . And must follow the same directory structure relative to the view modules. The returned data from the view will be passed to the template. So for application/views/main.py , it is expecting the following template structure / application | | -- templates | | | -- main/ | | -- Index/ | | -- index.jade | | -- about_us.jade | | __ Document / | | -- index.jade | | -- get.jade As you can see, the template structure follows the view structure, where in the view: main.py -> /templates/main main.py:Index() -> templates/main/Index main.py:Index(Mocha):index(self) -> templates/main/Index/index.jade main.py:Index(Mocha):about_us(self) -> templates/main/Index/about_us.jade main.py:Document() -> templates/main/Document main.py:Document(Mocha):index(self) -> templates/main/Document/index.jade main.py:Document(Mocha):get(self) -> templates/main/Document/get.jade Also, you may have noticed that we use .jade template instead of HTML, just for aesthetic, as it looks like python on the templates side. But HTML can also be used. templates/main/Index/index.jade .row .col-md-12.text-center h2 = name small = version Which will be translated into html <div class= \"row\" > <div class= \"col-md-12 text-center\" > <h2> Mocha <small> 1.0 </small></h2> </div> </div> templates/main/Document/index.jade . row . col - md - 12 ul for doc in docs li : a ( href = url_for ( ' views.main.Document:get ' , id = doc . id )) = doc . title Will be translated into html <div class= \"row\" > <div class= \"col-md-12\" > <ul> <li><a href= '/document/1' > This is a doc title </a></li> </ul> </div> </div>","title":"Template"},{"location":"first-app/#layout","text":"By default, layouts are placed in application/templates/layouts , and upon rendering Mocha will glue your view in the layout. The default layout is at: application/templates/layouts/base.jade While you can have extends in your templates, Mocha makes it easy to bypass the repetitive tasks, so you can fully focus on that one page you are working on. - import \"contrib/components/html.html\" as html with context - import \"contrib/components/nav.jade\" as nav with context - import \"contrib/components/forms.html\" as forms with context - import \"contrib/components/widget.html\" as widget with context !!! 5 html ( lang = \"en\" ) head meta ( charset = \"utf-8\" ) meta ( name = \"viewport\" , content = \"width=device-width, initial-scale=1.0\" ) + html . page_title () + html . page_description () + html . opengraph () + html . favicon ( \"favicon.ico\" ) + html . include_jquery () + html . include_bootstrap () + html . include_fontawesome () + html . include_bootswatch_theme ( 'yeti' ) + html . include_css_file ( \"commons.css\" ) + html . include_css_file ( \"styles.css\" ) + html . include_js_file ( \"app.js\" ) + html . google_analytics () body . container - include __template__ footer . container - fluid . row . col - md - 12 . text - center . & copy ; {{ g . __YEAR__ }} {{ config . APPLICATION_NAME }} {{ config . APPLICATION_VERSION }} The most important part of the layout is include __template__ . This where the view template will be injected. There are much more stuff going on it the template, we can tackle them later.","title":"Layout"},{"location":"first-app/#static","text":"Static hold your assets: js, css, images. They must be placed in /application/static/ Mocha uses Flask-Assets to manage your assets. Therefor assets.yml is a bundle collection, that allows you to bundle css or js together. assets.yml styles . css : output : \"gen/styles.css\" contents : - css / style . css app . js : output : \"gen/app.js\" contents : - js / app . js And in your template you can call it + html . include_css_file ( \"style.css\" ) + html . include_js_file ( \"app.js\" ) As a convenience, we include a package.json if you want to download 3rd party scripts (js, css). You can either run npm install in static directory, or run mocha :install-assets , which will install your assets in the node_modules","title":"Static"},{"location":"first-app/#serve","text":"Now we are done with our application, all we need to do is serve it. mocha : serve The command above will run brew.py brew.py is the entry point of the application. from mocha import Brew projects = { \"main\" : [ \"main\" ] } app = Brew ( __name__ , projects ) projects is a dict containing all the views to be used. Let's say if we had the views: main.py , account.py , music.py , books.py We could put them into one projects = { \"main\" : [ \"main\" , \"account\" , \"music\" , \"books\" ] } Upon serving the app, it would make all the endpoints available. Let's say we want to run multiple application projects = { \"main\" : [ \"main\" , \"account\" ], \"library\" : [ \"music\" , \"books\" ] } Now we have 2 applications: main and library By default, Mocha will default to main mocha : serve But to run library app = library mocha : serve If two apps are running at the same time, you may need to specify a different port app = library mocha : serve --port 5001","title":"Serve"},{"location":"install/","text":"Assembly is a Pythonic Object-Oriented Web Framework built on Flask Requirements Python 3.6+ Virtualenv Install Install Assembly with pip install assembly It is highly recommended to use a virtualenv, in this case let's use VirtualenvWrapper (you can use any that is convenient for you) mkvirtualenv my - first - app workon my - first - app pip install assembly Initialize Initialize Assembly with asm-admin init CD into the folder you intend to create the application, then run asm-admin init . This will setup the structure along with the necessary files to get started cd app - dir asm - admin init Launch first app asm - admin serve","title":"Installation"},{"location":"install/#requirements","text":"Python 3.6+ Virtualenv","title":"Requirements"},{"location":"install/#install","text":"Install Assembly with pip install assembly It is highly recommended to use a virtualenv, in this case let's use VirtualenvWrapper (you can use any that is convenient for you) mkvirtualenv my - first - app workon my - first - app pip install assembly","title":"Install"},{"location":"install/#initialize","text":"Initialize Assembly with asm-admin init CD into the folder you intend to create the application, then run asm-admin init . This will setup the structure along with the necessary files to get started cd app - dir asm - admin init","title":"Initialize"},{"location":"install/#launch-first-app","text":"asm - admin serve","title":"Launch first app"},{"location":"tutorials/","text":"Setup Assembly Install pip install assembly Initialiaze asm-admin init Run Development Server asm-admin serve REST API Generate the view using asm-admin asm-admin gen-api-view my-api This will generate a View package with __init__.py , __models__.py , cli.py . Import in wsgi.py # wsgi . py APPS = { \"default\" : [ \"main\" , \"api\" ] } Edit View # /api/__init__.py from assembly import ( Assembly , request , response , date ) @response.route ( \"/api/\" ) class Index ( Assembly ): @response.json def index ( self ): return { \"date\" : date . utcnow () } @request.post def submit_info ( self ): return { \"message\" : \"Thank you\" } HTML Site Generate the view using asm-admin asm-admin gen-template-view admin This will generate a View package with __init__.py , __models__.py , templates/ , static/ , cli.py . Import in wsgi.py # wsgi . py APPS = { \"default\" : [ \"main\" , \"admin\" ] } Edit your first view # admin/__init__.py from assembly import ( Assembly , response ) @response.route ( \"/admin/\" ) class Index ( Assembly ): index ( self ): return { \"title\" : \"Assembly is awesome\" , \"content\" : \"That is a true fact\" } @response.json api ( self ): return { \"name\" : \"Assembly\" , \"version\" : \"x-to-infinity\" } Edit Index/index.html <!-- admin/templates/Index/index.html --> {% extends 'main/layouts/base.html' %} {% block title %} Welcome to Admin {% endblock %} {% block body %} <div> <h1> {{ title }} </h1> </div> <div> {{ content }} </div> {% endblock %} Serve your first application If everything is all set, all you need to do now is run your site: asm - admin serve It will start serving your application by default at 127.0.0.1:5000 Two endpoints will be available: http://127.0.0.1:5000/admin which will show an HTML http://127.0.0.1:5000/admin/api/ which will a json response Error Handler Work with CORS API Create Custom CLI Work with CSRF Upload Application","title":"Tutorials"},{"location":"tutorials/#setup-assembly","text":"Install pip install assembly Initialiaze asm-admin init Run Development Server asm-admin serve","title":"Setup Assembly"},{"location":"tutorials/#rest-api","text":"Generate the view using asm-admin asm-admin gen-api-view my-api This will generate a View package with __init__.py , __models__.py , cli.py . Import in wsgi.py # wsgi . py APPS = { \"default\" : [ \"main\" , \"api\" ] } Edit View # /api/__init__.py from assembly import ( Assembly , request , response , date ) @response.route ( \"/api/\" ) class Index ( Assembly ): @response.json def index ( self ): return { \"date\" : date . utcnow () } @request.post def submit_info ( self ): return { \"message\" : \"Thank you\" }","title":"REST API"},{"location":"tutorials/#html-site","text":"Generate the view using asm-admin asm-admin gen-template-view admin This will generate a View package with __init__.py , __models__.py , templates/ , static/ , cli.py . Import in wsgi.py # wsgi . py APPS = { \"default\" : [ \"main\" , \"admin\" ] } Edit your first view # admin/__init__.py from assembly import ( Assembly , response ) @response.route ( \"/admin/\" ) class Index ( Assembly ): index ( self ): return { \"title\" : \"Assembly is awesome\" , \"content\" : \"That is a true fact\" } @response.json api ( self ): return { \"name\" : \"Assembly\" , \"version\" : \"x-to-infinity\" } Edit Index/index.html <!-- admin/templates/Index/index.html --> {% extends 'main/layouts/base.html' %} {% block title %} Welcome to Admin {% endblock %} {% block body %} <div> <h1> {{ title }} </h1> </div> <div> {{ content }} </div> {% endblock %} Serve your first application If everything is all set, all you need to do now is run your site: asm - admin serve It will start serving your application by default at 127.0.0.1:5000 Two endpoints will be available: http://127.0.0.1:5000/admin which will show an HTML http://127.0.0.1:5000/admin/api/ which will a json response","title":"HTML Site"},{"location":"tutorials/#error-handler","text":"","title":"Error Handler"},{"location":"tutorials/#work-with-cors-api","text":"","title":"Work with CORS API"},{"location":"tutorials/#create-custom-cli","text":"","title":"Create Custom CLI"},{"location":"tutorials/#work-with-csrf","text":"","title":"Work with CSRF"},{"location":"tutorials/#upload-application","text":"","title":"Upload Application"},{"location":"wsgipy/","text":"Overview wsgi.py is the application's entry point which contains the application object called app wsgi.py and app are both required. wsgi.py # wsgi.py from assembly import Assembly APPS = { \"default\" : [ \"main\" ] } app = Assembly . initialize ( __name__ , APPS ) app app is the application object. It's a Flask object actually. __name__ __name__ is a special variable that gets as value the string \" main \" when the file gets executed. APPS Assembly is a multi-application framework, where you can launch different application with the same code base. To achieve this, Assembly requires a list off all the views to be used per app. Upon deploying an app, you can select on by providing the name of it using the environment variable ASSEMBLY_APP . Environment Variables Having set wsgi.py properly you will be able to load different apps using the environment variables. ASSEMBLY_APP export ASSEMBLY_APP=$appname , where $appname is name from the APPS list. ASSEMBLY_ENV export ASSEMBLY_ENV=$configClassName , where $configClassName is a class name from config.py . Deployment To deploy your application, learn more about Deploy Options","title":"wsgi.py"},{"location":"wsgipy/#overview","text":"wsgi.py is the application's entry point which contains the application object called app wsgi.py and app are both required.","title":"Overview"},{"location":"wsgipy/#wsgipy","text":"# wsgi.py from assembly import Assembly APPS = { \"default\" : [ \"main\" ] } app = Assembly . initialize ( __name__ , APPS )","title":"wsgi.py"},{"location":"wsgipy/#app","text":"app is the application object. It's a Flask object actually.","title":"app"},{"location":"wsgipy/#9595name__","text":"__name__ is a special variable that gets as value the string \" main \" when the file gets executed.","title":"__name__"},{"location":"wsgipy/#apps","text":"Assembly is a multi-application framework, where you can launch different application with the same code base. To achieve this, Assembly requires a list off all the views to be used per app. Upon deploying an app, you can select on by providing the name of it using the environment variable ASSEMBLY_APP .","title":"APPS"},{"location":"wsgipy/#environment-variables","text":"Having set wsgi.py properly you will be able to load different apps using the environment variables.","title":"Environment Variables"},{"location":"wsgipy/#assembly_app","text":"export ASSEMBLY_APP=$appname , where $appname is name from the APPS list.","title":"ASSEMBLY_APP"},{"location":"wsgipy/#assembly_env","text":"export ASSEMBLY_ENV=$configClassName , where $configClassName is a class name from config.py .","title":"ASSEMBLY_ENV"},{"location":"wsgipy/#deployment","text":"To deploy your application, learn more about Deploy Options","title":"Deployment"},{"location":"advanced/bcrypt/","text":"bcrypt from the passlib library is used to hash and verify password. Import from mocha import bcrypt Hash password Hash a password for storage my_string_pass = \"mypass123\" my_hash = bcrypt . hash ( my_string_pass ) Verify password Verify a password by using the string provided to hash, and the hash that was created previously. It returns a bool. bcrypt . verify ( my_string_pass , my_hash ) Config bcrypt can be used with no configuration as it will fall back to its default. But if you want you can have the following config BCRYPT_SALT = \"\" BCRYPT_ROUNDS = 12 BCRYPT_INDENT = \"\"","title":"Bcrypt"},{"location":"advanced/bcrypt/#import","text":"from mocha import bcrypt","title":"Import"},{"location":"advanced/bcrypt/#hash-password","text":"Hash a password for storage my_string_pass = \"mypass123\" my_hash = bcrypt . hash ( my_string_pass )","title":"Hash password"},{"location":"advanced/bcrypt/#verify-password","text":"Verify a password by using the string provided to hash, and the hash that was created previously. It returns a bool. bcrypt . verify ( my_string_pass , my_hash )","title":"Verify password"},{"location":"advanced/bcrypt/#config","text":"bcrypt can be used with no configuration as it will fall back to its default. But if you want you can have the following config BCRYPT_SALT = \"\" BCRYPT_ROUNDS = 12 BCRYPT_INDENT = \"\"","title":"Config"},{"location":"advanced/caching/","text":"Overview Assembly uses flask-caching to cache the endpoint responses. It allows to use different backend, ie: Redis, Memcache, etc. The Cache configuration can be set in the config.py file. Extension: flask-caching Usage Assembly exposes @response.cache to cache enpoint. The decorator will use request.path by default for the cache_key from assembly import Assembly , response , date class Index ( Assembly ): @response.json def index ( self ): return { \"description\" : \"not cached\" , \"date\" : date . utcnow () } @response.cache ( 10 ) @response.json def cached ( self ): return { \"description\" : \"cached\" , \"date\" : date . utcnow () } Configuration Set the configuration below in your config.py file. #: CACHE_TYPE #: The type of cache to use #: null , simple , redis , filesystem , CACHE_TYPE = \" simple \" #: CACHE_REDIS_URL #: If CHACHE_TYPE is ' redis ' , set the redis uri #: redis : // username : password @ host : port / db CACHE_REDIS_URL = \"\" #: CACHE_DIR #: Directory to store cache if CACHE_TYPE is filesystem , it will CACHE_DIR = \"\"","title":"Caching"},{"location":"advanced/caching/#overview","text":"Assembly uses flask-caching to cache the endpoint responses. It allows to use different backend, ie: Redis, Memcache, etc. The Cache configuration can be set in the config.py file. Extension: flask-caching","title":"Overview"},{"location":"advanced/caching/#usage","text":"Assembly exposes @response.cache to cache enpoint. The decorator will use request.path by default for the cache_key from assembly import Assembly , response , date class Index ( Assembly ): @response.json def index ( self ): return { \"description\" : \"not cached\" , \"date\" : date . utcnow () } @response.cache ( 10 ) @response.json def cached ( self ): return { \"description\" : \"cached\" , \"date\" : date . utcnow () }","title":"Usage"},{"location":"advanced/caching/#configuration","text":"Set the configuration below in your config.py file. #: CACHE_TYPE #: The type of cache to use #: null , simple , redis , filesystem , CACHE_TYPE = \" simple \" #: CACHE_REDIS_URL #: If CHACHE_TYPE is ' redis ' , set the redis uri #: redis : // username : password @ host : port / db CACHE_REDIS_URL = \"\" #: CACHE_DIR #: Directory to store cache if CACHE_TYPE is filesystem , it will CACHE_DIR = \"\"","title":"Configuration"},{"location":"advanced/cookies/","text":"Overview Assembly allows you to easily, set, get and delete cookie. It exposes some functions to help you with that. version: 1.1.0 Usage Import from assembly import set_cookie , get_cookie , delete_cookie set_cookie To set a cookie from assembly import ( Assembly , set_cookie ) class Index ( Assembly ): def index ( self ): set_cookie ( \"my_key\" , \"my_value\" ) return set_cookie ( key , value = \"\" , max_age = None , expires = None , path = \" / \" , domain = None , secure = False , httponly = False , samesite = None ) Sets a cookie . The parameters are the same as in the cookie ` Morsel ` object in the Python standard library but it accepts unicode data , too . :param key : the key ( name ) of the cookie to be set . :param value : the value of the cookie . :param max_age : should be a number of seconds , or ` None ` ( default ) if the cookie should last only as long as the client ' s browser session . :param expires : should be a ` datetime ` object or UNIX timestamp . :param path : limits the cookie to a given path , per default it will span the whole domain . :param domain : if you want to set a cross - domain cookie . For example , `` domain = \" .example.com \" `` will set a cookie that is readable by the domain `` www . example . com ``, `` foo . example . com `` etc . Otherwise , a cookie will only be readable by the domain that set it . :param secure : If ` True `, the cookie will only be available via HTTPS :param httponly : disallow JavaScript to access the cookie . This is an extension to the cookie standard and probably not supported by all browsers . :param samesite : Limits the scope of the cookie such that it will only be attached to requests if those requests are \" same-site \" . get_cookie To retrieve a cookie. It will return None if the key doesn't exist. You can also retrieve the cookie with request.cookies from assembly import ( Assembly , get_cookie ) class Index ( Assembly ): def index ( self ): get_cookie ( \"my_key\" ) return delete_cookie To delete a cookie that was set. It will silently fail if it doesn't exist from assembly import ( Assembly , delete_cookie ) class Index ( Assembly ): def index ( self ): delete_cookie ( \"my_key\" ) return delete_cookie ( self , key , path = \" / \" , domain = None ) Delete a cookie . Fails silently if key doesn ' t exist. :param key : the key ( name ) of the cookie to be deleted . :param path : if the cookie that should be deleted was limited to a path , the path has to be defined here . :param domain : if the cookie that should be deleted was limited to a domain , that domain has to be defined here .","title":"Cookies"},{"location":"advanced/cookies/#overview","text":"Assembly allows you to easily, set, get and delete cookie. It exposes some functions to help you with that. version: 1.1.0","title":"Overview"},{"location":"advanced/cookies/#usage","text":"","title":"Usage"},{"location":"advanced/cookies/#import","text":"from assembly import set_cookie , get_cookie , delete_cookie","title":"Import"},{"location":"advanced/cookies/#set_cookie","text":"To set a cookie from assembly import ( Assembly , set_cookie ) class Index ( Assembly ): def index ( self ): set_cookie ( \"my_key\" , \"my_value\" ) return set_cookie ( key , value = \"\" , max_age = None , expires = None , path = \" / \" , domain = None , secure = False , httponly = False , samesite = None ) Sets a cookie . The parameters are the same as in the cookie ` Morsel ` object in the Python standard library but it accepts unicode data , too . :param key : the key ( name ) of the cookie to be set . :param value : the value of the cookie . :param max_age : should be a number of seconds , or ` None ` ( default ) if the cookie should last only as long as the client ' s browser session . :param expires : should be a ` datetime ` object or UNIX timestamp . :param path : limits the cookie to a given path , per default it will span the whole domain . :param domain : if you want to set a cross - domain cookie . For example , `` domain = \" .example.com \" `` will set a cookie that is readable by the domain `` www . example . com ``, `` foo . example . com `` etc . Otherwise , a cookie will only be readable by the domain that set it . :param secure : If ` True `, the cookie will only be available via HTTPS :param httponly : disallow JavaScript to access the cookie . This is an extension to the cookie standard and probably not supported by all browsers . :param samesite : Limits the scope of the cookie such that it will only be attached to requests if those requests are \" same-site \" .","title":"set_cookie"},{"location":"advanced/cookies/#get_cookie","text":"To retrieve a cookie. It will return None if the key doesn't exist. You can also retrieve the cookie with request.cookies from assembly import ( Assembly , get_cookie ) class Index ( Assembly ): def index ( self ): get_cookie ( \"my_key\" ) return","title":"get_cookie"},{"location":"advanced/cookies/#delete_cookie","text":"To delete a cookie that was set. It will silently fail if it doesn't exist from assembly import ( Assembly , delete_cookie ) class Index ( Assembly ): def index ( self ): delete_cookie ( \"my_key\" ) return delete_cookie ( self , key , path = \" / \" , domain = None ) Delete a cookie . Fails silently if key doesn ' t exist. :param key : the key ( name ) of the cookie to be deleted . :param path : if the cookie that should be deleted was limited to a path , the path has to be defined here . :param domain : if the cookie that should be deleted was limited to a domain , that domain has to be defined here .","title":"delete_cookie"},{"location":"advanced/core/","text":"Overview Core methods and functions Functions Assembly from assembly import Assembly config from assembly import config env from assembly import env ext from assembly import ext db from assembly import db models from assembly import models Holds all class models that have been extended by db.Model . To use, access them via models.{ModelName} from assembly import models class Index ( Assembly ): def index ( self ): user = models . User . query () views from assembly import views date from assembly import date set_cookie from assembly import set_cookie get_cookie from assembly import get_cookie delete_cookie from assembly import delete_cookie url_for from assembly import url_for redirect from assembly import redirect Decorators view_decorator from assembly import view_decorator app_context from assembly import app_context","title":"Core"},{"location":"advanced/core/#overview","text":"Core methods and functions","title":"Overview"},{"location":"advanced/core/#functions","text":"","title":"Functions"},{"location":"advanced/core/#assembly","text":"from assembly import Assembly","title":"Assembly"},{"location":"advanced/core/#config","text":"from assembly import config","title":"config"},{"location":"advanced/core/#env","text":"from assembly import env","title":"env"},{"location":"advanced/core/#ext","text":"from assembly import ext","title":"ext"},{"location":"advanced/core/#db","text":"from assembly import db","title":"db"},{"location":"advanced/core/#models","text":"from assembly import models Holds all class models that have been extended by db.Model . To use, access them via models.{ModelName} from assembly import models class Index ( Assembly ): def index ( self ): user = models . User . query ()","title":"models"},{"location":"advanced/core/#views","text":"from assembly import views","title":"views"},{"location":"advanced/core/#date","text":"from assembly import date","title":"date"},{"location":"advanced/core/#set_cookie","text":"from assembly import set_cookie","title":"set_cookie"},{"location":"advanced/core/#get_cookie","text":"from assembly import get_cookie","title":"get_cookie"},{"location":"advanced/core/#delete_cookie","text":"from assembly import delete_cookie","title":"delete_cookie"},{"location":"advanced/core/#url_for","text":"from assembly import url_for","title":"url_for"},{"location":"advanced/core/#redirect","text":"from assembly import redirect","title":"redirect"},{"location":"advanced/core/#decorators","text":"","title":"Decorators"},{"location":"advanced/core/#view_decorator","text":"from assembly import view_decorator","title":"view_decorator"},{"location":"advanced/core/#app_context","text":"from assembly import app_context","title":"app_context"},{"location":"advanced/csrf/","text":"Overview Assembly uses flask-seasurf to prevent cross-site request forgery (CSRF) Extension: flask-seasurf Usage Automatically all POST, UPDATE methods will require a CSRF token, unless explicitly exempt . (That's a good thing) This includes POST from FORMS or AJAX calls. HTML Forms In HTML, csrf_token() needs to be added for any POST forms. <input type='hidden' name=\"_csrf_token\" value=' {{ csrf_token () }} '> Example: <h1> Upload </h1> <form id= \"uploadbanner\" action= \"/upload/\" enctype= \"multipart/form-data\" method= \"post\" > <input type= 'hidden' name= \"_csrf_token\" value= ' {{ csrf_token () }} ' > <input id= \"fileupload\" name= \"file\" type= \"file\" /> <input type= \"submit\" value= \"Upload\" id= \"submit\" /> </form> Validation Implicitely CSRF gets validated if _csrf_token was part of the POST call. If CSRF fails to validate, it will throw a Forbidden/403 error. Validate CSRF To validate CSRF, use request.csrf . If CSRF fails to validate, it will throw a Forbidden/403 error. from assembly import Assembly , request class Index ( Assembly ): def post ( self ): if request . csrf . validate (): # everything is good here pass Exempt CSRF Assembly exposes @request.csrf.exempt to exclude a view from CSRF validation. from assembly import Assembly , request class Index ( Assembly ): def post ( self ): # this will require csrf @request.post @request.csrf.exempt def exempt_this ( self ): # this will not require CSFR In the example above, when POSTing to /post/ it will require the CSRF token, however POSTing to /exempt-this/ will not requires it. Configuration Set the configuration below in your config.py file. CSRF_COOKIE_NAME = \"_csrf_token\" CSRF_HEADER_NAME = \"X-CSRFToken\" CSRF_DISABLE CSRF_COOKIE_TIMEOUT CSRF_COOKIE_SECURE CSRF_COOKIE_HTTPONLY CSRF_COOKIE_DOMAIN CSRF_CHECK_REFERER SEASURF_INCLUDE_OR_EXEMPT_VIEWS","title":"CSFR"},{"location":"advanced/csrf/#overview","text":"Assembly uses flask-seasurf to prevent cross-site request forgery (CSRF) Extension: flask-seasurf","title":"Overview"},{"location":"advanced/csrf/#usage","text":"Automatically all POST, UPDATE methods will require a CSRF token, unless explicitly exempt . (That's a good thing) This includes POST from FORMS or AJAX calls.","title":"Usage"},{"location":"advanced/csrf/#html-forms","text":"In HTML, csrf_token() needs to be added for any POST forms. <input type='hidden' name=\"_csrf_token\" value=' {{ csrf_token () }} '> Example: <h1> Upload </h1> <form id= \"uploadbanner\" action= \"/upload/\" enctype= \"multipart/form-data\" method= \"post\" > <input type= 'hidden' name= \"_csrf_token\" value= ' {{ csrf_token () }} ' > <input id= \"fileupload\" name= \"file\" type= \"file\" /> <input type= \"submit\" value= \"Upload\" id= \"submit\" /> </form>","title":"HTML Forms"},{"location":"advanced/csrf/#validation","text":"Implicitely CSRF gets validated if _csrf_token was part of the POST call. If CSRF fails to validate, it will throw a Forbidden/403 error.","title":"Validation"},{"location":"advanced/csrf/#validate-csrf","text":"To validate CSRF, use request.csrf . If CSRF fails to validate, it will throw a Forbidden/403 error. from assembly import Assembly , request class Index ( Assembly ): def post ( self ): if request . csrf . validate (): # everything is good here pass","title":"Validate CSRF"},{"location":"advanced/csrf/#exempt-csrf","text":"Assembly exposes @request.csrf.exempt to exclude a view from CSRF validation. from assembly import Assembly , request class Index ( Assembly ): def post ( self ): # this will require csrf @request.post @request.csrf.exempt def exempt_this ( self ): # this will not require CSFR In the example above, when POSTing to /post/ it will require the CSRF token, however POSTing to /exempt-this/ will not requires it.","title":"Exempt CSRF"},{"location":"advanced/csrf/#configuration","text":"Set the configuration below in your config.py file. CSRF_COOKIE_NAME = \"_csrf_token\" CSRF_HEADER_NAME = \"X-CSRFToken\" CSRF_DISABLE CSRF_COOKIE_TIMEOUT CSRF_COOKIE_SECURE CSRF_COOKIE_HTTPONLY CSRF_COOKIE_DOMAIN CSRF_CHECK_REFERER SEASURF_INCLUDE_OR_EXEMPT_VIEWS","title":"Configuration"},{"location":"advanced/date/","text":"Overview Arrow is used as the date library in Assembly, an date is the alias available. Arrow helps you work with dates and times with fewer imports and a lot less code. Extension: Arrow Usage Import from assembly import date Usage from assembly import date date . get ( '2013-05-11T21:23:58.970460+07:00' ) #-> <Arrow [2013-05-11T21:23:58.970460+07:00]> utc = date . utcnow () #-> <Arrow [2013-05-11T21:23:58.970460+00:00]> utc = utc . shift ( hours =- 1 ) #-> <Arrow [2013-05-11T20:23:58.970460+00:00]> local = utc . to ( 'US/Pacific' ) #-> <Arrow [2013-05-11T13:23:58.970460-07:00]> local . timestamp #-> 1368303838 local . format () #-> '2013-05-11 13:23:58 -07:00' local . format ( 'YYYY-MM-DD HH:mm:ss ZZ' ) #-> '2013-05-11 13:23:58 -07:00' local . humanize () # 'an hour ago' or along with config from assembly import date , config local = utc . to ( config . get ( 'TIMEZONE' )) local . format ( config . get ( 'DATE_FORMAT.default' )) Supported Tokens Use the following tokens in parsing and formatting. Note that they\u2019re not the same as the tokens for strptime. View all supported tokens ie : local = utc . to ( ' US/Pacific ' ) local . format ( ' YYYY-MM-DD HH:mm:ss ' ) ** Year ** -- YYYY ( 2019 , 2020 ) -- YY ( 19 , 20 ) ** Month ** -- MMMM ( January , February ,... ) -- MMM ( Jan , Feb , ... ) -- MM ( 01 , 02 , ... ) -- M ( 1 , 2 , ... ) ** Dat of Year ** -- DDDD ( 001 , 002 , ..., 364 , 365 ) --- DDD ( 01 , 02 , 364 , 365 ) ** Day of Month ** -- DD ( 01 , 02 , ..., 30 , 31 ) -- D ( 1 , 2 ,..., 30 , 31 ) -- Do ( 1 st , 2 nd , ..., 30 th , 31 st ) ** Day of Week ** -- dddd ( Monday , Tuesday ) -- dd ( Mon , Tues ) -- d ( 1 , 2 , ..., 6 , 7 ) ** Hour ** -- HH ( 00 , 01 , ... 23 ) -- H ( 1 , 23 ) -- hh ( 01 , 02 , ..., 11 , 12 ) -- h ( 1 , 2 , ..., 11 , 12 ) ** AM / PM ** -- A ( AM , PM ) -- a ( am , pm ) ** Minute ** -- mm ( 00 , 01 , ..., 59 ) -- m ( 0 , 1 , ..., 59 ) ** Second ** -- ss ( 00 , 01 , ..., 59 ) -- s ( 0 , 1 , ..., 59 )","title":"Date"},{"location":"advanced/date/#overview","text":"Arrow is used as the date library in Assembly, an date is the alias available. Arrow helps you work with dates and times with fewer imports and a lot less code. Extension: Arrow","title":"Overview"},{"location":"advanced/date/#usage","text":"","title":"Usage"},{"location":"advanced/date/#import","text":"from assembly import date","title":"Import"},{"location":"advanced/date/#usage_1","text":"from assembly import date date . get ( '2013-05-11T21:23:58.970460+07:00' ) #-> <Arrow [2013-05-11T21:23:58.970460+07:00]> utc = date . utcnow () #-> <Arrow [2013-05-11T21:23:58.970460+00:00]> utc = utc . shift ( hours =- 1 ) #-> <Arrow [2013-05-11T20:23:58.970460+00:00]> local = utc . to ( 'US/Pacific' ) #-> <Arrow [2013-05-11T13:23:58.970460-07:00]> local . timestamp #-> 1368303838 local . format () #-> '2013-05-11 13:23:58 -07:00' local . format ( 'YYYY-MM-DD HH:mm:ss ZZ' ) #-> '2013-05-11 13:23:58 -07:00' local . humanize () # 'an hour ago' or along with config from assembly import date , config local = utc . to ( config . get ( 'TIMEZONE' )) local . format ( config . get ( 'DATE_FORMAT.default' ))","title":"Usage"},{"location":"advanced/date/#supported-tokens","text":"Use the following tokens in parsing and formatting. Note that they\u2019re not the same as the tokens for strptime. View all supported tokens ie : local = utc . to ( ' US/Pacific ' ) local . format ( ' YYYY-MM-DD HH:mm:ss ' ) ** Year ** -- YYYY ( 2019 , 2020 ) -- YY ( 19 , 20 ) ** Month ** -- MMMM ( January , February ,... ) -- MMM ( Jan , Feb , ... ) -- MM ( 01 , 02 , ... ) -- M ( 1 , 2 , ... ) ** Dat of Year ** -- DDDD ( 001 , 002 , ..., 364 , 365 ) --- DDD ( 01 , 02 , 364 , 365 ) ** Day of Month ** -- DD ( 01 , 02 , ..., 30 , 31 ) -- D ( 1 , 2 ,..., 30 , 31 ) -- Do ( 1 st , 2 nd , ..., 30 th , 31 st ) ** Day of Week ** -- dddd ( Monday , Tuesday ) -- dd ( Mon , Tues ) -- d ( 1 , 2 , ..., 6 , 7 ) ** Hour ** -- HH ( 00 , 01 , ... 23 ) -- H ( 1 , 23 ) -- hh ( 01 , 02 , ..., 11 , 12 ) -- h ( 1 , 2 , ..., 11 , 12 ) ** AM / PM ** -- A ( AM , PM ) -- a ( am , pm ) ** Minute ** -- mm ( 00 , 01 , ..., 59 ) -- m ( 0 , 1 , ..., 59 ) ** Second ** -- ss ( 00 , 01 , ..., 59 ) -- s ( 0 , 1 , ..., 59 )","title":"Supported Tokens"},{"location":"advanced/error-handling/","text":"Overview Assembly allows you to handle your errors beautifully. _error_handler A special method _error_handler can be added in your view class to capture any HTTPException. A template with the name error_handler.html will be used. Only one _error_handler can exist in the application. _error_handler will take precedence over the other error handlers. To use specific error handler, omit _error_handler instead use the _error_$errorCode for example _error_404 # error/__init__.py from assembly import Assembly , HTTPError class Index ( Assembly ): def _error_handler ( self , e ): return { \"e\" : e } Template: <!-- error/templates/Index/error_handler.html --> {% extends 'main/layouts/base.html' %} {% block title %} Error {{ e.code }} {% endblock %} {% block body %} <h1> Error: {{ e.code }} </h1> <h4> {{ e.description }} </h4> {% endblock %} _error_$errorCode Only one _error_handler can exist in the application. _error_handler will take precedence over the other error handlers. To use specific error handler, omit _error_handler instead use the _error_$errorCode for example _error_404 $errorCode is valid HTTP Error Code. Invalid code will throw an error A template with the name error_$errorCode.html will be used. # error/__init__.py from assembly import Assembly , HTTPError class Index ( Assembly ): def _error_404 ( self , e ): return { \"e\" : e } def _error_500 ( self , e ): return { \"e\" : e } Template: <!-- error/templates/Index/error_404.html --> {% extends 'main/layouts/base.html' %} {% block title %} Error {{ e.code }} {% endblock %} {% block body %} <h1> Error: {{ e.code }} </h1> <h4> {{ e.description }} </h4> {% endblock %} <!-- error/templates/Index/error_500.html --> {% extends 'main/layouts/base.html' %} {% block title %} Error {{ e.code }} {% endblock %} {% block body %} <h1> Error: {{ e.code }} </h1> <h4> {{ e.description }} </h4> {% endblock %} Error Method Usage from assembly import Assembly , HTTPError class Index ( Assembly ): def index ( self ): raise HTTPError . Unauthorized () def trigger_404 ( self ): raise HTTPError . NotFound () abort abort can also be used to trigger error from assembly import Assembly , HTTPError class Index ( Assembly ): def index ( self ): raise HTTPError . abort ( 401 ) def trigger_404 ( self ): raise HTTPError . abort ( 404 ) Available Methods BadRequest: 400 Unauthorized: 401 Forbidden: 403 NotFound: 404 MethodNotAllowed: 405 NotAcceptable: 406 RequestTimeout: 408 Conflict: 409 Gone: 410 LengthRequired: 411 PreconditionFailed: 412 RequestEntityTooLarge: 413 RequestURITooLarge: 414 UnsupportedMediaType: 415 RequestedRangeNotSatisfiable: 416 ExpectationFailed: 417 ImATeapot: 418 UnprocessableEntity: 422 Locked: 423 FailedDependency: 424 PreconditionRequired: 428 TooManyRequests: 429 RequestHeaderFieldsTooLarge: 431 UnavailableForLegalReasons: 451 InternalServerError: 500 NotImplemented: 501 BadGateway: 502 ServiceUnavailable: 503 GatewayTimeout: 504 HTTPVersionNotSupported: 505 ClientDisconnected SecurityError","title":"Error Handling"},{"location":"advanced/error-handling/#overview","text":"Assembly allows you to handle your errors beautifully.","title":"Overview"},{"location":"advanced/error-handling/#_error_handler","text":"A special method _error_handler can be added in your view class to capture any HTTPException. A template with the name error_handler.html will be used. Only one _error_handler can exist in the application. _error_handler will take precedence over the other error handlers. To use specific error handler, omit _error_handler instead use the _error_$errorCode for example _error_404 # error/__init__.py from assembly import Assembly , HTTPError class Index ( Assembly ): def _error_handler ( self , e ): return { \"e\" : e } Template: <!-- error/templates/Index/error_handler.html --> {% extends 'main/layouts/base.html' %} {% block title %} Error {{ e.code }} {% endblock %} {% block body %} <h1> Error: {{ e.code }} </h1> <h4> {{ e.description }} </h4> {% endblock %}","title":"_error_handler"},{"location":"advanced/error-handling/#_error95errorcode","text":"Only one _error_handler can exist in the application. _error_handler will take precedence over the other error handlers. To use specific error handler, omit _error_handler instead use the _error_$errorCode for example _error_404 $errorCode is valid HTTP Error Code. Invalid code will throw an error A template with the name error_$errorCode.html will be used. # error/__init__.py from assembly import Assembly , HTTPError class Index ( Assembly ): def _error_404 ( self , e ): return { \"e\" : e } def _error_500 ( self , e ): return { \"e\" : e } Template: <!-- error/templates/Index/error_404.html --> {% extends 'main/layouts/base.html' %} {% block title %} Error {{ e.code }} {% endblock %} {% block body %} <h1> Error: {{ e.code }} </h1> <h4> {{ e.description }} </h4> {% endblock %} <!-- error/templates/Index/error_500.html --> {% extends 'main/layouts/base.html' %} {% block title %} Error {{ e.code }} {% endblock %} {% block body %} <h1> Error: {{ e.code }} </h1> <h4> {{ e.description }} </h4> {% endblock %}","title":"_error_$errorCode"},{"location":"advanced/error-handling/#error-method-usage","text":"from assembly import Assembly , HTTPError class Index ( Assembly ): def index ( self ): raise HTTPError . Unauthorized () def trigger_404 ( self ): raise HTTPError . NotFound ()","title":"Error Method Usage"},{"location":"advanced/error-handling/#abort","text":"abort can also be used to trigger error from assembly import Assembly , HTTPError class Index ( Assembly ): def index ( self ): raise HTTPError . abort ( 401 ) def trigger_404 ( self ): raise HTTPError . abort ( 404 )","title":"abort"},{"location":"advanced/error-handling/#available-methods","text":"","title":"Available Methods"},{"location":"advanced/error-handling/#badrequest-400","text":"","title":"BadRequest: 400"},{"location":"advanced/error-handling/#unauthorized-401","text":"","title":"Unauthorized: 401"},{"location":"advanced/error-handling/#forbidden-403","text":"","title":"Forbidden: 403"},{"location":"advanced/error-handling/#notfound-404","text":"","title":"NotFound: 404"},{"location":"advanced/error-handling/#methodnotallowed-405","text":"","title":"MethodNotAllowed: 405"},{"location":"advanced/error-handling/#notacceptable-406","text":"","title":"NotAcceptable: 406"},{"location":"advanced/error-handling/#requesttimeout-408","text":"","title":"RequestTimeout: 408"},{"location":"advanced/error-handling/#conflict-409","text":"","title":"Conflict: 409"},{"location":"advanced/error-handling/#gone-410","text":"","title":"Gone: 410"},{"location":"advanced/error-handling/#lengthrequired-411","text":"","title":"LengthRequired: 411"},{"location":"advanced/error-handling/#preconditionfailed-412","text":"","title":"PreconditionFailed: 412"},{"location":"advanced/error-handling/#requestentitytoolarge-413","text":"","title":"RequestEntityTooLarge: 413"},{"location":"advanced/error-handling/#requesturitoolarge-414","text":"","title":"RequestURITooLarge: 414"},{"location":"advanced/error-handling/#unsupportedmediatype-415","text":"","title":"UnsupportedMediaType: 415"},{"location":"advanced/error-handling/#requestedrangenotsatisfiable-416","text":"","title":"RequestedRangeNotSatisfiable: 416"},{"location":"advanced/error-handling/#expectationfailed-417","text":"","title":"ExpectationFailed: 417"},{"location":"advanced/error-handling/#imateapot-418","text":"","title":"ImATeapot: 418"},{"location":"advanced/error-handling/#unprocessableentity-422","text":"","title":"UnprocessableEntity: 422"},{"location":"advanced/error-handling/#locked-423","text":"","title":"Locked: 423"},{"location":"advanced/error-handling/#faileddependency-424","text":"","title":"FailedDependency: 424"},{"location":"advanced/error-handling/#preconditionrequired-428","text":"","title":"PreconditionRequired: 428"},{"location":"advanced/error-handling/#toomanyrequests-429","text":"","title":"TooManyRequests: 429"},{"location":"advanced/error-handling/#requestheaderfieldstoolarge-431","text":"","title":"RequestHeaderFieldsTooLarge: 431"},{"location":"advanced/error-handling/#unavailableforlegalreasons-451","text":"","title":"UnavailableForLegalReasons: 451"},{"location":"advanced/error-handling/#internalservererror-500","text":"","title":"InternalServerError: 500"},{"location":"advanced/error-handling/#notimplemented-501","text":"","title":"NotImplemented: 501"},{"location":"advanced/error-handling/#badgateway-502","text":"","title":"BadGateway: 502"},{"location":"advanced/error-handling/#serviceunavailable-503","text":"","title":"ServiceUnavailable: 503"},{"location":"advanced/error-handling/#gatewaytimeout-504","text":"","title":"GatewayTimeout: 504"},{"location":"advanced/error-handling/#httpversionnotsupported-505","text":"","title":"HTTPVersionNotSupported: 505"},{"location":"advanced/error-handling/#clientdisconnected","text":"","title":"ClientDisconnected"},{"location":"advanced/error-handling/#securityerror","text":"","title":"SecurityError"},{"location":"advanced/flash/","text":"","title":"Flash"},{"location":"advanced/mail/","text":"Overview Assembly allows you to send email from your application using SMTP or AWS SES. Extension: Flask-Mail SES-Mailer Usage Set Sender In the config file, set the MAIL_SENDER and MAIL_REPLY_TO. # config . py #: MAIL_SENDER - The sender of the email by default #: For SES , this email must be authorized MAIL_SENDER = \" me@myemail.com \" #: MAIL_REPLY_TO #: The email to reply to by default MAIL_REPLY_TO = \" me@myemail.com \" Import from assembly import asm send_mail is a function in the asm module. asm.send_mail will be used to send the email Send Simple Email To send basic email from assembly import asm to = \"user@email.com\" subject = \"Welcome\" body = \"Welcome to our site\" asm . send_mail ( to = to , subject = subject , body = body ) Send Template Email Having a template like this... # welcome . txt { % block subject % } Welcome {{ name }} to our site { % endblock % } { % block body % } Dear {{ name }} this is the content of the message Thank you very much for your visiting us { % endblock % } Send email with vars from assembly import asm asm . send_mail ( to = \"x@y.com\" , template = \"welcome.txt\" , name = \"Mardix\" ) Signal The mail also emit a signal, which can be used to pre and post process information from assembly import asm @asm.send_mail.post def process_email_sent ( result , ** kwargs ): if result : print ( \"Email sent successfully!\" ) Templates You can have pre-made templates to send email. It's easier to customize, and instead of having messages all over the place, you can now have a central place to put the messages that will be sent. The template must be a Jinja template, containing at least the following blocks: subject body Example of a template Having a template file called welcome.txt , we will create two Jinja blocks: 'subject', 'body'. We can also use {{...}} to assign variables. # welcome . txt { % block subject % } Welcome {{ name }} to our site { % endblock % } { % block body % } Dear {{ name }} this is the content of the message Thank you very much for your visiting us { % endblock % } File Templates File base templates is supported. Place the templates in a directory. By default, Assembly places them in ./_data/emails-templates/ Place your templates files in there. The files name will be used to retrieve the template. inside of the config.py, # config . py MAIL_TEMPLATES_DIR = os . path . join ( DATA_DIR , \"mail-templates\" ) Structure of the templates directory / _data / email - templates | | _ welcome . txt | | _ lost - password . txt Dictionary based templates If you don't want to create files, you can dictionary based templates # config.py MAIL_TEMPLATES_DICT = { \"welcome.txt\": \"\"\" {% block subject %} I'm subject {% endblock %} {% block body %} How are you {{ name }} ? {% endblock %} \"\"\", \"lost-password.txt\": \"\"\" {% block subject %} Lost Password {% endblock %} {% block body %} Hello {{ name }} . Here's your new password: {{ new_password }} {% endblock %} \"\"\", } Send Email For either files or dictionary based templates: # welcome asm . send_mail ( to = \"x@y.com\" , template = \"welcome.txt\" , name = \"Mardix\" ) # lost - password asm . send_mail ( to = \"x@y.com\" , template = \"lost-password.txt\" , name = \"Mardix\" , new_password = \"mynewpassword\" ) Configuration # AWS SES # To use AWS SES to send email #: #: - To use the default AWS credentials ( AWS_ACCESS_KEY_ID , AWS_SECRET_ACCESS_KEY ) #: set MAIL_URI = \" ses:// \" #: * To use a different credential : #: set MAIL_URI = \" ses://{access_key}:{secret_key}@{region} \" #: #: *** comment out if you are using SMTP instead MAIL_URI = \" ses:// \" # SMTP #: If you are using SMTP , it will use Flask - Mail #: The uri for the smtp connection . It will use Flask - Mail #: format : smtp : // USERNAME : PASSWORD @ HOST : PORT #: with sll -> smtp + ssl : // USERNAME : PASSWORD @ HOST : PORT #: with ssl and tls -> smtp + ssl + tls : // USERNAME : PASSWORD @ HOST : PORT #: #: *** comment out if you are using SES instead # MAIL_URI = \" smtp+ssl://{username}:{password}@{host}:{port} \" \\ # . format ( username = \"\" , password = \"\" , host = \" smtp.gmail.com \" , port = 465 ) #: MAIL_SENDER - The sender of the email by default #: For SES , this email must be authorized MAIL_SENDER = APPLICATION_ADMIN_EMAIL #: MAIL_REPLY_TO #: The email to reply to by default MAIL_REPLY_TO = APPLICATION_ADMIN_EMAIL #: MAIL_TEMPLATE #: a directory that contains the email template or a dict MAIL_TEMPLATE = os . path . join ( DATA_DIR , \" mail-templates \" ) #: MAIL_TEMPLATE_CONTEXT #: a dict of all context to pass to the email by default MAIL_TEMPLATE_CONTEXT = { \" site_name \" : APPLICATION_NAME , \" site_url \" : APPLICATION_URL } API For the core functionalities of Flask-Mail or SES-Mailer, import the extension that was set from assembly import ext mail.mail is the object in the ext to use. For SES-Mailer from assembly import ext ext . mail . mail . send ( * args , ** kw ) ext . mail . mail . send_template ( * args , ** kw ) For Flask-Mail from assembly import ext ext . mail . mail . send_message ( * args , ** kw )","title":"Mail"},{"location":"advanced/mail/#overview","text":"Assembly allows you to send email from your application using SMTP or AWS SES. Extension: Flask-Mail SES-Mailer","title":"Overview"},{"location":"advanced/mail/#usage","text":"","title":"Usage"},{"location":"advanced/mail/#set-sender","text":"In the config file, set the MAIL_SENDER and MAIL_REPLY_TO. # config . py #: MAIL_SENDER - The sender of the email by default #: For SES , this email must be authorized MAIL_SENDER = \" me@myemail.com \" #: MAIL_REPLY_TO #: The email to reply to by default MAIL_REPLY_TO = \" me@myemail.com \"","title":"Set Sender"},{"location":"advanced/mail/#import","text":"from assembly import asm send_mail is a function in the asm module. asm.send_mail will be used to send the email","title":"Import"},{"location":"advanced/mail/#send-simple-email","text":"To send basic email from assembly import asm to = \"user@email.com\" subject = \"Welcome\" body = \"Welcome to our site\" asm . send_mail ( to = to , subject = subject , body = body )","title":"Send Simple Email"},{"location":"advanced/mail/#send-template-email","text":"Having a template like this... # welcome . txt { % block subject % } Welcome {{ name }} to our site { % endblock % } { % block body % } Dear {{ name }} this is the content of the message Thank you very much for your visiting us { % endblock % } Send email with vars from assembly import asm asm . send_mail ( to = \"x@y.com\" , template = \"welcome.txt\" , name = \"Mardix\" )","title":"Send Template Email"},{"location":"advanced/mail/#signal","text":"The mail also emit a signal, which can be used to pre and post process information from assembly import asm @asm.send_mail.post def process_email_sent ( result , ** kwargs ): if result : print ( \"Email sent successfully!\" )","title":"Signal"},{"location":"advanced/mail/#templates","text":"You can have pre-made templates to send email. It's easier to customize, and instead of having messages all over the place, you can now have a central place to put the messages that will be sent. The template must be a Jinja template, containing at least the following blocks: subject body","title":"Templates"},{"location":"advanced/mail/#example-of-a-template","text":"Having a template file called welcome.txt , we will create two Jinja blocks: 'subject', 'body'. We can also use {{...}} to assign variables. # welcome . txt { % block subject % } Welcome {{ name }} to our site { % endblock % } { % block body % } Dear {{ name }} this is the content of the message Thank you very much for your visiting us { % endblock % }","title":"Example of a template"},{"location":"advanced/mail/#file-templates","text":"File base templates is supported. Place the templates in a directory. By default, Assembly places them in ./_data/emails-templates/ Place your templates files in there. The files name will be used to retrieve the template. inside of the config.py, # config . py MAIL_TEMPLATES_DIR = os . path . join ( DATA_DIR , \"mail-templates\" ) Structure of the templates directory / _data / email - templates | | _ welcome . txt | | _ lost - password . txt","title":"File Templates"},{"location":"advanced/mail/#dictionary-based-templates","text":"If you don't want to create files, you can dictionary based templates # config.py MAIL_TEMPLATES_DICT = { \"welcome.txt\": \"\"\" {% block subject %} I'm subject {% endblock %} {% block body %} How are you {{ name }} ? {% endblock %} \"\"\", \"lost-password.txt\": \"\"\" {% block subject %} Lost Password {% endblock %} {% block body %} Hello {{ name }} . Here's your new password: {{ new_password }} {% endblock %} \"\"\", }","title":"Dictionary based templates"},{"location":"advanced/mail/#send-email","text":"For either files or dictionary based templates: # welcome asm . send_mail ( to = \"x@y.com\" , template = \"welcome.txt\" , name = \"Mardix\" ) # lost - password asm . send_mail ( to = \"x@y.com\" , template = \"lost-password.txt\" , name = \"Mardix\" , new_password = \"mynewpassword\" )","title":"Send Email"},{"location":"advanced/mail/#configuration","text":"# AWS SES # To use AWS SES to send email #: #: - To use the default AWS credentials ( AWS_ACCESS_KEY_ID , AWS_SECRET_ACCESS_KEY ) #: set MAIL_URI = \" ses:// \" #: * To use a different credential : #: set MAIL_URI = \" ses://{access_key}:{secret_key}@{region} \" #: #: *** comment out if you are using SMTP instead MAIL_URI = \" ses:// \" # SMTP #: If you are using SMTP , it will use Flask - Mail #: The uri for the smtp connection . It will use Flask - Mail #: format : smtp : // USERNAME : PASSWORD @ HOST : PORT #: with sll -> smtp + ssl : // USERNAME : PASSWORD @ HOST : PORT #: with ssl and tls -> smtp + ssl + tls : // USERNAME : PASSWORD @ HOST : PORT #: #: *** comment out if you are using SES instead # MAIL_URI = \" smtp+ssl://{username}:{password}@{host}:{port} \" \\ # . format ( username = \"\" , password = \"\" , host = \" smtp.gmail.com \" , port = 465 ) #: MAIL_SENDER - The sender of the email by default #: For SES , this email must be authorized MAIL_SENDER = APPLICATION_ADMIN_EMAIL #: MAIL_REPLY_TO #: The email to reply to by default MAIL_REPLY_TO = APPLICATION_ADMIN_EMAIL #: MAIL_TEMPLATE #: a directory that contains the email template or a dict MAIL_TEMPLATE = os . path . join ( DATA_DIR , \" mail-templates \" ) #: MAIL_TEMPLATE_CONTEXT #: a dict of all context to pass to the email by default MAIL_TEMPLATE_CONTEXT = { \" site_name \" : APPLICATION_NAME , \" site_url \" : APPLICATION_URL }","title":"Configuration"},{"location":"advanced/mail/#api","text":"For the core functionalities of Flask-Mail or SES-Mailer, import the extension that was set from assembly import ext mail.mail is the object in the ext to use.","title":"API"},{"location":"advanced/mail/#for-ses-mailer","text":"from assembly import ext ext . mail . mail . send ( * args , ** kw ) ext . mail . mail . send_template ( * args , ** kw )","title":"For SES-Mailer"},{"location":"advanced/mail/#for-flask-mail","text":"from assembly import ext ext . mail . mail . send_message ( * args , ** kw )","title":"For Flask-Mail"},{"location":"advanced/pagination/","text":"Overview Assembly uses the Paginator to paginate iterable items Extension: Paginator Usage Paginate Models Paginate models from assembly import Assembly , models , request class Index ( Assembly ): def posts ( self ): per_page = 10 page = int ( request . args . get ( \"page\" , 1 )) posts = models . Posts . query () posts = posts . paginate ( page = page , per_page = per_page ) return { \"posts\" : posts } Paginate List To paginate a list of items from assembly import Assembly , request from paginator import Paginator class Index ( Assembly ): def posts ( self ): per_page = 10 page = int ( request . args . get ( \"page\" , 1 )) items = range ( 1 , 1000 ) items = Paginator ( items , page = page , per_page = per_page ) return { \"items\" : [ i for i in items ] } API Paginator(query, page=1, per_page=10, total=None, padding=0, callback=None, static_query=False) :param query : Iterable to paginate . Can be a query object , list or any iterables :param page : current page :param per_page : max number of items per page :param total : Max number of items . If not provided , it will use the query to count :param padding : Number of elements of the next page to show :param callback : a function to callback on each item being iterated . :param static_query : bool - When True it will return the query as is , without slicing / limit . Usally when using the paginator to just create the pagination . :return : Properties total_pages has_prev has_next next_page_number prev_page_number pages_range items pages (iterables) Create Jinja Macro {#: PAGINATION -------------------------------------------------------------- #} {# : paginator : iterator : endpoint : : prev : Text for previous button : next : Text for Next button : class_ : A class name for pagination if customed . If you are extending the class best to add the original class and your custom class ie : ' pagination my_custom_pagination ' or ' pager my_custom_page ' : pager : If true it will show a pager instead of numbered pagination #} { % macro pagination ( paginator , endpoint = None , prev = \"\" , next = \"\" , class_ = None , pager = False ) % } { % if not endpoint % } { % set endpoint = request . endpoint % } { % endif % } { % if \" page \" in kwargs % } { % set _ = kwargs . pop ( \" page \" ) % } { % endif % } { % if not class_ % } { % set class_ = \" pagination \" % } { % if pager % } { % set class_ = \" pager \" % } { % endif % } { % endif % } { % set _prev_btn = \" <span aria-hidden='true'>&larr;</span> %s \" % prev % } { % set _next_btn = \" <span aria-hidden='true'>&rarr;</span> %s \" % next % } < nav > < ul class = \" {{ class_ }} \" > { %- if paginator . has_prev % } < li class = \" previous \" > < a href = \" {{ url_for(endpoint, page=paginator.prev_page_number, **kwargs) }} \" > {{ _prev_btn | safe }} </ a > </ li > { % else % } < li class = \" disabled previous \" > < a href = \" # \" > {{ _prev_btn | safe }} </ a > </ li > { %- endif % } { % if not pager % } { %- for page in paginator . iter_pages () % } { % if page % } { % if page != paginator . page % } < li >< a href = \" {{ url_for(endpoint, page=page, **kwargs) }} \" rel = \" me \" > {{ page }} </ a ></ li > { % else % } < li class = \" active \" >< span > {{ page }} </ span ></ li > { % endif % } { % else % } < li >< span class = ellipsis > \u2026 </ span ></ li > { % endif % } { %- endfor % } { % endif % } { %- if paginator . has_next % } < li class = \" next \" > < a href = \" {{ url_for(endpoint, page=paginator.next_page_number, **kwargs) }} \" > {{ _next_btn | safe }} </ a > </ li > { % else % } < li class = \" disabled next \" > < a href = \" # \" > {{ _next_btn | safe }} </ a > </ li > { %- endif % } </ ul > </ nav > { % endmacro % }","title":"Pagination"},{"location":"advanced/pagination/#overview","text":"Assembly uses the Paginator to paginate iterable items Extension: Paginator","title":"Overview"},{"location":"advanced/pagination/#usage","text":"","title":"Usage"},{"location":"advanced/pagination/#paginate-models","text":"Paginate models from assembly import Assembly , models , request class Index ( Assembly ): def posts ( self ): per_page = 10 page = int ( request . args . get ( \"page\" , 1 )) posts = models . Posts . query () posts = posts . paginate ( page = page , per_page = per_page ) return { \"posts\" : posts }","title":"Paginate Models"},{"location":"advanced/pagination/#paginate-list","text":"To paginate a list of items from assembly import Assembly , request from paginator import Paginator class Index ( Assembly ): def posts ( self ): per_page = 10 page = int ( request . args . get ( \"page\" , 1 )) items = range ( 1 , 1000 ) items = Paginator ( items , page = page , per_page = per_page ) return { \"items\" : [ i for i in items ] }","title":"Paginate List"},{"location":"advanced/pagination/#api","text":"Paginator(query, page=1, per_page=10, total=None, padding=0, callback=None, static_query=False) :param query : Iterable to paginate . Can be a query object , list or any iterables :param page : current page :param per_page : max number of items per page :param total : Max number of items . If not provided , it will use the query to count :param padding : Number of elements of the next page to show :param callback : a function to callback on each item being iterated . :param static_query : bool - When True it will return the query as is , without slicing / limit . Usally when using the paginator to just create the pagination . :return :","title":"API"},{"location":"advanced/pagination/#properties","text":"total_pages has_prev has_next next_page_number prev_page_number pages_range items pages (iterables)","title":"Properties"},{"location":"advanced/pagination/#create-jinja-macro","text":"{#: PAGINATION -------------------------------------------------------------- #} {# : paginator : iterator : endpoint : : prev : Text for previous button : next : Text for Next button : class_ : A class name for pagination if customed . If you are extending the class best to add the original class and your custom class ie : ' pagination my_custom_pagination ' or ' pager my_custom_page ' : pager : If true it will show a pager instead of numbered pagination #} { % macro pagination ( paginator , endpoint = None , prev = \"\" , next = \"\" , class_ = None , pager = False ) % } { % if not endpoint % } { % set endpoint = request . endpoint % } { % endif % } { % if \" page \" in kwargs % } { % set _ = kwargs . pop ( \" page \" ) % } { % endif % } { % if not class_ % } { % set class_ = \" pagination \" % } { % if pager % } { % set class_ = \" pager \" % } { % endif % } { % endif % } { % set _prev_btn = \" <span aria-hidden='true'>&larr;</span> %s \" % prev % } { % set _next_btn = \" <span aria-hidden='true'>&rarr;</span> %s \" % next % } < nav > < ul class = \" {{ class_ }} \" > { %- if paginator . has_prev % } < li class = \" previous \" > < a href = \" {{ url_for(endpoint, page=paginator.prev_page_number, **kwargs) }} \" > {{ _prev_btn | safe }} </ a > </ li > { % else % } < li class = \" disabled previous \" > < a href = \" # \" > {{ _prev_btn | safe }} </ a > </ li > { %- endif % } { % if not pager % } { %- for page in paginator . iter_pages () % } { % if page % } { % if page != paginator . page % } < li >< a href = \" {{ url_for(endpoint, page=page, **kwargs) }} \" rel = \" me \" > {{ page }} </ a ></ li > { % else % } < li class = \" active \" >< span > {{ page }} </ span ></ li > { % endif % } { % else % } < li >< span class = ellipsis > \u2026 </ span ></ li > { % endif % } { %- endfor % } { % endif % } { %- if paginator . has_next % } < li class = \" next \" > < a href = \" {{ url_for(endpoint, page=paginator.next_page_number, **kwargs) }} \" > {{ _next_btn | safe }} </ a > </ li > { % else % } < li class = \" disabled next \" > < a href = \" # \" > {{ _next_btn | safe }} </ a > </ li > { %- endif % } </ ul > </ nav > { % endmacro % }","title":"Create Jinja Macro"},{"location":"advanced/redirect/","text":"Overview Redirect is a Proxy to Flask redirct. Redirect helps you redirect to different enpoint using the method name via 'self' or the class itself. Assembly knows what to do. also allows inter within Usage from assembly import Assembly , redirect class Index ( Assembly ): def about_us ( self ): return \"This is about us\" # redirect to 'about_us' method # redirect by providing the method name with 'self' def redirect_me ( self ): return redirect ( self . about_us ) Redirect by Class name from assembly import Assembly , redirect class Index ( Assembly ): # redirects a diffrent class, no need to know the endpoint def redirect_me ( self ): return redirect ( Blog . all_posts ) class Blog ( Assembly ): def all_posts ( self ): return Redirect with other Views For View classes that are not in the same file, you can redirect by using the views # main/__init__.py from assembly import Assembly , redirect , views class Index ( Assembly ): # redirects a different class, no need to know the endpoint def redirect_me ( self ): return redirect ( views . admin . Index . login ) # admin/__init__.py from assembly import Assembly , request @request.route ( \"/admin/\" ) class Index ( Assembly ): def login ( self ): return","title":"Redirect"},{"location":"advanced/redirect/#overview","text":"Redirect is a Proxy to Flask redirct. Redirect helps you redirect to different enpoint using the method name via 'self' or the class itself. Assembly knows what to do. also allows inter within","title":"Overview"},{"location":"advanced/redirect/#usage","text":"from assembly import Assembly , redirect class Index ( Assembly ): def about_us ( self ): return \"This is about us\" # redirect to 'about_us' method # redirect by providing the method name with 'self' def redirect_me ( self ): return redirect ( self . about_us )","title":"Usage"},{"location":"advanced/redirect/#redirect-by-class-name","text":"from assembly import Assembly , redirect class Index ( Assembly ): # redirects a diffrent class, no need to know the endpoint def redirect_me ( self ): return redirect ( Blog . all_posts ) class Blog ( Assembly ): def all_posts ( self ): return","title":"Redirect by Class name"},{"location":"advanced/redirect/#redirect-with-other-views","text":"For View classes that are not in the same file, you can redirect by using the views # main/__init__.py from assembly import Assembly , redirect , views class Index ( Assembly ): # redirects a different class, no need to know the endpoint def redirect_me ( self ): return redirect ( views . admin . Index . login ) # admin/__init__.py from assembly import Assembly , request @request.route ( \"/admin/\" ) class Index ( Assembly ): def login ( self ): return","title":"Redirect with other Views"},{"location":"advanced/request/","text":"Overview Request is a Proxy to Flask request with extra functionalities. For example it adds route decorator, cors decorator, etc. Usage Import from assembly import request @route class Index ( Assembly ) : # responds to -> / hello - world / @ request . route ( \" hello-world \" ) def index ( self ) : return @post Restrict a method to only accepts POST request. class Index ( Assembly ) : @ request . post def index ( self ) : return @get Restrict a method to only accepts GET request. class Index ( Assembly ) : @ request . get def index ( self ) : return @post_get Restrict a method to only accepts POST and GET request. class Index ( Assembly ) : @ request . post_get def index ( self ) : return @all Restrict a method to only accepts all requests (POST, GET, PUT, DELETE, UPDATE, OPTIONS). class Index ( Assembly ) : @ request . all def index ( self ) : return @put Restrict a method to only accepts PUT request. @delete Restrict a method to only accepts DELETE request. @cors Make an endpoint CORS. class Index ( Assembly ) : @ request . cors def index ( self ) : return @csrf.exempt To exempt CSRF on this endpoint. class Index ( Assembly ) : @ request . post @ request . csrf . exempt def index ( self ) : return get_auth_bearer Get the authorization bearer, ie: JWT. class Index ( Assembly ) : def index ( self ) : auth_bearer = request . get_auth_bearer () return IS_GET Test if a request is GET. Usually if one endpoint accepts multiple method class Index ( Assembly ) : @ request . post @ request . get def index ( self ) : if request . IS_GET : # do something return IS_POST Test if a request is POST. Usually if one endpoint accepts multiple method class Index ( Assembly ) : @ request . post @ request . get def index ( self ) : if request . IS_POST : # do something return IS_PUT Test if a request is PUT. Usually if one endpoint accepts multiple method IS_DELETE Test if a request is DELETE. Usually if one endpoint accepts multiple method args request.args.get lets you get the query vars # http : // 127 . 0 . 0 . 1 /? name = Assembly request . args . get ( 'name' ) form request.form.get lets you get the data that was sent in a post form getlist request.form.getlist returns a list of all the items with the same name that was posted in a form. # HTML < input type = 'checkbox' name = 'options' value = 'apple' > < input type = 'checkbox' name = 'options' value = 'orange' > < input type = 'checkbox' name = 'options' value = 'grapes' > # options = request . form . getlist ( \"options\" ) files.get request.files.get allow you to retrieve a file that was uploaded # HTML < input type = file name = \"file\" > # py file = request . files . get ( \"file\" ) files.getlist request.files.getlist allow you to retrieve multiple files uploaded with the same name # HTML < input type = file name = \"file\" > < input type = file name = \"file\" > < input type = file name = \"file\" > # py files = request . files . getlist ( 'file' )","title":"Request"},{"location":"advanced/request/#overview","text":"Request is a Proxy to Flask request with extra functionalities. For example it adds route decorator, cors decorator, etc.","title":"Overview"},{"location":"advanced/request/#usage","text":"Import from assembly import request","title":"Usage"},{"location":"advanced/request/#route","text":"class Index ( Assembly ) : # responds to -> / hello - world / @ request . route ( \" hello-world \" ) def index ( self ) : return","title":"@route"},{"location":"advanced/request/#post","text":"Restrict a method to only accepts POST request. class Index ( Assembly ) : @ request . post def index ( self ) : return","title":"@post"},{"location":"advanced/request/#get","text":"Restrict a method to only accepts GET request. class Index ( Assembly ) : @ request . get def index ( self ) : return","title":"@get"},{"location":"advanced/request/#post_get","text":"Restrict a method to only accepts POST and GET request. class Index ( Assembly ) : @ request . post_get def index ( self ) : return","title":"@post_get"},{"location":"advanced/request/#all","text":"Restrict a method to only accepts all requests (POST, GET, PUT, DELETE, UPDATE, OPTIONS). class Index ( Assembly ) : @ request . all def index ( self ) : return","title":"@all"},{"location":"advanced/request/#put","text":"Restrict a method to only accepts PUT request.","title":"@put"},{"location":"advanced/request/#delete","text":"Restrict a method to only accepts DELETE request.","title":"@delete"},{"location":"advanced/request/#cors","text":"Make an endpoint CORS. class Index ( Assembly ) : @ request . cors def index ( self ) : return","title":"@cors"},{"location":"advanced/request/#csrfexempt","text":"To exempt CSRF on this endpoint. class Index ( Assembly ) : @ request . post @ request . csrf . exempt def index ( self ) : return","title":"@csrf.exempt"},{"location":"advanced/request/#get_auth_bearer","text":"Get the authorization bearer, ie: JWT. class Index ( Assembly ) : def index ( self ) : auth_bearer = request . get_auth_bearer () return","title":"get_auth_bearer"},{"location":"advanced/request/#is_get","text":"Test if a request is GET. Usually if one endpoint accepts multiple method class Index ( Assembly ) : @ request . post @ request . get def index ( self ) : if request . IS_GET : # do something return","title":"IS_GET"},{"location":"advanced/request/#is_post","text":"Test if a request is POST. Usually if one endpoint accepts multiple method class Index ( Assembly ) : @ request . post @ request . get def index ( self ) : if request . IS_POST : # do something return","title":"IS_POST"},{"location":"advanced/request/#is_put","text":"Test if a request is PUT. Usually if one endpoint accepts multiple method","title":"IS_PUT"},{"location":"advanced/request/#is_delete","text":"Test if a request is DELETE. Usually if one endpoint accepts multiple method","title":"IS_DELETE"},{"location":"advanced/request/#args","text":"request.args.get lets you get the query vars # http : // 127 . 0 . 0 . 1 /? name = Assembly request . args . get ( 'name' )","title":"args"},{"location":"advanced/request/#form","text":"request.form.get lets you get the data that was sent in a post form","title":"form"},{"location":"advanced/request/#getlist","text":"request.form.getlist returns a list of all the items with the same name that was posted in a form. # HTML < input type = 'checkbox' name = 'options' value = 'apple' > < input type = 'checkbox' name = 'options' value = 'orange' > < input type = 'checkbox' name = 'options' value = 'grapes' > # options = request . form . getlist ( \"options\" )","title":"getlist"},{"location":"advanced/request/#filesget","text":"request.files.get allow you to retrieve a file that was uploaded # HTML < input type = file name = \"file\" > # py file = request . files . get ( \"file\" )","title":"files.get"},{"location":"advanced/request/#filesgetlist","text":"request.files.getlist allow you to retrieve multiple files uploaded with the same name # HTML < input type = file name = \"file\" > < input type = file name = \"file\" > < input type = file name = \"file\" > # py files = request . files . getlist ( 'file' )","title":"files.getlist"},{"location":"advanced/response/","text":"Overview By default, Assembly will attempt to match a template with the view. Sometimes you may want to return JSON or cache the response. The response module provides some decorators to help with some response functionalities. Usage from assembly import response @json Turn a response dict into a JSON class Index ( Assembly ) : @ response . json def api ( self ) : return { \" name \" : \" Assembly \" } @cache Cache the response class Index ( Assembly ) : @ response . json @ response . cache ( 10 ) def api ( self ) : return { \" name \" : \" Assembly \" } @xml Turn a response dict into an XML class Index ( Assembly ) : @ response . xml def api ( self ) : return { \" name \" : \" Assembly \" } @jsonp @template Change the template that would be used by default to another one class Index ( Assembly ) : @ response . template ( \" myOtherPackage/Index/api.html \" ) def api ( self ) : return { \" name \" : \" Assembly \" } @headers Add additional headers in the response class Index ( Assembly ) : @ response . headers ( { \" X-COMMON \" : \" something.2.4 \" } ) def api ( self ) : return { \" name \" : \" Assembly \" } @noindex Add the no-index in the headers, hopefully, so search engines don't index the endpoint. class Index ( Assembly ) : @ response . noindex def api ( self ) : return { \" name \" : \" Assembly \" }","title":"Response"},{"location":"advanced/response/#overview","text":"By default, Assembly will attempt to match a template with the view. Sometimes you may want to return JSON or cache the response. The response module provides some decorators to help with some response functionalities.","title":"Overview"},{"location":"advanced/response/#usage","text":"from assembly import response","title":"Usage"},{"location":"advanced/response/#json","text":"Turn a response dict into a JSON class Index ( Assembly ) : @ response . json def api ( self ) : return { \" name \" : \" Assembly \" }","title":"@json"},{"location":"advanced/response/#cache","text":"Cache the response class Index ( Assembly ) : @ response . json @ response . cache ( 10 ) def api ( self ) : return { \" name \" : \" Assembly \" }","title":"@cache"},{"location":"advanced/response/#xml","text":"Turn a response dict into an XML class Index ( Assembly ) : @ response . xml def api ( self ) : return { \" name \" : \" Assembly \" }","title":"@xml"},{"location":"advanced/response/#jsonp","text":"","title":"@jsonp"},{"location":"advanced/response/#template","text":"Change the template that would be used by default to another one class Index ( Assembly ) : @ response . template ( \" myOtherPackage/Index/api.html \" ) def api ( self ) : return { \" name \" : \" Assembly \" }","title":"@template"},{"location":"advanced/response/#headers","text":"Add additional headers in the response class Index ( Assembly ) : @ response . headers ( { \" X-COMMON \" : \" something.2.4 \" } ) def api ( self ) : return { \" name \" : \" Assembly \" }","title":"@headers"},{"location":"advanced/response/#noindex","text":"Add the no-index in the headers, hopefully, so search engines don't index the endpoint. class Index ( Assembly ) : @ response . noindex def api ( self ) : return { \" name \" : \" Assembly \" }","title":"@noindex"},{"location":"advanced/sessions/","text":"from assembly import session","title":"Sessions"},{"location":"advanced/signals/","text":"Overview Signals help you decouple applications by sending notifications when actions occur elsewhere in the appliation. In short, signals allow certain senders to notify subscribers that something happened. Assembly uses Blinker to provide a fast dispatching system that allows any number of interested parties to subscribe to events, or \u201csignals\u201d. Extension: Blinker Usage Import from assembly import signal Create a signal Import and use the @signal decorator on the function to send signal from. It will add a @pre and @post decorators on that function to be used by other function that will listens it. Whenever the function with the @signal get executed, all functions with @pre and @post will be executed before and after the @signal function is executed repectively. from assembly import signal @signal def hello_world ( name ): return \"Hello World %s \" % s Listens to a signal Now hello_world has @hello_world.pre and @hello_world.post . These decorators can attached to functions. @ hello_world . pre def before_hello_world ( * a , ** kw ) : \"\"\" This will be executed before \"\"\" @ hello_world . post def after_hello_world ( result , * kw ) : \"\"\" This will be executed after \"\"\" if result : print ( result ) @ hello_world . post def after_another_hello_world ( result , * kw ) : \"\"\" This will be executed after \"\"\" if result : print ( result ) Full Example Now we can run the functions and our signals will be executed from assembly import signal # Emit the signal @signal def hello_world ( name ): return \"Hello World %s \" % s # Listeners @hello_world.pre def before_hello_world ( * a , ** kw ): \"\"\"This will be executed before\"\"\" @hello_world.post def after_hello_world ( result , * kw ): \"\"\"This will be executed after\"\"\" if result : print ( result ) @hello_world.post def after_another_hello_world ( result , * kw ): \"\"\"This will be executed after\"\"\" if result : print ( result ) hello_world ( 'Assembly' ) hello_world ( 'Mardix' ) API @signal @pre Functions with @pre will be executed before the signaled functions is executed. The function receiving the signal, must have 1 args: - * a - ** kwargs : args : * a , kwargs : ** kw , name : the name of the signal , signal : the signal ' s instance Example @myfn . pre def post_action ( * a , ** kw ) : pass @post Functions with @post will be executed after the signaled functions is finished. The function receiving the signal, must have 2 args: - result : that 's the result sent from the signal - **kwargs: args: *a, kwargs: **kw, name: the name of the signal, signal: the signal' s instance Example @ myfn . post def post_action ( result , ** kw ) : if result : print ( \" Done! \" ) @pre_ and @post_ To fully utilize Blinker functionalities, use post_ and pre_ , for example @do_something.post_.connect , @do_something.pre_.connect","title":"Signals"},{"location":"advanced/signals/#overview","text":"Signals help you decouple applications by sending notifications when actions occur elsewhere in the appliation. In short, signals allow certain senders to notify subscribers that something happened. Assembly uses Blinker to provide a fast dispatching system that allows any number of interested parties to subscribe to events, or \u201csignals\u201d. Extension: Blinker","title":"Overview"},{"location":"advanced/signals/#usage","text":"","title":"Usage"},{"location":"advanced/signals/#import","text":"from assembly import signal","title":"Import"},{"location":"advanced/signals/#create-a-signal","text":"Import and use the @signal decorator on the function to send signal from. It will add a @pre and @post decorators on that function to be used by other function that will listens it. Whenever the function with the @signal get executed, all functions with @pre and @post will be executed before and after the @signal function is executed repectively. from assembly import signal @signal def hello_world ( name ): return \"Hello World %s \" % s","title":"Create a signal"},{"location":"advanced/signals/#listens-to-a-signal","text":"Now hello_world has @hello_world.pre and @hello_world.post . These decorators can attached to functions. @ hello_world . pre def before_hello_world ( * a , ** kw ) : \"\"\" This will be executed before \"\"\" @ hello_world . post def after_hello_world ( result , * kw ) : \"\"\" This will be executed after \"\"\" if result : print ( result ) @ hello_world . post def after_another_hello_world ( result , * kw ) : \"\"\" This will be executed after \"\"\" if result : print ( result )","title":"Listens to a signal"},{"location":"advanced/signals/#full-example","text":"Now we can run the functions and our signals will be executed from assembly import signal # Emit the signal @signal def hello_world ( name ): return \"Hello World %s \" % s # Listeners @hello_world.pre def before_hello_world ( * a , ** kw ): \"\"\"This will be executed before\"\"\" @hello_world.post def after_hello_world ( result , * kw ): \"\"\"This will be executed after\"\"\" if result : print ( result ) @hello_world.post def after_another_hello_world ( result , * kw ): \"\"\"This will be executed after\"\"\" if result : print ( result ) hello_world ( 'Assembly' ) hello_world ( 'Mardix' )","title":"Full Example"},{"location":"advanced/signals/#api","text":"","title":"API"},{"location":"advanced/signals/#signal","text":"","title":"@signal"},{"location":"advanced/signals/#pre","text":"Functions with @pre will be executed before the signaled functions is executed. The function receiving the signal, must have 1 args: - * a - ** kwargs : args : * a , kwargs : ** kw , name : the name of the signal , signal : the signal ' s instance Example @myfn . pre def post_action ( * a , ** kw ) : pass","title":"@pre"},{"location":"advanced/signals/#post","text":"Functions with @post will be executed after the signaled functions is finished. The function receiving the signal, must have 2 args: - result : that 's the result sent from the signal - **kwargs: args: *a, kwargs: **kw, name: the name of the signal, signal: the signal' s instance Example @ myfn . post def post_action ( result , ** kw ) : if result : print ( \" Done! \" )","title":"@post"},{"location":"advanced/signals/#pre_-and-post_","text":"To fully utilize Blinker functionalities, use post_ and pre_ , for example @do_something.post_.connect , @do_something.pre_.connect","title":"@pre_ and @post_"},{"location":"advanced/storage/","text":"Overview Aseembly uses Flask-Cloudy to let you access, upload, download, save and delete files on cloud storage providers such as: AWS S3, Google Storage, Microsoft Azure, Rackspace Cloudfiles, and even Local file system. Extension: flask-cloudy Usage from assembly import asm get_file , upload_file , download_file , delete_file are functions in the asm module. Get file asm.get_file will return a Storage Object. from assembly import asm myfile = asm . get_file ( \"hello.txt\" ) myfile . name # return The file name myfile . size # returns file size myfile . full_url # the full url of the file Upload file asm.upload_file to save or upload a file in the container Example of file upload # main/__init__.py from assembly import Assembly , asm , request , redirect class Index ( Assembly ): def index ( self ): return @request.post def upload ( self ): file = request . files . get ( \"file\" ) if file : profile_image = asm . upload_file ( file , name = utils . gen_uuid (), prefix = \"img.\" , public = True , extensions = [ \"jpg\" , \"jpeg\" , \"png\" , \"gif\" ]) return redirect ( self . upload_success ) def upload_success ( self ): return \"Upload successful!\" Template <!-- main/templates/Index/index.html --> {% extends 'main/layouts/base.html' %} {% block title %} Upload {% endblock %} {% block body %} <h1> Upload </h1> <form id= \"uploadbanner\" action= \"/upload/\" enctype= \"multipart/form-data\" method= \"post\" > <input type= 'hidden' name= \"_csrf_token\" value= ' {{ csrf_token () }} ' > <input id= \"fileupload\" name= \"file\" type= \"file\" /> <input type= \"submit\" value= \"Upload\" id= \"submit\" /> </form> {% endblock %} Note : Since this will call a POST, we also add the CSRF token in the form <input type='hidden' name=\"_csrf_token\" value=' {{ csrf_token () }} '> Signal asm.upload_file emits a signal to be used from assembly import asm @asm.upload_file.post def file_uploaded ( result , ** kw ): if result : print ( \"File uploaded successfully!\" ) Download File asm.download_file to download a file to the user. You will need to redirect to that path. from assembly import Assembly , asm , redirect class Index ( Assembly ): def dowload ( self ): filename = \"hello.txt\" name = \"new-name-hello\" url = asm . download_file ( filename , name = name , timeout = 60 ) return redirect ( url ) Signal asm.download_file emits a signal to be used from assembly import asm @asm.download_file.post def file_downloaded ( result , ** kw ): if result : print ( \"File uploaded successfully!\" ) Delete File asm.delete_file deletes a file from storage from assembly import asm asm . delete_file ( \"hello.txt\" ) Signal asm.delete_file emits a signal to be used from assembly import asm @asm.delete_file.post def file_deleted ( result , ** kw ): if result : print ( \"File deleted successfully!\" ) Config # config . py #: STORAGE_PROVIDER : # The provider to use . By default it ' s ' LOCAL ' . # You can use : # LOCAL , S3 , GOOGLE_STORAGE , AZURE_BLOBS , CLOUDFILES STORAGE_PROVIDER = \" LOCAL \" #: STORAGE_KEY # The storage key . Leave it blank if PROVIDER is LOCAL STORAGE_KEY = AWS_ACCESS_KEY_ID #: STORAGE_SECRET #: The storage secret key . Leave it blank if PROVIDER is LOCAL STORAGE_SECRET = AWS_SECRET_ACCESS_KEY #: STORAGE_REGION_NAME #: The region for the storage . Leave it blank if PROVIDER is LOCAL STORAGE_REGION_NAME = AWS_REGION_NAME #: STORAGE_CONTAINER #: The Bucket name ( for S3 , Google storage , Azure , cloudfile ) #: or the directory name ( LOCAL ) to access STORAGE_CONTAINER = os . path . join ( DATA_DIR , \" uploads \" ) #: STORAGE_SERVER #: Bool , to serve local file STORAGE_SERVER = True #: STORAGE_SERVER_URL #: The url suffix for local storage STORAGE_SERVER_URL = \" files \" Storage Object The class Object is an entity of an object in the container. Usually, you will get a cloud object by accessing an object in the container. my_object = asm . get_file ( \"my_object.txt\" ) Properties and Methods: Object.name: The name of the object Object.size: The size in bytes of the object Object.extension: The extension of the object Object.url: Return the url of the object Object.full_url: Returns the full url of the object Object.secure_url:Return a secured url, with https:// Object.path: The path of the object relative to the container Object.full_path: For Local, it will show the full path of the object, otherwise it just returns the Object.path Object.provider_name: The provider name: ie: Local, S3,... Object.type: The type of the object, ie: IMAGE, AUDIO, TEXT,... OTHER Object.info: Returns a dict of the object name, extension, url, etc. This can be saved in a DB Object.save_to: (method) to save to a destination Object.download_url: (method) Return a URL that triggers the browser download of the file. On cloud providers it will return a signed url.","title":"Storage"},{"location":"advanced/storage/#overview","text":"Aseembly uses Flask-Cloudy to let you access, upload, download, save and delete files on cloud storage providers such as: AWS S3, Google Storage, Microsoft Azure, Rackspace Cloudfiles, and even Local file system. Extension: flask-cloudy","title":"Overview"},{"location":"advanced/storage/#usage","text":"from assembly import asm get_file , upload_file , download_file , delete_file are functions in the asm module.","title":"Usage"},{"location":"advanced/storage/#get-file","text":"asm.get_file will return a Storage Object. from assembly import asm myfile = asm . get_file ( \"hello.txt\" ) myfile . name # return The file name myfile . size # returns file size myfile . full_url # the full url of the file","title":"Get file"},{"location":"advanced/storage/#upload-file","text":"asm.upload_file to save or upload a file in the container","title":"Upload file"},{"location":"advanced/storage/#example-of-file-upload","text":"# main/__init__.py from assembly import Assembly , asm , request , redirect class Index ( Assembly ): def index ( self ): return @request.post def upload ( self ): file = request . files . get ( \"file\" ) if file : profile_image = asm . upload_file ( file , name = utils . gen_uuid (), prefix = \"img.\" , public = True , extensions = [ \"jpg\" , \"jpeg\" , \"png\" , \"gif\" ]) return redirect ( self . upload_success ) def upload_success ( self ): return \"Upload successful!\" Template <!-- main/templates/Index/index.html --> {% extends 'main/layouts/base.html' %} {% block title %} Upload {% endblock %} {% block body %} <h1> Upload </h1> <form id= \"uploadbanner\" action= \"/upload/\" enctype= \"multipart/form-data\" method= \"post\" > <input type= 'hidden' name= \"_csrf_token\" value= ' {{ csrf_token () }} ' > <input id= \"fileupload\" name= \"file\" type= \"file\" /> <input type= \"submit\" value= \"Upload\" id= \"submit\" /> </form> {% endblock %} Note : Since this will call a POST, we also add the CSRF token in the form <input type='hidden' name=\"_csrf_token\" value=' {{ csrf_token () }} '>","title":"Example of file upload"},{"location":"advanced/storage/#signal","text":"asm.upload_file emits a signal to be used from assembly import asm @asm.upload_file.post def file_uploaded ( result , ** kw ): if result : print ( \"File uploaded successfully!\" )","title":"Signal"},{"location":"advanced/storage/#download-file","text":"asm.download_file to download a file to the user. You will need to redirect to that path. from assembly import Assembly , asm , redirect class Index ( Assembly ): def dowload ( self ): filename = \"hello.txt\" name = \"new-name-hello\" url = asm . download_file ( filename , name = name , timeout = 60 ) return redirect ( url )","title":"Download File"},{"location":"advanced/storage/#signal_1","text":"asm.download_file emits a signal to be used from assembly import asm @asm.download_file.post def file_downloaded ( result , ** kw ): if result : print ( \"File uploaded successfully!\" )","title":"Signal"},{"location":"advanced/storage/#delete-file","text":"asm.delete_file deletes a file from storage from assembly import asm asm . delete_file ( \"hello.txt\" )","title":"Delete File"},{"location":"advanced/storage/#signal_2","text":"asm.delete_file emits a signal to be used from assembly import asm @asm.delete_file.post def file_deleted ( result , ** kw ): if result : print ( \"File deleted successfully!\" )","title":"Signal"},{"location":"advanced/storage/#config","text":"# config . py #: STORAGE_PROVIDER : # The provider to use . By default it ' s ' LOCAL ' . # You can use : # LOCAL , S3 , GOOGLE_STORAGE , AZURE_BLOBS , CLOUDFILES STORAGE_PROVIDER = \" LOCAL \" #: STORAGE_KEY # The storage key . Leave it blank if PROVIDER is LOCAL STORAGE_KEY = AWS_ACCESS_KEY_ID #: STORAGE_SECRET #: The storage secret key . Leave it blank if PROVIDER is LOCAL STORAGE_SECRET = AWS_SECRET_ACCESS_KEY #: STORAGE_REGION_NAME #: The region for the storage . Leave it blank if PROVIDER is LOCAL STORAGE_REGION_NAME = AWS_REGION_NAME #: STORAGE_CONTAINER #: The Bucket name ( for S3 , Google storage , Azure , cloudfile ) #: or the directory name ( LOCAL ) to access STORAGE_CONTAINER = os . path . join ( DATA_DIR , \" uploads \" ) #: STORAGE_SERVER #: Bool , to serve local file STORAGE_SERVER = True #: STORAGE_SERVER_URL #: The url suffix for local storage STORAGE_SERVER_URL = \" files \"","title":"Config"},{"location":"advanced/storage/#storage-object","text":"The class Object is an entity of an object in the container. Usually, you will get a cloud object by accessing an object in the container. my_object = asm . get_file ( \"my_object.txt\" ) Properties and Methods: Object.name: The name of the object Object.size: The size in bytes of the object Object.extension: The extension of the object Object.url: Return the url of the object Object.full_url: Returns the full url of the object Object.secure_url:Return a secured url, with https:// Object.path: The path of the object relative to the container Object.full_path: For Local, it will show the full path of the object, otherwise it just returns the Object.path Object.provider_name: The provider name: ie: Local, S3,... Object.type: The type of the object, ie: IMAGE, AUDIO, TEXT,... OTHER Object.info: Returns a dict of the object name, extension, url, etc. This can be saved in a DB Object.save_to: (method) to save to a destination Object.download_url: (method) Return a URL that triggers the browser download of the file. On cloud providers it will return a signed url.","title":"Storage Object"},{"location":"advanced/utils/","text":"Utils contains some common functionw and also exposes under the utils namespace some 3rd party function for convenience Functions Import the utils as follow: from assembly import utils gen_md5 gen_uuid gen_uuid_hex to_json chunk_list in_any_list dict_replace list_replace DotDict is_valid_email is_valid_password is_valid_username -- is_valid_url -- slugify from lib: slugify Inflection utils camelize titleize dasherize underscore plurialize singularize ordinalize ordinal","title":"Utils"},{"location":"advanced/utils/#functions","text":"Import the utils as follow: from assembly import utils","title":"Functions"},{"location":"advanced/utils/#gen_md5","text":"","title":"gen_md5"},{"location":"advanced/utils/#gen_uuid","text":"","title":"gen_uuid"},{"location":"advanced/utils/#gen_uuid_hex","text":"","title":"gen_uuid_hex"},{"location":"advanced/utils/#to_json","text":"","title":"to_json"},{"location":"advanced/utils/#chunk_list","text":"","title":"chunk_list"},{"location":"advanced/utils/#in_any_list","text":"","title":"in_any_list"},{"location":"advanced/utils/#dict_replace","text":"","title":"dict_replace"},{"location":"advanced/utils/#list_replace","text":"","title":"list_replace"},{"location":"advanced/utils/#dotdict","text":"","title":"DotDict"},{"location":"advanced/utils/#is_valid_email","text":"","title":"is_valid_email"},{"location":"advanced/utils/#is_valid_password","text":"","title":"is_valid_password"},{"location":"advanced/utils/#is_valid_username","text":"--","title":"is_valid_username"},{"location":"advanced/utils/#is_valid_url","text":"--","title":"is_valid_url"},{"location":"advanced/utils/#slugify","text":"from lib: slugify","title":"slugify"},{"location":"advanced/utils/#inflection-utils","text":"","title":"Inflection utils"},{"location":"advanced/utils/#camelize","text":"","title":"camelize"},{"location":"advanced/utils/#titleize","text":"","title":"titleize"},{"location":"advanced/utils/#dasherize","text":"","title":"dasherize"},{"location":"advanced/utils/#underscore","text":"","title":"underscore"},{"location":"advanced/utils/#plurialize","text":"","title":"plurialize"},{"location":"advanced/utils/#singularize","text":"","title":"singularize"},{"location":"advanced/utils/#ordinalize","text":"","title":"ordinalize"},{"location":"advanced/utils/#ordinal","text":"","title":"ordinal"},{"location":"application/core/","text":"\"Assembly\" , \"g\" , \"db\" , \"env\" , \"ext\" , \"date\" , \"views\" , \"flash\" , \"config\" , \"models\" , \"session\" , \"extends\" , \"url_for\" , \"redirect\" , \"HTTPError\"","title":"Core"},{"location":"application/models/","text":"Overview Assembly supports RDBMS (Postgresql, MySQL, SQLite) via Active-Alchemy , a wrapper around SQLAlchemy that makes it simple to use your models in an active record like manner, while it still uses the SQLAlchemy db.session underneath. Assembly requires you to create your models in __models__.py , in the View Package folder. __models__.py loads automatically. Models are classes that extends db.Model A simple Models would look like this |- main / |- __init__ . py |- __models__ . py # main/__models__.py from assembly import db class Article ( db . Model ): title = db . Column ( db . String ( 255 )) content = db . Column ( db . Text ) published_at = db . Column ( db . DateTime ) image = db . Column ( db . StorageObjectType ) in views, model can be accessed with models.$ModelClassName . # main/__init__.py from assembly import Assembly , models class Article ( Assembly ): def get ( self , id ): article = models . Article . get ( id ) return { \"article\" : article } Note: Every model class created have a reference in the models object . You can access any models in the application. Extension: Active-Alchemy Extension: SQLAlchemy Features Automatically creates and manages the database connection Supports Postgresql, MySQL, SQLite Each model is a Python class that subclasses assembly.db.Model Each attribute of the model represents a database field by using db.Column With all of this, Assembly gives you an automatically-generated database-access API. ActiveAlchemy automatically creates the session, model and everything necessary for SQLAlchemy. It provides easy methods such as query() , create() , update() , delete() , to select, create, update, delete entries respectively. It automatically create a primary key for your table It adds the following columns: id , created_at , updated_at , is_deleted , deleted_at When delete() , it soft deletes the entry so it doesn't get queried. But it still exists in the database. This feature allows you to un-delete an entry It uses Arrow for DateTime DateTime is saved in UTC and uses the ArrowType from the SQLAlchemy-Utils Added some data types: JSONType, EmailType, and the whole SQLAlchemy-Utils Type db.now -> gives you the Arrow UTC type It is still SQLAlchemy. You can access all the SQLAlchemy awesomeness Configuration Assembly, via Active-Alchemy comes, with a PyMySQL and PG8000 as drivers for MySQL and PostgreSQL respectively, because they are in pure Python. But you can use other drivers for better performance. SQLite is already built in Python. In the config.py set DB_URL DB_URL DB_URL follows RFC-1738, and usually can include username, password, hostname, database name as well as optional keyword arguments for additional configuration. In some cases a file path is accepted, and in others a \u201cdata source name\u201d replaces the \u201chost\u201d and \u201cdatabase\u201d portions. The typical form of a database URL is: dialect + driver : // username : password @host : port / database Postgresql DB_URL = \"postgresql+pg8000://user:password@host:port/database\" MySQL DB_URL = \"mysql+pymysql://user:password@host:port/database\" SQLite DB_URL = \"sqlite:////database.db\" or in memory DB_URL = \"sqlite://\" Model Assembly, when DB_URL is set, will attempt to automatically connect to the database. Assembly exposes db which is an instance of ActiveAlchemy . from assembly import db Create Models Create model classes by extending your class to db.Model . By default Assembly will look for __models__.py to exist to automatically load your models. # main/__models__.py from assembly import db class Article ( db . Model ): title = db . Column ( db . String ( 255 )) content = db . Column ( db . Text ) published_at = db . Column ( db . DateTime ) image = db . Column ( db . StorageObjectType ) Default Columns Upon creation of the table, db.Model will add the following columns: id created_at upated_at is_deleted deleted_at Table name ActiveAlchemy does an automatic table naming by using the class name. The class name should be in PascalCase (UpperCamelCase) when combining multiple words, ie: TodoList . PascalCase name will be converted into lower_underscore_case to be used as the table name in the DB. ie: TodoList -> todo_list . The table names will be not be plurialized. The underscore_case of the Model name will be used as the table name. Examples Article model gets a table named article , User becomes user , TodoList becomes todo_list Define table name To define your own table name, or to create a model from an existing table name, assign __tablename__ property to the value of the table name. class TodoList ( db . Model ): __tablename__ = \"my_existing_table_name\" CLI Command Having created all your models in __models__.py , to create the tables, you need to use the CLI command. asm - admin sync - models This command automatically connects to the DB and only creates the tables that don't exist in the DB. Note You must run the CLI command to create tables. Note In your deploy tool, make sure you have this command to be executed. Model.__sync__ Version: 1.2.0 Model.__sync__() is a class method to add in your Model class that will be executed, when asm-admin sync-models is run. It will allow you to run some routines to setup some data once it's created, or if you want to do some other updates or housekeeping from assembly import db class Test ( db . Model ): name = db . Column ( db . String ( 20 )) @classmethod def __sync__ ( cls ): cls . create ( name = \"Assembly\" ) print ( \"Total: %s \" % cls . query () . count ()) Upon running asm-admin sync-models , __sync__() will also be executed. db.Model db.Model extends your model with helpers that turn your model into an active record like model. But underneath, it still uses the db.session db.Model also adds a few preset columns on the table: id : The primary key created_at : Datetime. It contains the creation date of the record updated_at : Datetime. It is updated whenever the record is updated. deleted_at : Datetime. Contains the datetime the record was soft-deleted. is_deleted : Boolean. A flag to set if record is soft-deleted or not Soft delete marks a record as deleted so it doesn't get queried, but it still exists in the database. This allows you to undo a delete. If you want to completely delete an entry, you can set $entry.delete(hard_delete=True) to do so. CRUD Below are example of some CRUD operations you can do with your models. query query(*args, **kwargs) To start querying the DB and returns a db.session.query object to filter or apply more conditions. from assembly import models for user in models . User . query (): print ( user . login ) By default query() will show only all non-soft-delete records. To display both deleted and non deleted items, add the arg: include_deleted=True for user in models . User . query ( include_deleted = True ) : print ( user . login ) To select columns... for user in models . User . query ( models . User . name . distinct () , models . User . location ) : print ( user . login ) To use with filter... all = models . User . query ( models . User . name . distinct , models . User . location ) . order_by ( models . User . updated_at . desc ()) . filter ( models . User . location == \"Charlotte\" ) get get(id) Get one record by id. By default it will query only a record that is not soft-deleted id = 1234 user = models . User . get ( id ) print ( user . id ) print ( user . login ) To query a record that has been soft deleted, just set the argument include_deleted=True id = 234 user = models . User . get ( id , include_deleted = True ) create create(**kwargs) To create/insert new record. Same as init , but just a shortcut to it. record = models . User . create ( login = 'abc' , passw_hash = 'hash' , profile_id = 123 ) print ( record . login ) # -> abc or you can use the constructor with save() record = models . User ( login = 'abc' , passw_hash = 'hash' , profile_id = 123 ). save () print ( record . login ) # -> abc or record = models . User ( login = 'abc' , passw_hash = 'hash' , profile_id = 123 ) record . save () print ( record . login ) # -> abc update update(**kwargs) Update an existing record record = models . User . get ( 124 ) record . update ( login = 'new_login' ) print ( record . login ) # -> new_login delete delete() To soft delete a record. is_deleted will be set to True and deleted_at datetime will be set record = models . User . get ( 124 ) record . delete () print ( record . is_deleted ) # -> True To soft UNdelete a record. is_deleted will be set to False and deleted_at datetime will be None record = models . User . get ( 124 ) record . delete ( hard_delete = False ) print ( record . is_deleted ) # -> False To HARD delete a record. The record will be deleted completely record = models . User . get ( 124 ) record . delete ( hard_delete = True ) save save() A shortcut to update an entry record = models . User . get ( 124 ) record . login = \"Another one\" record . save () Method Chaining For convenience, some method chaining are available user = models . User ( name = \"Mardix\" , location = \"Charlotte\" ). save () models . User . get ( 12345 ). update ( location = \"Atlanta\" ) models . User . get ( 345 ). delete (). delete ( False ). update ( location = \"St. Louis\" ) Aggegated selects class Product ( db . Model ): name = db . Column ( db . String ( 250 )) price = db . Column ( db . Numeric ) price_label = db . func . sum ( models . Product . price ). label ( 'price' ) results = models . Product . query ( price_label ) Learn more on Active-Alchemy Views Views can easily access your models, via the models object. from assembly import Assembly , models All the models created will have their reference in the models object. # main/__init__.py from assembly import Assembly , models class Article ( Assembly ): def get ( self , id ): article = models . Article . get ( id ) return { \"article\" : article } Learn more on Views Columns Columns are also properties under db object. ie: from assembly import db class Article ( db . Model ): title = db . Column ( db . String ( 250 )) content = db . Column ( db . Text ) Column Types Read mode about Column and Data Types BIGINT BINARY BLOB BOOLEAN BigInteger Boolean CHAR CLOB Concatenable DATE DATETIME DECIMAL Date DateTime Enum FLOAT Float INT INTEGER Integer Interval LargeBinary MatchType NCHAR NVARCHAR Numeric PickleType REAL SMALLINT SchemaType SmallInteger String TEXT TIME TIMESTAMP Text Time TypeDecorator TypeEnginBases TypeEngine Unicode VARBINARY VARCHAR Other Types Beside the default SQLAlchemy column types, ActiveAlchemy also extends the types with some additional ones for convenience from SQLAlchemy-Utils. DateTime Alias to ArrowType, which provides way of saving Arrow objects into database. It automatically changes Arrow objects to datetime objects on the way in and datetime objects back to Arrow objects on the way out (when querying database). Example # __models__.py from assembly import db class Article ( db . Model ): title = db . Column ( db . String ( 255 )) published_at = db . Column ( db . DateTime ) Create from assembly import date , models models . Article . create ( title = 'Hi' , published_at = date . utcnow ) Read from assembly import models article = models . Article . get ( 1 ) article . created_at = article . created_at . replace ( hours =- 1 ) article . created_at . humanize () #-> 'an hour ago' Links ArrowType Arrow Arrow Tokens StorageObjectType StorageObjectType offers way of saving Storage.Object data structures to database. It automatically changes Arrow objects to JSON objects on the way in and Storage.Object objects back on the way out (when querying database). Example from assembly import db class Article ( db . Model ): title = db . Column ( db . String ( 255 )) published_at = db . Column ( db . DateTime ) image = db . Column ( db . StorageObjectType ) Create from assembly import date , models , asm image_file = \"file/xyz.jpg\" image = asm . upload_file ( image_file ) models . Article . create ( title = 'Hi' , published_at = date . utcnow , image = image ) Read from assembly import models article = models . Article . get ( 1 ) article . image . url article . image . size article . image . download () EmailType Provides a way for storing emails in a lower case. Example from assembly import db class Article ( db . Model ): title = db . Column ( db . String ( 255 )) published_at = db . Column ( db . DateTime ) email = db . Column ( db . EmailType ) EmailType JSONType JSONType offers way of saving JSON data structures to database. On PostgreSQL the underlying implementation of this data type is \u2018json\u2019 while on other databases its simply \u2018text\u2019. Example from assembly import db class Article ( db . Model ): title = db . Column ( db . String ( 255 )) published_at = db . Column ( db . DateTime ) data = db . Column ( db . JSONType ) Create from assembly import models , date models . Article . create ( title = 'Hello' , published_at = date . utcnow , data = { \"reference\" : \"blah\" , \"tags\" : [ \"A\" , \"B\" , \"C\" ] }) Read article = models . Article . get ( 1 ) article . data . get ( \"reference\" ) # blah article . data . get ( \"tags\" ) # [ \"A\" , \"B\" , \"C\" ] article . data . get ( \"location\" , \"Charlotte\" ) # Charlotte JSONType More SQLAlchemy-Utils Types For more types, SQLAlchemy-Utils provides various new data types for SQLAlchemy. SQLAlchemy-Utils ArrowType ChoiceType ColorType CountryType CurrencyType EmailType EncryptedType JSONType LocaleType LtreeType IPAddressType PasswordType PhoneNumberType ScalarListType TimezoneType TSVectorType URLType UUIDType WeekDaysType","title":"Models"},{"location":"application/models/#overview","text":"Assembly supports RDBMS (Postgresql, MySQL, SQLite) via Active-Alchemy , a wrapper around SQLAlchemy that makes it simple to use your models in an active record like manner, while it still uses the SQLAlchemy db.session underneath. Assembly requires you to create your models in __models__.py , in the View Package folder. __models__.py loads automatically. Models are classes that extends db.Model A simple Models would look like this |- main / |- __init__ . py |- __models__ . py # main/__models__.py from assembly import db class Article ( db . Model ): title = db . Column ( db . String ( 255 )) content = db . Column ( db . Text ) published_at = db . Column ( db . DateTime ) image = db . Column ( db . StorageObjectType ) in views, model can be accessed with models.$ModelClassName . # main/__init__.py from assembly import Assembly , models class Article ( Assembly ): def get ( self , id ): article = models . Article . get ( id ) return { \"article\" : article } Note: Every model class created have a reference in the models object . You can access any models in the application. Extension: Active-Alchemy Extension: SQLAlchemy","title":"Overview"},{"location":"application/models/#features","text":"Automatically creates and manages the database connection Supports Postgresql, MySQL, SQLite Each model is a Python class that subclasses assembly.db.Model Each attribute of the model represents a database field by using db.Column With all of this, Assembly gives you an automatically-generated database-access API. ActiveAlchemy automatically creates the session, model and everything necessary for SQLAlchemy. It provides easy methods such as query() , create() , update() , delete() , to select, create, update, delete entries respectively. It automatically create a primary key for your table It adds the following columns: id , created_at , updated_at , is_deleted , deleted_at When delete() , it soft deletes the entry so it doesn't get queried. But it still exists in the database. This feature allows you to un-delete an entry It uses Arrow for DateTime DateTime is saved in UTC and uses the ArrowType from the SQLAlchemy-Utils Added some data types: JSONType, EmailType, and the whole SQLAlchemy-Utils Type db.now -> gives you the Arrow UTC type It is still SQLAlchemy. You can access all the SQLAlchemy awesomeness","title":"Features"},{"location":"application/models/#configuration","text":"Assembly, via Active-Alchemy comes, with a PyMySQL and PG8000 as drivers for MySQL and PostgreSQL respectively, because they are in pure Python. But you can use other drivers for better performance. SQLite is already built in Python. In the config.py set DB_URL DB_URL DB_URL follows RFC-1738, and usually can include username, password, hostname, database name as well as optional keyword arguments for additional configuration. In some cases a file path is accepted, and in others a \u201cdata source name\u201d replaces the \u201chost\u201d and \u201cdatabase\u201d portions. The typical form of a database URL is: dialect + driver : // username : password @host : port / database Postgresql DB_URL = \"postgresql+pg8000://user:password@host:port/database\" MySQL DB_URL = \"mysql+pymysql://user:password@host:port/database\" SQLite DB_URL = \"sqlite:////database.db\" or in memory DB_URL = \"sqlite://\"","title":"Configuration"},{"location":"application/models/#model","text":"Assembly, when DB_URL is set, will attempt to automatically connect to the database. Assembly exposes db which is an instance of ActiveAlchemy . from assembly import db","title":"Model"},{"location":"application/models/#create-models","text":"Create model classes by extending your class to db.Model . By default Assembly will look for __models__.py to exist to automatically load your models. # main/__models__.py from assembly import db class Article ( db . Model ): title = db . Column ( db . String ( 255 )) content = db . Column ( db . Text ) published_at = db . Column ( db . DateTime ) image = db . Column ( db . StorageObjectType )","title":"Create Models"},{"location":"application/models/#default-columns","text":"Upon creation of the table, db.Model will add the following columns: id created_at upated_at is_deleted deleted_at","title":"Default Columns"},{"location":"application/models/#table-name","text":"ActiveAlchemy does an automatic table naming by using the class name. The class name should be in PascalCase (UpperCamelCase) when combining multiple words, ie: TodoList . PascalCase name will be converted into lower_underscore_case to be used as the table name in the DB. ie: TodoList -> todo_list . The table names will be not be plurialized. The underscore_case of the Model name will be used as the table name. Examples Article model gets a table named article , User becomes user , TodoList becomes todo_list","title":"Table name"},{"location":"application/models/#define-table-name","text":"To define your own table name, or to create a model from an existing table name, assign __tablename__ property to the value of the table name. class TodoList ( db . Model ): __tablename__ = \"my_existing_table_name\"","title":"Define table name"},{"location":"application/models/#cli-command","text":"Having created all your models in __models__.py , to create the tables, you need to use the CLI command. asm - admin sync - models This command automatically connects to the DB and only creates the tables that don't exist in the DB. Note You must run the CLI command to create tables. Note In your deploy tool, make sure you have this command to be executed.","title":"CLI Command"},{"location":"application/models/#model9595sync__","text":"Version: 1.2.0 Model.__sync__() is a class method to add in your Model class that will be executed, when asm-admin sync-models is run. It will allow you to run some routines to setup some data once it's created, or if you want to do some other updates or housekeeping from assembly import db class Test ( db . Model ): name = db . Column ( db . String ( 20 )) @classmethod def __sync__ ( cls ): cls . create ( name = \"Assembly\" ) print ( \"Total: %s \" % cls . query () . count ()) Upon running asm-admin sync-models , __sync__() will also be executed.","title":"Model.__sync__"},{"location":"application/models/#dbmodel","text":"db.Model extends your model with helpers that turn your model into an active record like model. But underneath, it still uses the db.session db.Model also adds a few preset columns on the table: id : The primary key created_at : Datetime. It contains the creation date of the record updated_at : Datetime. It is updated whenever the record is updated. deleted_at : Datetime. Contains the datetime the record was soft-deleted. is_deleted : Boolean. A flag to set if record is soft-deleted or not Soft delete marks a record as deleted so it doesn't get queried, but it still exists in the database. This allows you to undo a delete. If you want to completely delete an entry, you can set $entry.delete(hard_delete=True) to do so.","title":"db.Model"},{"location":"application/models/#crud","text":"Below are example of some CRUD operations you can do with your models.","title":"CRUD"},{"location":"application/models/#query","text":"query(*args, **kwargs) To start querying the DB and returns a db.session.query object to filter or apply more conditions. from assembly import models for user in models . User . query (): print ( user . login ) By default query() will show only all non-soft-delete records. To display both deleted and non deleted items, add the arg: include_deleted=True for user in models . User . query ( include_deleted = True ) : print ( user . login ) To select columns... for user in models . User . query ( models . User . name . distinct () , models . User . location ) : print ( user . login ) To use with filter... all = models . User . query ( models . User . name . distinct , models . User . location ) . order_by ( models . User . updated_at . desc ()) . filter ( models . User . location == \"Charlotte\" )","title":"query"},{"location":"application/models/#get","text":"get(id) Get one record by id. By default it will query only a record that is not soft-deleted id = 1234 user = models . User . get ( id ) print ( user . id ) print ( user . login ) To query a record that has been soft deleted, just set the argument include_deleted=True id = 234 user = models . User . get ( id , include_deleted = True )","title":"get"},{"location":"application/models/#create","text":"create(**kwargs) To create/insert new record. Same as init , but just a shortcut to it. record = models . User . create ( login = 'abc' , passw_hash = 'hash' , profile_id = 123 ) print ( record . login ) # -> abc or you can use the constructor with save() record = models . User ( login = 'abc' , passw_hash = 'hash' , profile_id = 123 ). save () print ( record . login ) # -> abc or record = models . User ( login = 'abc' , passw_hash = 'hash' , profile_id = 123 ) record . save () print ( record . login ) # -> abc","title":"create"},{"location":"application/models/#update","text":"update(**kwargs) Update an existing record record = models . User . get ( 124 ) record . update ( login = 'new_login' ) print ( record . login ) # -> new_login","title":"update"},{"location":"application/models/#delete","text":"delete() To soft delete a record. is_deleted will be set to True and deleted_at datetime will be set record = models . User . get ( 124 ) record . delete () print ( record . is_deleted ) # -> True To soft UNdelete a record. is_deleted will be set to False and deleted_at datetime will be None record = models . User . get ( 124 ) record . delete ( hard_delete = False ) print ( record . is_deleted ) # -> False To HARD delete a record. The record will be deleted completely record = models . User . get ( 124 ) record . delete ( hard_delete = True )","title":"delete"},{"location":"application/models/#save","text":"save() A shortcut to update an entry record = models . User . get ( 124 ) record . login = \"Another one\" record . save ()","title":"save"},{"location":"application/models/#method-chaining","text":"For convenience, some method chaining are available user = models . User ( name = \"Mardix\" , location = \"Charlotte\" ). save () models . User . get ( 12345 ). update ( location = \"Atlanta\" ) models . User . get ( 345 ). delete (). delete ( False ). update ( location = \"St. Louis\" )","title":"Method Chaining"},{"location":"application/models/#aggegated-selects","text":"class Product ( db . Model ): name = db . Column ( db . String ( 250 )) price = db . Column ( db . Numeric ) price_label = db . func . sum ( models . Product . price ). label ( 'price' ) results = models . Product . query ( price_label ) Learn more on Active-Alchemy","title":"Aggegated selects"},{"location":"application/models/#views","text":"Views can easily access your models, via the models object. from assembly import Assembly , models All the models created will have their reference in the models object. # main/__init__.py from assembly import Assembly , models class Article ( Assembly ): def get ( self , id ): article = models . Article . get ( id ) return { \"article\" : article } Learn more on Views","title":"Views"},{"location":"application/models/#columns","text":"Columns are also properties under db object. ie: from assembly import db class Article ( db . Model ): title = db . Column ( db . String ( 250 )) content = db . Column ( db . Text )","title":"Columns"},{"location":"application/models/#column-types","text":"Read mode about Column and Data Types BIGINT BINARY BLOB BOOLEAN BigInteger Boolean CHAR CLOB Concatenable DATE DATETIME DECIMAL Date DateTime Enum FLOAT Float INT INTEGER Integer Interval LargeBinary MatchType NCHAR NVARCHAR Numeric PickleType REAL SMALLINT SchemaType SmallInteger String TEXT TIME TIMESTAMP Text Time TypeDecorator TypeEnginBases TypeEngine Unicode VARBINARY VARCHAR","title":"Column Types"},{"location":"application/models/#other-types","text":"Beside the default SQLAlchemy column types, ActiveAlchemy also extends the types with some additional ones for convenience from SQLAlchemy-Utils.","title":"Other Types"},{"location":"application/models/#datetime","text":"Alias to ArrowType, which provides way of saving Arrow objects into database. It automatically changes Arrow objects to datetime objects on the way in and datetime objects back to Arrow objects on the way out (when querying database). Example # __models__.py from assembly import db class Article ( db . Model ): title = db . Column ( db . String ( 255 )) published_at = db . Column ( db . DateTime ) Create from assembly import date , models models . Article . create ( title = 'Hi' , published_at = date . utcnow ) Read from assembly import models article = models . Article . get ( 1 ) article . created_at = article . created_at . replace ( hours =- 1 ) article . created_at . humanize () #-> 'an hour ago' Links ArrowType Arrow Arrow Tokens","title":"DateTime"},{"location":"application/models/#storageobjecttype","text":"StorageObjectType offers way of saving Storage.Object data structures to database. It automatically changes Arrow objects to JSON objects on the way in and Storage.Object objects back on the way out (when querying database). Example from assembly import db class Article ( db . Model ): title = db . Column ( db . String ( 255 )) published_at = db . Column ( db . DateTime ) image = db . Column ( db . StorageObjectType ) Create from assembly import date , models , asm image_file = \"file/xyz.jpg\" image = asm . upload_file ( image_file ) models . Article . create ( title = 'Hi' , published_at = date . utcnow , image = image ) Read from assembly import models article = models . Article . get ( 1 ) article . image . url article . image . size article . image . download ()","title":"StorageObjectType"},{"location":"application/models/#emailtype","text":"Provides a way for storing emails in a lower case. Example from assembly import db class Article ( db . Model ): title = db . Column ( db . String ( 255 )) published_at = db . Column ( db . DateTime ) email = db . Column ( db . EmailType ) EmailType","title":"EmailType"},{"location":"application/models/#jsontype","text":"JSONType offers way of saving JSON data structures to database. On PostgreSQL the underlying implementation of this data type is \u2018json\u2019 while on other databases its simply \u2018text\u2019. Example from assembly import db class Article ( db . Model ): title = db . Column ( db . String ( 255 )) published_at = db . Column ( db . DateTime ) data = db . Column ( db . JSONType ) Create from assembly import models , date models . Article . create ( title = 'Hello' , published_at = date . utcnow , data = { \"reference\" : \"blah\" , \"tags\" : [ \"A\" , \"B\" , \"C\" ] }) Read article = models . Article . get ( 1 ) article . data . get ( \"reference\" ) # blah article . data . get ( \"tags\" ) # [ \"A\" , \"B\" , \"C\" ] article . data . get ( \"location\" , \"Charlotte\" ) # Charlotte JSONType","title":"JSONType"},{"location":"application/models/#more-sqlalchemy-utils-types","text":"For more types, SQLAlchemy-Utils provides various new data types for SQLAlchemy. SQLAlchemy-Utils ArrowType ChoiceType ColorType CountryType CurrencyType EmailType EncryptedType JSONType LocaleType LtreeType IPAddressType PasswordType PhoneNumberType ScalarListType TimezoneType TSVectorType URLType UUIDType WeekDaysType","title":"More SQLAlchemy-Utils Types"},{"location":"application/static/","text":"-- IN CONSTRUCTION --","title":"Static"},{"location":"application/templates/","text":"Overview Assembly uses Jinja as template language, files are organized per Class and Methods name. |- main / |- __init__ . py |- __models__ . py |- templates / |- static / Structure Files are organized per Class and Methods name. Each class name have corresponding folder with the same name, and every method have a corresponding .html with the same name inside of the folder. Having a View like this... # admin/__init__.py from assembly import Assembly class Index ( Assembly ): def index ( self ): return def login ( self ): return class Articles ( Assembly ): def index ( self ): return def all ( self ): return class Movies ( Assembly ): def index ( self ): return def guide ( self ): return def channels ( self ): return will map to templates below |- admin |- __init__ . py |- __models__ . py |- templates |- Index |- index . html |- login . html |- Articles |- index . html |- all . html |- Movies |- index . html |- guide . html |- channels . html |- static |- cli . py -- IN CONSTRUCTION --","title":"Templates"},{"location":"application/templates/#overview","text":"Assembly uses Jinja as template language, files are organized per Class and Methods name. |- main / |- __init__ . py |- __models__ . py |- templates / |- static /","title":"Overview"},{"location":"application/templates/#structure","text":"Files are organized per Class and Methods name. Each class name have corresponding folder with the same name, and every method have a corresponding .html with the same name inside of the folder. Having a View like this... # admin/__init__.py from assembly import Assembly class Index ( Assembly ): def index ( self ): return def login ( self ): return class Articles ( Assembly ): def index ( self ): return def all ( self ): return class Movies ( Assembly ): def index ( self ): return def guide ( self ): return def channels ( self ): return will map to templates below |- admin |- __init__ . py |- __models__ . py |- templates |- Index |- index . html |- login . html |- Articles |- index . html |- all . html |- Movies |- index . html |- guide . html |- channels . html |- static |- cli . py -- IN CONSTRUCTION --","title":"Structure"},{"location":"application/views/","text":"Overview Assembly views are classes that extend Assembly Assembly by default suggests that you put your views in __init__.py , in the View Package folder. A simple View would look like this |- hello_world / |- __init__ . py # hello_world/__init__.py from assembly import Assembly class Index ( Assembly ): def index ( self ): return \"Hello World\" Working with View To create a view, just create a folder at the root of the application and create __init__.py in it. You may also create __models__.py , templates/ , static/ , cli.py . Or you can use the built-in CLI to create your view # asm - admin gen - api - view myapi # asm - admin gen - template - view admin Imports Turn your classes into Assembly views by extending Assembly from assembly import Assembly class Index ( Assembly ): index ( self ): return Routing By default Assembly creates routes based on the class name and the method. Modifiying routes Use @request.route on classes or method to change the route endpoint from assembly import Assembly , request # responds to -> /admin @request.route ( \"/admin/\" ) class Index ( Assembly ): # responds to /admin/catalog @request.route ( \"catalog\" ) index ( self ): return Routing Rules Index Class named Index or method named index will be the root of the endpoint # responds to -> / class Index ( Assembly ) : # responds to -> / index ( self ) : return Class name are base routes the class name is the base url # responds to -> / api class Api ( Assembly ) : # responds to -> / api / def index ( self ) : return # responds to -> / article / class Article ( Assembly ) : # responds to -> / articles / def index ( self ) : return method names are routes # responds to -> / class Index ( Assembly ) : # responds to -> / index ( self ) : return # responds to -> / hello / hello ( self ) : return # responds to -> / save / save ( self ) : return With underscore Methods containing underscore in between, will turn into dash/hyphe class Index ( Assembly ) : # responds to -> / about - us / about_us ( self ) : return However, method starting with undescrore will be ignored class Index ( Assembly ) : # will not be assigned a route because it starts with underscore _log_data_info ( self ) : return RESTful get , post , put , delete will automatically be assigned their method name class Index ( Assembly ) : # will responds on get call get ( self ) : return # will responds on post call post ( self ) : return # will responds on delete call delete ( self ) : return # will responds on put call put ( self ) : return # will responds on update call update ( self ) : return Special methods Below are methods that are very special to your application _before_request This function will run before each request class Index ( Assembly ) : def _before_request ( self , name ) : \"\"\" name : The name of the view that \u2019 s about to be called \"\"\" pass def index ( self ) : return _after_request This function will run after each request class Index ( Assembly ) : def _after_request ( self , name , response ) : \"\"\" name : The name of the view that \u2019 s about to be called response : The response object . Must return the response \"\"\" return response def index ( self ) : return _error_handler This function will catch all HTTPError. class Index ( Assembly ) : def _error_handler ( self , error ) : return { \" e \" : error } _error_$errorCode This function will catch an HTTP Error Code class Index ( Assembly ) : # will catch 404 only def _error_404 ( self , error ) : return { \" e \" : error } # will catch 401 only def _error_401 ( self , error ) : return { \" e \" : error } # will catch 500 only def _error_500 ( self , error ) : return { \" e \" : error } _before_$methodName This function will run before each time $methodName is called class Index ( Assembly ): def _before_about_us ( self , name ): \"\"\" name: The name of the view that\u2019s about to be called \"\"\" pass def about_us ( self ): pass _after_$methodName This function will run after each time $methodName is called class Index ( Assembly ) : def _after_about_us ( self , name ) : \"\"\" name : The name of the view that \u2019 s about to be called response : The response object . Must return the response \"\"\" return response def about_us ( self ) : pass Request Request is a Proxy to Flask request with extra functionalities. For example it adds route decorator, cors decorator, etc. from assembly import request Go to: Request Response By default, Assembly will attempt to match a template with the view. Sometimes you may want to return JSON or cache the response. The response module provides some decorators to help with some response functionalities. from assembly import response Go to: Response Redirect Redirect helps you redirect to different enpoint using the method name via 'self' or the class itself. Assembly knows what to do. also allows inter within from assembly import redirect Go to: Redirect url_for Generates a URL to the given endpoint with the method provided. It's a proxy to Flask url_for, but add some functionalities. Extra arguments will be used as query params. To get the full url, add _external=True . from assembly import Assembly , url_for , views class Index ( Assembly ): def index ( self ): return { \"about-us-url\" : url_for ( self . about_us ), \"blog-url\" : url_for ( Blog . index ), \"articles-url\" : url_for ( views . articles . Articles . index ), } def about_us ( self ): return Class Blog ( Assembly ): def index ( self ): return # articles/__init__.py class Articles ( Assembly ): def index ( self ): return Models Models can be used easily by importing the models object. It contains a reference of every models that have been created with db.Model Learn more on Models # main/__models__.py from assembly import db class Article ( db . Model ): title = db . Column ( db . String ( 250 )) content = db . Column ( db . Text ) class Author ( db . Model ): name = db . Column ( db . String ( 250 )) from assembly import Assembly , models class Index ( Assembly ): def articles ( self ): articles = models . Article . query () articles = articles . paginate ( page = 1 , per_page = 20 ) return { \"articles\" : articles } Config You can access config variable in your view by using config . config is a dict to retrieve any info. It also allows dot notation to drill down property Go to: Config from assembly import Assembly , config class Index ( Assembly ): def index ( self ): app_version = config . get ( \"APPLICATION_VERSION\" ) default_date = config . get ( \"DATE_FORMAT.default\" ) return Error Handling A special method _error_handler can be added in your view class to capture any HTTPException. from assembly import HTTPError Go to: Error Handling Working with dates To work with dates, Assembly provides date . from assembly import date Go to: Dates Session Working with session from assembly import session Go to: Session Flash Working with flash from assembly import flash Go to: Flash","title":"Views"},{"location":"application/views/#overview","text":"Assembly views are classes that extend Assembly Assembly by default suggests that you put your views in __init__.py , in the View Package folder. A simple View would look like this |- hello_world / |- __init__ . py # hello_world/__init__.py from assembly import Assembly class Index ( Assembly ): def index ( self ): return \"Hello World\"","title":"Overview"},{"location":"application/views/#working-with-view","text":"To create a view, just create a folder at the root of the application and create __init__.py in it. You may also create __models__.py , templates/ , static/ , cli.py . Or you can use the built-in CLI to create your view # asm - admin gen - api - view myapi # asm - admin gen - template - view admin","title":"Working with View"},{"location":"application/views/#imports","text":"Turn your classes into Assembly views by extending Assembly from assembly import Assembly class Index ( Assembly ): index ( self ): return","title":"Imports"},{"location":"application/views/#routing","text":"By default Assembly creates routes based on the class name and the method.","title":"Routing"},{"location":"application/views/#modifiying-routes","text":"Use @request.route on classes or method to change the route endpoint from assembly import Assembly , request # responds to -> /admin @request.route ( \"/admin/\" ) class Index ( Assembly ): # responds to /admin/catalog @request.route ( \"catalog\" ) index ( self ): return","title":"Modifiying routes"},{"location":"application/views/#routing-rules","text":"","title":"Routing Rules"},{"location":"application/views/#index","text":"Class named Index or method named index will be the root of the endpoint # responds to -> / class Index ( Assembly ) : # responds to -> / index ( self ) : return","title":"Index"},{"location":"application/views/#class-name-are-base-routes","text":"the class name is the base url # responds to -> / api class Api ( Assembly ) : # responds to -> / api / def index ( self ) : return # responds to -> / article / class Article ( Assembly ) : # responds to -> / articles / def index ( self ) : return","title":"Class name are base routes"},{"location":"application/views/#method-names-are-routes","text":"# responds to -> / class Index ( Assembly ) : # responds to -> / index ( self ) : return # responds to -> / hello / hello ( self ) : return # responds to -> / save / save ( self ) : return","title":"method names are routes"},{"location":"application/views/#with-underscore","text":"Methods containing underscore in between, will turn into dash/hyphe class Index ( Assembly ) : # responds to -> / about - us / about_us ( self ) : return However, method starting with undescrore will be ignored class Index ( Assembly ) : # will not be assigned a route because it starts with underscore _log_data_info ( self ) : return","title":"With underscore"},{"location":"application/views/#restful","text":"get , post , put , delete will automatically be assigned their method name class Index ( Assembly ) : # will responds on get call get ( self ) : return # will responds on post call post ( self ) : return # will responds on delete call delete ( self ) : return # will responds on put call put ( self ) : return # will responds on update call update ( self ) : return","title":"RESTful"},{"location":"application/views/#special-methods","text":"Below are methods that are very special to your application","title":"Special methods"},{"location":"application/views/#_before_request","text":"This function will run before each request class Index ( Assembly ) : def _before_request ( self , name ) : \"\"\" name : The name of the view that \u2019 s about to be called \"\"\" pass def index ( self ) : return","title":"_before_request"},{"location":"application/views/#_after_request","text":"This function will run after each request class Index ( Assembly ) : def _after_request ( self , name , response ) : \"\"\" name : The name of the view that \u2019 s about to be called response : The response object . Must return the response \"\"\" return response def index ( self ) : return","title":"_after_request"},{"location":"application/views/#_error_handler","text":"This function will catch all HTTPError. class Index ( Assembly ) : def _error_handler ( self , error ) : return { \" e \" : error }","title":"_error_handler"},{"location":"application/views/#_error95errorcode","text":"This function will catch an HTTP Error Code class Index ( Assembly ) : # will catch 404 only def _error_404 ( self , error ) : return { \" e \" : error } # will catch 401 only def _error_401 ( self , error ) : return { \" e \" : error } # will catch 500 only def _error_500 ( self , error ) : return { \" e \" : error }","title":"_error_$errorCode"},{"location":"application/views/#_before95methodname","text":"This function will run before each time $methodName is called class Index ( Assembly ): def _before_about_us ( self , name ): \"\"\" name: The name of the view that\u2019s about to be called \"\"\" pass def about_us ( self ): pass","title":"_before_$methodName"},{"location":"application/views/#_after95methodname","text":"This function will run after each time $methodName is called class Index ( Assembly ) : def _after_about_us ( self , name ) : \"\"\" name : The name of the view that \u2019 s about to be called response : The response object . Must return the response \"\"\" return response def about_us ( self ) : pass","title":"_after_$methodName"},{"location":"application/views/#request","text":"Request is a Proxy to Flask request with extra functionalities. For example it adds route decorator, cors decorator, etc. from assembly import request Go to: Request","title":"Request"},{"location":"application/views/#response","text":"By default, Assembly will attempt to match a template with the view. Sometimes you may want to return JSON or cache the response. The response module provides some decorators to help with some response functionalities. from assembly import response Go to: Response","title":"Response"},{"location":"application/views/#redirect","text":"Redirect helps you redirect to different enpoint using the method name via 'self' or the class itself. Assembly knows what to do. also allows inter within from assembly import redirect Go to: Redirect","title":"Redirect"},{"location":"application/views/#url_for","text":"Generates a URL to the given endpoint with the method provided. It's a proxy to Flask url_for, but add some functionalities. Extra arguments will be used as query params. To get the full url, add _external=True . from assembly import Assembly , url_for , views class Index ( Assembly ): def index ( self ): return { \"about-us-url\" : url_for ( self . about_us ), \"blog-url\" : url_for ( Blog . index ), \"articles-url\" : url_for ( views . articles . Articles . index ), } def about_us ( self ): return Class Blog ( Assembly ): def index ( self ): return # articles/__init__.py class Articles ( Assembly ): def index ( self ): return","title":"url_for"},{"location":"application/views/#models","text":"Models can be used easily by importing the models object. It contains a reference of every models that have been created with db.Model Learn more on Models # main/__models__.py from assembly import db class Article ( db . Model ): title = db . Column ( db . String ( 250 )) content = db . Column ( db . Text ) class Author ( db . Model ): name = db . Column ( db . String ( 250 )) from assembly import Assembly , models class Index ( Assembly ): def articles ( self ): articles = models . Article . query () articles = articles . paginate ( page = 1 , per_page = 20 ) return { \"articles\" : articles }","title":"Models"},{"location":"application/views/#config","text":"You can access config variable in your view by using config . config is a dict to retrieve any info. It also allows dot notation to drill down property Go to: Config from assembly import Assembly , config class Index ( Assembly ): def index ( self ): app_version = config . get ( \"APPLICATION_VERSION\" ) default_date = config . get ( \"DATE_FORMAT.default\" ) return","title":"Config"},{"location":"application/views/#error-handling","text":"A special method _error_handler can be added in your view class to capture any HTTPException. from assembly import HTTPError Go to: Error Handling","title":"Error Handling"},{"location":"application/views/#working-with-dates","text":"To work with dates, Assembly provides date . from assembly import date Go to: Dates","title":"Working with dates"},{"location":"application/views/#session","text":"Working with session from assembly import session Go to: Session","title":"Session"},{"location":"application/views/#flash","text":"Working with flash from assembly import flash Go to: Flash","title":"Flash"}]}