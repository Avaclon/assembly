{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"local_florist Assembly local_florist A Pythonic Object-Oriented Web Framework built on Flask About Assembly is a pythonic object-oriented, mid stack, batteries included framework built on Flask, that adds structure to your Flask application, and group your routes by class. Assembly allows developers to build web applications in much the same way they would build any other object-oriented Python program. Technically Assembly is an attempt of making a simple framework based on Flask Great Again! Installation Guide Quick Start This quickstart will allow us to go with Assembly from 0 to 100! 1. Install Assembly Install Assembly with pip install assembly It is highly recommended to use a virtualenv, in this case let's use VirtualenvWrapper (you can use any that is convenient for you) mkvirtualenv my - first - app workon my - first - app pip install assembly 2. Initialize your application Initialize Assembly with asm-admin init CD into the folder you intend to create the application, then run asm-admin init . This will setup the structure along with the necessary files to get started cd app - dir asm - admin init Upon initialization you should have a structure similar to this: -- / |- wsgi . py |- config . py |- requirements . txt |- main |- __init__ . py |- __models__ . py |- templates |- Index |- index . html |- layouts |- base . html |- static |- cli . py |- __data__ / 3. Edit your first view # main/__init__.py from assembly import ( Assembly , response ) class Index ( Assembly ): index ( self ): return { \"title\" : \"Assembly is awesome\" , \"content\" : \"That is a true fact\" } @response.json api ( self ): return { \"name\" : \"Assembly\" , \"version\" : \"x-to-infinity\" } 4. Edit your template 4.0 Edit base layout <!-- main/templates/layouts/base.html --> <!doctype html> <html lang= \"en\" > <head> <title> {% block title %}{% endblock %} </title> </head> <body> <div class= \"container\" > {% block body %}{% endblock %} </div> </body> </html> 4.1 Edit Index/index.html <!-- main/templates/Index/index.html --> {% extends 'main/layouts/base.html' %} {% block title %} Welcome to my Assembly Site {% endblock %} {% block body %} <div> <h1> {{ title }} </h1> </div> <div> {{ content }} </div> {% endblock %} 5. Serve your first application If everything is all set, all you need to do now is run your site: asm - admin serve It will start serving your application by default at 127.0.0.1:5000 Two endpoints will be available: http://127.0.0.1:5000/ which will show an HTML http://127.0.0.1:5000/api/ which will a json response Features List Smart routing: automatically generates routes based on the classes and methods in your views Class name as the base url, ie: class UserAccount will be accessed at '/user-account' Class methods (action) could be accessed: hello_world(self) becomes 'hello-world' Easy rending and render decorator Auto route can be edited with @route() Restful: GET, POST, PUT, DELETE REST API Ready Markdown friendly. Inclusion of a markdown file will turn into HTML BCRYPT is chosen as the password hasher Session: Redis, AWS S3, Google Storage, SQLite, MySQL, PostgreSQL Database/ORM: Active-Alchemy (SQLALchemy wrapper) CSRF on all POST Storage: Local, S3, Google Storage Flask-Cloudy Mailer (SES or SMTP) Arrow for date and time Caching JWT Pagination Signals: to dispatch messages and data to other part of the application Markdown Jinja2 for templating language Multi application Web Assets CLI Local server Credits: Flask, Flask-Classy","title":"Overview"},{"location":"#about","text":"Assembly is a pythonic object-oriented, mid stack, batteries included framework built on Flask, that adds structure to your Flask application, and group your routes by class. Assembly allows developers to build web applications in much the same way they would build any other object-oriented Python program. Technically Assembly is an attempt of making a simple framework based on Flask Great Again! Installation Guide","title":"About"},{"location":"#quick-start","text":"This quickstart will allow us to go with Assembly from 0 to 100!","title":"Quick Start"},{"location":"#1-install-assembly","text":"Install Assembly with pip install assembly It is highly recommended to use a virtualenv, in this case let's use VirtualenvWrapper (you can use any that is convenient for you) mkvirtualenv my - first - app workon my - first - app pip install assembly","title":"1. Install Assembly"},{"location":"#2-initialize-your-application","text":"Initialize Assembly with asm-admin init CD into the folder you intend to create the application, then run asm-admin init . This will setup the structure along with the necessary files to get started cd app - dir asm - admin init Upon initialization you should have a structure similar to this: -- / |- wsgi . py |- config . py |- requirements . txt |- main |- __init__ . py |- __models__ . py |- templates |- Index |- index . html |- layouts |- base . html |- static |- cli . py |- __data__ /","title":"2. Initialize your application"},{"location":"#3-edit-your-first-view","text":"# main/__init__.py from assembly import ( Assembly , response ) class Index ( Assembly ): index ( self ): return { \"title\" : \"Assembly is awesome\" , \"content\" : \"That is a true fact\" } @response.json api ( self ): return { \"name\" : \"Assembly\" , \"version\" : \"x-to-infinity\" }","title":"3. Edit your first view"},{"location":"#4-edit-your-template","text":"","title":"4. Edit your template"},{"location":"#40-edit-base-layout","text":"<!-- main/templates/layouts/base.html --> <!doctype html> <html lang= \"en\" > <head> <title> {% block title %}{% endblock %} </title> </head> <body> <div class= \"container\" > {% block body %}{% endblock %} </div> </body> </html>","title":"4.0 Edit base layout"},{"location":"#41-edit-indexindexhtml","text":"<!-- main/templates/Index/index.html --> {% extends 'main/layouts/base.html' %} {% block title %} Welcome to my Assembly Site {% endblock %} {% block body %} <div> <h1> {{ title }} </h1> </div> <div> {{ content }} </div> {% endblock %}","title":"4.1  Edit Index/index.html"},{"location":"#5-serve-your-first-application","text":"If everything is all set, all you need to do now is run your site: asm - admin serve It will start serving your application by default at 127.0.0.1:5000 Two endpoints will be available: http://127.0.0.1:5000/ which will show an HTML http://127.0.0.1:5000/api/ which will a json response","title":"5. Serve your first application"},{"location":"#features-list","text":"Smart routing: automatically generates routes based on the classes and methods in your views Class name as the base url, ie: class UserAccount will be accessed at '/user-account' Class methods (action) could be accessed: hello_world(self) becomes 'hello-world' Easy rending and render decorator Auto route can be edited with @route() Restful: GET, POST, PUT, DELETE REST API Ready Markdown friendly. Inclusion of a markdown file will turn into HTML BCRYPT is chosen as the password hasher Session: Redis, AWS S3, Google Storage, SQLite, MySQL, PostgreSQL Database/ORM: Active-Alchemy (SQLALchemy wrapper) CSRF on all POST Storage: Local, S3, Google Storage Flask-Cloudy Mailer (SES or SMTP) Arrow for date and time Caching JWT Pagination Signals: to dispatch messages and data to other part of the application Markdown Jinja2 for templating language Multi application Web Assets CLI Local server Credits: Flask, Flask-Classy","title":"Features List"},{"location":"first-app/","text":"If you haven't done so yet, you need to mocha :init in the directory that you want to install mocha : init Once created, you should see a file structure similar to this / ____ | |- brew . py | |- propel . yml | | -- requirements.txt | | -- /application | | -- config.py | | -- models.py | | -- helpers.py | | -- manage.py | | -- views/ | | -- main.py | | -- templates/ | | -- layouts/ | | -- base.jade | | -- main/ | | -- Index/ | | -- index.jade | | -- /static/ | | -- assets.yml | | -- package.json | | -- css/ | | -- js/ | | -- imgs/ | | -- /var/ Description: brew.py is the application entry point propel.yml (optional) A deploy based config file requirements.txt contains your requirements + mocha application/ contains the application's models, config, helpers and manage application/views/ : contains your views modules application/templates/ : contains all templates relative to the views name application/static/ : contains all the app's assets: js, css, imgs, etc... application/var/ : contains var files: database, mail-template, uploads, etc... Your first app Here's what Mocha will do, and expecting: that your views are structured in class the class inherits mocha.Mocha if the class name is Index(Mocha) , it will be the base route as / the methods are the views actions the methods name will become the endpoint url if the method name is index(self) , it will be the entry point of that view methods name with underscore will be dasherized, about_us(self) -> /about-us/ the methods return data as dict type the data returned is passed to your template the template is named after the method name the template is magically included in your layout Mocha brews everything together, and renders the page Views All your view module should be placed in application/views . By default , main.py view is created main.py must contain at a least one class that inherits Mocha . A view module may have multiple classes application/views/main.py from mocha import Mocha , page_attr class Index ( Mocha ): def index ( self ): page_attr ( \"Hello World\" ) return { \"name\" : \"Mocha\" , \"version\" : \"1.0\" } def about_us ( self ): page_attr ( \"About Us\" ) return class Document ( Mocha ): def index ( self ): page_attr ( 'All documents' ) return { \"docs\" : [ { \"id\" : 1 , \"title\" : \"This is a doc title\" }, ... ] } def get ( self , id ): page_attr ( \"This is a doc title\" ) return { \"id\" : id , \"title\" : \"This is a doc title\" , \"content\" : \"My content\" } The main.py module contains two view classes: Index and Document that inherit Mocha . Also imported page_attr , a utility function to set the page title and other page attributes The methods return dict or None The route will be created from the class and method name. If the class name is Index , it will be the root of the domain, in this example / , and other will stay as is, in this instance the Document will have as route /document/ . The following url will be created: Index:index() -> http://localhost:5000/ Index:about_us() -> http://localhost:5000/about-us Document:index() -> http://localhost:5000/document Document:get(id) -> http://localhost:5000/document/1234 Template All your templates should be placed in application/templates . And must follow the same directory structure relative to the view modules. The returned data from the view will be passed to the template. So for application/views/main.py , it is expecting the following template structure / application | | -- templates | | | -- main/ | | -- Index/ | | -- index.jade | | -- about_us.jade | | __ Document / | | -- index.jade | | -- get.jade As you can see, the template structure follows the view structure, where in the view: main.py -> /templates/main main.py:Index() -> templates/main/Index main.py:Index(Mocha):index(self) -> templates/main/Index/index.jade main.py:Index(Mocha):about_us(self) -> templates/main/Index/about_us.jade main.py:Document() -> templates/main/Document main.py:Document(Mocha):index(self) -> templates/main/Document/index.jade main.py:Document(Mocha):get(self) -> templates/main/Document/get.jade Also, you may have noticed that we use .jade template instead of HTML, just for aesthetic, as it looks like python on the templates side. But HTML can also be used. templates/main/Index/index.jade .row .col-md-12.text-center h2 = name small = version Which will be translated into html <div class= \"row\" > <div class= \"col-md-12 text-center\" > <h2> Mocha <small> 1.0 </small></h2> </div> </div> templates/main/Document/index.jade . row . col - md - 12 ul for doc in docs li : a ( href = url_for ( ' views.main.Document:get ' , id = doc . id )) = doc . title Will be translated into html <div class= \"row\" > <div class= \"col-md-12\" > <ul> <li><a href= '/document/1' > This is a doc title </a></li> </ul> </div> </div> Layout By default, layouts are placed in application/templates/layouts , and upon rendering Mocha will glue your view in the layout. The default layout is at: application/templates/layouts/base.jade While you can have extends in your templates, Mocha makes it easy to bypass the repetitive tasks, so you can fully focus on that one page you are working on. - import \"contrib/components/html.html\" as html with context - import \"contrib/components/nav.jade\" as nav with context - import \"contrib/components/forms.html\" as forms with context - import \"contrib/components/widget.html\" as widget with context !!! 5 html ( lang = \"en\" ) head meta ( charset = \"utf-8\" ) meta ( name = \"viewport\" , content = \"width=device-width, initial-scale=1.0\" ) + html . page_title () + html . page_description () + html . opengraph () + html . favicon ( \"favicon.ico\" ) + html . include_jquery () + html . include_bootstrap () + html . include_fontawesome () + html . include_bootswatch_theme ( 'yeti' ) + html . include_css_file ( \"commons.css\" ) + html . include_css_file ( \"styles.css\" ) + html . include_js_file ( \"app.js\" ) + html . google_analytics () body . container - include __template__ footer . container - fluid . row . col - md - 12 . text - center . & copy ; {{ g . __YEAR__ }} {{ config . APPLICATION_NAME }} {{ config . APPLICATION_VERSION }} The most important part of the layout is include __template__ . This where the view template will be injected. There are much more stuff going on it the template, we can tackle them later. Static Static hold your assets: js, css, images. They must be placed in /application/static/ Mocha uses Flask-Assets to manage your assets. Therefor assets.yml is a bundle collection, that allows you to bundle css or js together. assets.yml styles . css : output : \"gen/styles.css\" contents : - css / style . css app . js : output : \"gen/app.js\" contents : - js / app . js And in your template you can call it + html . include_css_file ( \"style.css\" ) + html . include_js_file ( \"app.js\" ) As a convenience, we include a package.json if you want to download 3rd party scripts (js, css). You can either run npm install in static directory, or run mocha :install-assets , which will install your assets in the node_modules Serve Now we are done with our application, all we need to do is serve it. mocha : serve The command above will run brew.py brew.py is the entry point of the application. from mocha import Brew projects = { \"main\" : [ \"main\" ] } app = Brew ( __name__ , projects ) projects is a dict containing all the views to be used. Let's say if we had the views: main.py , account.py , music.py , books.py We could put them into one projects = { \"main\" : [ \"main\" , \"account\" , \"music\" , \"books\" ] } Upon serving the app, it would make all the endpoints available. Let's say we want to run multiple application projects = { \"main\" : [ \"main\" , \"account\" ], \"library\" : [ \"music\" , \"books\" ] } Now we have 2 applications: main and library By default, Mocha will default to main mocha : serve But to run library app = library mocha : serve If two apps are running at the same time, you may need to specify a different port app = library mocha : serve --port 5001","title":"First app"},{"location":"first-app/#your-first-app","text":"Here's what Mocha will do, and expecting: that your views are structured in class the class inherits mocha.Mocha if the class name is Index(Mocha) , it will be the base route as / the methods are the views actions the methods name will become the endpoint url if the method name is index(self) , it will be the entry point of that view methods name with underscore will be dasherized, about_us(self) -> /about-us/ the methods return data as dict type the data returned is passed to your template the template is named after the method name the template is magically included in your layout Mocha brews everything together, and renders the page","title":"Your first app"},{"location":"first-app/#views","text":"All your view module should be placed in application/views . By default , main.py view is created main.py must contain at a least one class that inherits Mocha . A view module may have multiple classes application/views/main.py from mocha import Mocha , page_attr class Index ( Mocha ): def index ( self ): page_attr ( \"Hello World\" ) return { \"name\" : \"Mocha\" , \"version\" : \"1.0\" } def about_us ( self ): page_attr ( \"About Us\" ) return class Document ( Mocha ): def index ( self ): page_attr ( 'All documents' ) return { \"docs\" : [ { \"id\" : 1 , \"title\" : \"This is a doc title\" }, ... ] } def get ( self , id ): page_attr ( \"This is a doc title\" ) return { \"id\" : id , \"title\" : \"This is a doc title\" , \"content\" : \"My content\" } The main.py module contains two view classes: Index and Document that inherit Mocha . Also imported page_attr , a utility function to set the page title and other page attributes The methods return dict or None The route will be created from the class and method name. If the class name is Index , it will be the root of the domain, in this example / , and other will stay as is, in this instance the Document will have as route /document/ . The following url will be created: Index:index() -> http://localhost:5000/ Index:about_us() -> http://localhost:5000/about-us Document:index() -> http://localhost:5000/document Document:get(id) -> http://localhost:5000/document/1234","title":"Views"},{"location":"first-app/#template","text":"All your templates should be placed in application/templates . And must follow the same directory structure relative to the view modules. The returned data from the view will be passed to the template. So for application/views/main.py , it is expecting the following template structure / application | | -- templates | | | -- main/ | | -- Index/ | | -- index.jade | | -- about_us.jade | | __ Document / | | -- index.jade | | -- get.jade As you can see, the template structure follows the view structure, where in the view: main.py -> /templates/main main.py:Index() -> templates/main/Index main.py:Index(Mocha):index(self) -> templates/main/Index/index.jade main.py:Index(Mocha):about_us(self) -> templates/main/Index/about_us.jade main.py:Document() -> templates/main/Document main.py:Document(Mocha):index(self) -> templates/main/Document/index.jade main.py:Document(Mocha):get(self) -> templates/main/Document/get.jade Also, you may have noticed that we use .jade template instead of HTML, just for aesthetic, as it looks like python on the templates side. But HTML can also be used. templates/main/Index/index.jade .row .col-md-12.text-center h2 = name small = version Which will be translated into html <div class= \"row\" > <div class= \"col-md-12 text-center\" > <h2> Mocha <small> 1.0 </small></h2> </div> </div> templates/main/Document/index.jade . row . col - md - 12 ul for doc in docs li : a ( href = url_for ( ' views.main.Document:get ' , id = doc . id )) = doc . title Will be translated into html <div class= \"row\" > <div class= \"col-md-12\" > <ul> <li><a href= '/document/1' > This is a doc title </a></li> </ul> </div> </div>","title":"Template"},{"location":"first-app/#layout","text":"By default, layouts are placed in application/templates/layouts , and upon rendering Mocha will glue your view in the layout. The default layout is at: application/templates/layouts/base.jade While you can have extends in your templates, Mocha makes it easy to bypass the repetitive tasks, so you can fully focus on that one page you are working on. - import \"contrib/components/html.html\" as html with context - import \"contrib/components/nav.jade\" as nav with context - import \"contrib/components/forms.html\" as forms with context - import \"contrib/components/widget.html\" as widget with context !!! 5 html ( lang = \"en\" ) head meta ( charset = \"utf-8\" ) meta ( name = \"viewport\" , content = \"width=device-width, initial-scale=1.0\" ) + html . page_title () + html . page_description () + html . opengraph () + html . favicon ( \"favicon.ico\" ) + html . include_jquery () + html . include_bootstrap () + html . include_fontawesome () + html . include_bootswatch_theme ( 'yeti' ) + html . include_css_file ( \"commons.css\" ) + html . include_css_file ( \"styles.css\" ) + html . include_js_file ( \"app.js\" ) + html . google_analytics () body . container - include __template__ footer . container - fluid . row . col - md - 12 . text - center . & copy ; {{ g . __YEAR__ }} {{ config . APPLICATION_NAME }} {{ config . APPLICATION_VERSION }} The most important part of the layout is include __template__ . This where the view template will be injected. There are much more stuff going on it the template, we can tackle them later.","title":"Layout"},{"location":"first-app/#static","text":"Static hold your assets: js, css, images. They must be placed in /application/static/ Mocha uses Flask-Assets to manage your assets. Therefor assets.yml is a bundle collection, that allows you to bundle css or js together. assets.yml styles . css : output : \"gen/styles.css\" contents : - css / style . css app . js : output : \"gen/app.js\" contents : - js / app . js And in your template you can call it + html . include_css_file ( \"style.css\" ) + html . include_js_file ( \"app.js\" ) As a convenience, we include a package.json if you want to download 3rd party scripts (js, css). You can either run npm install in static directory, or run mocha :install-assets , which will install your assets in the node_modules","title":"Static"},{"location":"first-app/#serve","text":"Now we are done with our application, all we need to do is serve it. mocha : serve The command above will run brew.py brew.py is the entry point of the application. from mocha import Brew projects = { \"main\" : [ \"main\" ] } app = Brew ( __name__ , projects ) projects is a dict containing all the views to be used. Let's say if we had the views: main.py , account.py , music.py , books.py We could put them into one projects = { \"main\" : [ \"main\" , \"account\" , \"music\" , \"books\" ] } Upon serving the app, it would make all the endpoints available. Let's say we want to run multiple application projects = { \"main\" : [ \"main\" , \"account\" ], \"library\" : [ \"music\" , \"books\" ] } Now we have 2 applications: main and library By default, Mocha will default to main mocha : serve But to run library app = library mocha : serve If two apps are running at the same time, you may need to specify a different port app = library mocha : serve --port 5001","title":"Serve"},{"location":"install/","text":"Installation Requirements Python 3.6+ Virtualenv Install pip install assembly Setup assembly : init Serve assembly : serve","title":"Installation"},{"location":"install/#installation","text":"Requirements Python 3.6+ Virtualenv","title":"Installation"},{"location":"install/#install","text":"pip install assembly","title":"Install"},{"location":"install/#setup","text":"assembly : init","title":"Setup"},{"location":"install/#serve","text":"assembly : serve","title":"Serve"},{"location":"tutorial/","text":"","title":"Tutorial"},{"location":"X/pagination/","text":"Import from mocha import paginate Usage","title":"Pagination"},{"location":"X/setup/","text":"In here we're going to install, init and serve our Mocha application Install The best way to install Mocha is to do it with pip. pip install mocha It's preferable to install your Mocha app into it's own virtual environment. Init Once installed, use the command line mocha to initiate the application. Make sure that you cd into the right directory to run the command, as it will place the data in the current working dir. So run: mocha : init It will create all the necessary files to get going, and you should see a file structure similar to the one below / ____ | |- brew . py | |- propel . yml | | -- requirements.txt | | -- /application | | -- config.py | | -- models.py | | -- helpers.py | | -- manage.py | | -- views/ | | -- main.py | | -- templates/ | | -- layouts/ | | -- base.jade | | -- main/ | | -- Index/ | | -- index.jade | | -- /static/ | | -- assets.yml | | -- package.json | | -- css/ | | -- js/ | | -- imgs/ | | -- /var/ Description: brew.py is the application entry point propel.yml (optional) A deploy based config file requirements.txt contains your requirements + mocha application/ contains the application's models, config, helpers and manage application/views/ : contains your views modules application/templates/ : contains all templates relative to the views name application/static/ : contains all the app's assets: js, css, imgs, etc... application/var/ : contains var files: database, mail-template, uploads, etc... Serve Now your Mocha app is ready to go, it's time to serve it. mocha : serve You can access by default the application at: http://localhost:5000 To serve on a different port: mocha : serve -- port 5001 -> http://localhost:5001","title":"Setup"},{"location":"X/setup/#install","text":"The best way to install Mocha is to do it with pip. pip install mocha It's preferable to install your Mocha app into it's own virtual environment.","title":"Install"},{"location":"X/setup/#init","text":"Once installed, use the command line mocha to initiate the application. Make sure that you cd into the right directory to run the command, as it will place the data in the current working dir. So run: mocha : init It will create all the necessary files to get going, and you should see a file structure similar to the one below / ____ | |- brew . py | |- propel . yml | | -- requirements.txt | | -- /application | | -- config.py | | -- models.py | | -- helpers.py | | -- manage.py | | -- views/ | | -- main.py | | -- templates/ | | -- layouts/ | | -- base.jade | | -- main/ | | -- Index/ | | -- index.jade | | -- /static/ | | -- assets.yml | | -- package.json | | -- css/ | | -- js/ | | -- imgs/ | | -- /var/ Description: brew.py is the application entry point propel.yml (optional) A deploy based config file requirements.txt contains your requirements + mocha application/ contains the application's models, config, helpers and manage application/views/ : contains your views modules application/templates/ : contains all templates relative to the views name application/static/ : contains all the app's assets: js, css, imgs, etc... application/var/ : contains var files: database, mail-template, uploads, etc...","title":"Init"},{"location":"X/setup/#serve","text":"Now your Mocha app is ready to go, it's time to serve it. mocha : serve You can access by default the application at: http://localhost:5000 To serve on a different port: mocha : serve -- port 5001 -> http://localhost:5001","title":"Serve"},{"location":"_partials/file-structure/","text":"/ ____ | |- brew . py | |- propel . yml | | -- requirements.txt | | -- /application | | -- config.py | | -- models.py | | -- helpers.py | | -- manage.py | | -- views/ | | -- main.py | | -- templates/ | | -- layouts/ | | -- base.jade | | -- main/ | | -- Index/ | | -- index.jade | | -- /static/ | | -- assets.yml | | -- package.json | | -- css/ | | -- js/ | | -- imgs/ | | -- /var/ Description: brew.py is the application entry point propel.yml (optional) A deploy based config file requirements.txt contains your requirements + mocha application/ contains the application's models, config, helpers and manage application/views/ : contains your views modules application/templates/ : contains all templates relative to the views name application/static/ : contains all the app's assets: js, css, imgs, etc... application/var/ : contains var files: database, mail-template, uploads, etc...","title":"File structure"},{"location":"_xviews/","text":"Location: /application/views Examples from mocha import Mocha class Index ( Mocha ): def index ( self ): return","title":"Home"},{"location":"_xviews/abort/","text":"","title":"Abort"},{"location":"_xviews/decorators/","text":"Decorators Mocha exposes decorators to simplify your app development Render Cache Flask-Caching is used for caching cache from mocha.ext import cache class Index ( Mocha ): @cache.cached ( 500 ) def my_cache_view ( self ): return memoize CSRF All POST methods are required to receive _csrf_token from the application. It it fails, the user will not be able to use it. exempt_csrf In some cases you will want to bypass a POST method CSRF check, to do, we have to exempt that method from mocha.ext import csrf import mocha.decorators as deco class Index ( Mocha ): @csrf.exempt @deco.accept_post def my_exempted_csrf_post ( self ): return nav_menu @nav_menu creates a navigation menu for UI from mocha import nav_menu view_parser @view_parser from mocha import view_parser","title":"Decorators"},{"location":"_xviews/decorators/#decorators","text":"Mocha exposes decorators to simplify your app development","title":"Decorators"},{"location":"_xviews/decorators/#render","text":"","title":"Render"},{"location":"_xviews/decorators/#cache","text":"Flask-Caching is used for caching","title":"Cache"},{"location":"_xviews/decorators/#cache_1","text":"from mocha.ext import cache class Index ( Mocha ): @cache.cached ( 500 ) def my_cache_view ( self ): return","title":"cache"},{"location":"_xviews/decorators/#memoize","text":"","title":"memoize"},{"location":"_xviews/decorators/#csrf","text":"All POST methods are required to receive _csrf_token from the application. It it fails, the user will not be able to use it.","title":"CSRF"},{"location":"_xviews/decorators/#exempt_csrf","text":"In some cases you will want to bypass a POST method CSRF check, to do, we have to exempt that method from mocha.ext import csrf import mocha.decorators as deco class Index ( Mocha ): @csrf.exempt @deco.accept_post def my_exempted_csrf_post ( self ): return","title":"exempt_csrf"},{"location":"_xviews/decorators/#nav_menu","text":"@nav_menu creates a navigation menu for UI from mocha import nav_menu","title":"nav_menu"},{"location":"_xviews/decorators/#view_parser","text":"@view_parser from mocha import view_parser","title":"view_parser"},{"location":"_xviews/helpers/","text":"Utils are functions or objects that are exposed to the applications. They can be shortcuts, or from Flask itself. Some of them may extend some functionalities. config page_attr send_mail get_env set_env get_env_app get_env_config models views register_package init_app import_module register_models send_mail upload storage","title":"Helpers"},{"location":"_xviews/helpers/#config","text":"","title":"config"},{"location":"_xviews/helpers/#page_attr","text":"","title":"page_attr"},{"location":"_xviews/helpers/#send_mail","text":"","title":"send_mail"},{"location":"_xviews/helpers/#get_env","text":"","title":"get_env"},{"location":"_xviews/helpers/#set_env","text":"","title":"set_env"},{"location":"_xviews/helpers/#get_env_app","text":"","title":"get_env_app"},{"location":"_xviews/helpers/#get_env_config","text":"","title":"get_env_config"},{"location":"_xviews/helpers/#models","text":"","title":"models"},{"location":"_xviews/helpers/#views","text":"","title":"views"},{"location":"_xviews/helpers/#register_package","text":"","title":"register_package"},{"location":"_xviews/helpers/#init_app","text":"","title":"init_app"},{"location":"_xviews/helpers/#import_module","text":"","title":"import_module"},{"location":"_xviews/helpers/#register_models","text":"","title":"register_models"},{"location":"_xviews/helpers/#send_mail_1","text":"","title":"send_mail"},{"location":"_xviews/helpers/#upload","text":"","title":"upload"},{"location":"_xviews/helpers/#storage","text":"","title":"storage"},{"location":"_xviews/logging/","text":"Configuration","title":"Logging"},{"location":"_xviews/logging/#configuration","text":"","title":"Configuration"},{"location":"_xviews/redirect/","text":"As it is in Flask, redirect just redirects to another endpoint or url. However, Mocha put a little bit of convenience in, by doing self reference or Import from mocha import redirect Usage class Index ( Mocha ) : def index ( self ) : pass def post ( self ) : return redirect ( self . index ) With other views If you will be redirecting in views that are not in the same module, yo will need to import the views object along with redirect from mocha import redirect , views Usage # views/main.py from mocha import redirect , views , request class Index ( Mocha ): @request.post def save_data (): return redirect ( views . account . Index . info ) - # views / account . py @request . route ( \"/account\" ) class Index ( Mocha ) : def index ( self ) : pass def info ( self ) : pass","title":"Redirect"},{"location":"_xviews/redirect/#import","text":"from mocha import redirect","title":"Import"},{"location":"_xviews/redirect/#usage","text":"class Index ( Mocha ) : def index ( self ) : pass def post ( self ) : return redirect ( self . index )","title":"Usage"},{"location":"_xviews/redirect/#with-other-views","text":"If you will be redirecting in views that are not in the same module, yo will need to import the views object along with redirect from mocha import redirect , views","title":"With other views"},{"location":"_xviews/redirect/#usage_1","text":"# views/main.py from mocha import redirect , views , request class Index ( Mocha ): @request.post def save_data (): return redirect ( views . account . Index . info ) - # views / account . py @request . route ( \"/account\" ) class Index ( Mocha ) : def index ( self ) : pass def info ( self ) : pass","title":"Usage"},{"location":"_xviews/render/","text":"This module contains decorators that will alter the rendering of the view. It can change the response, or add new elements on the page, ie: json will turn the endpoint into a json response, while template will change the default template page to display, and nav will create a menu title. Import from mocha import render Response By default, the responses will render normal HTML. But if you want to return JSON, or XML data, the methods below will conveniently help you do that. N.B.: The methods must return DICT for them to benefit from multiple response format json It return a dict into JSON. Good for API endpoint. class Index ( Mocha ) : @ render . json def my_data ( self ) : return { \" name \" : \" Mocha \" , \" version \" : \" xxx \" } jsonp It return a dict into JSON for JSONP. class Index ( Mocha ) : @ render . jsonp def my_data ( self ) : return { \" name \" : \" Mocha \" , \" version \" : \" xxx \" } xml It return a dict into XML. class Index ( Mocha ) : @ render . xml def my_data ( self ) : return { \" name \" : \" Mocha \" , \" version \" : \" xxx \" } html There is no decorator for HTML, as it will fall back to it if a view is not decorated with json or xml Template This decorator allows you to change the view template or layout It can be applied on both class based or method based Params: template(page, markup=\"jade\") page: the path of the new layout or template markup: the markup to use for all pages: jade or html Class based This will change the default layout to another one. @ render . template ( ' /layouts/my-new-layouts.jade ' ) class Index ( Mocha ) : def index ( self ) : return def hello ( self ) : return Method based By default the template for method is based on its name, to use a different template, specify the full path class Index ( Mocha ) : def index ( self ) : return @ render . template ( ' /my-path/new-world.html ' , markup = ' html ' ) def hello ( self ) : return Navigation","title":"Render"},{"location":"_xviews/render/#import","text":"from mocha import render","title":"Import"},{"location":"_xviews/render/#response","text":"By default, the responses will render normal HTML. But if you want to return JSON, or XML data, the methods below will conveniently help you do that. N.B.: The methods must return DICT for them to benefit from multiple response format","title":"Response"},{"location":"_xviews/render/#json","text":"It return a dict into JSON. Good for API endpoint. class Index ( Mocha ) : @ render . json def my_data ( self ) : return { \" name \" : \" Mocha \" , \" version \" : \" xxx \" }","title":"json"},{"location":"_xviews/render/#jsonp","text":"It return a dict into JSON for JSONP. class Index ( Mocha ) : @ render . jsonp def my_data ( self ) : return { \" name \" : \" Mocha \" , \" version \" : \" xxx \" }","title":"jsonp"},{"location":"_xviews/render/#xml","text":"It return a dict into XML. class Index ( Mocha ) : @ render . xml def my_data ( self ) : return { \" name \" : \" Mocha \" , \" version \" : \" xxx \" }","title":"xml"},{"location":"_xviews/render/#html","text":"There is no decorator for HTML, as it will fall back to it if a view is not decorated with json or xml","title":"html"},{"location":"_xviews/render/#template","text":"This decorator allows you to change the view template or layout It can be applied on both class based or method based Params: template(page, markup=\"jade\") page: the path of the new layout or template markup: the markup to use for all pages: jade or html","title":"Template"},{"location":"_xviews/render/#class-based","text":"This will change the default layout to another one. @ render . template ( ' /layouts/my-new-layouts.jade ' ) class Index ( Mocha ) : def index ( self ) : return def hello ( self ) : return","title":"Class based"},{"location":"_xviews/render/#method-based","text":"By default the template for method is based on its name, to use a different template, specify the full path class Index ( Mocha ) : def index ( self ) : return @ render . template ( ' /my-path/new-world.html ' , markup = ' html ' ) def hello ( self ) : return","title":"Method based"},{"location":"_xviews/render/#navigation","text":"","title":"Navigation"},{"location":"_xviews/route/","text":"Allows you to apply a route on a view class or a single method Import from mocha import request Class based When applied to a view class, all methods will be prefixed with the toute The following code will use the /account/ route, and /account/hello @request . route ( \"/account/\" ) class Index ( Mocha ) : def index ( self ) : pass def hello ( self ) : pass Method based Method based route only applies the route to the method. The code below will expose /hello-world . By default Index and index will reference to the root, unless a route is applied class Index ( Mocha ) : def index ( self ) : pass @request . route ( \"hello-world\" ) def hello ( self ) : pass Class and Method You can combine both class and method based. The code below will now be accessed at: /account/ , /account/hello-world @request . route ( \"/account/\" ) class Index ( Mocha ) : def index ( self ) : pass @request . route ( \"/hello-world\" ) def hello ( self ) : pass","title":"Route"},{"location":"_xviews/route/#import","text":"from mocha import request","title":"Import"},{"location":"_xviews/route/#class-based","text":"When applied to a view class, all methods will be prefixed with the toute The following code will use the /account/ route, and /account/hello @request . route ( \"/account/\" ) class Index ( Mocha ) : def index ( self ) : pass def hello ( self ) : pass","title":"Class based"},{"location":"_xviews/route/#method-based","text":"Method based route only applies the route to the method. The code below will expose /hello-world . By default Index and index will reference to the root, unless a route is applied class Index ( Mocha ) : def index ( self ) : pass @request . route ( \"hello-world\" ) def hello ( self ) : pass","title":"Method based"},{"location":"_xviews/route/#class-and-method","text":"You can combine both class and method based. The code below will now be accessed at: /account/ , /account/hello-world @request . route ( \"/account/\" ) class Index ( Mocha ) : def index ( self ) : pass @request . route ( \"/hello-world\" ) def hello ( self ) : pass","title":"Class and Method"},{"location":"_xviews/session-flash/","text":"Session Mocha natively uses Flask session, with the addition of having the ability to use as backend either: Redis, Memcache, S3, CloudStorage Config #: SESSION #: Flask - KVSession is used to save the user ' s session #: Set the SESSION_URL by using these examples below to set KVSession #: To use local session , just set SESSION_URL to None #: #: Redis : redis : // username : password @host : 6379 / db #: S3 : s3 : // username : password @s3 . aws . amazon . com / bucket #: Google Storage : google_storage : // username : password @cloud . google . com / bucket #: SQL : postgresql : // username : password @host : 3306 / db #: mysql + pysql : // username : password @host : 3306 / db #: sqlite : // #: Memcached : memcache : // host : port #: SESSION_URL = None Usage from mocha import session Flash The Flash provides single-use string storage. It useful for implementing the Post/Redirect/Get pattern, or for transient \"Operation Successful!\" or \"Operation Failed!\" messages You can import the flash as is, but for convenience, we provided some special message pattern: flash_info , flash_success , flash_error to indicate a info, success and error message respectively. Flash Message Import from mocha import flash_info , flash_success , flash_error Usage class Index ( Mocha ) : def index ( self ) : flash_info ( \" You need to provide your account info \" ) return def post ( self ) : try : # do something flash_success ( ' Account info saved successfully! ' ) except Exception as ex : flash_error ( ' An error occured while saving your info ' ) return redirect ( self . index ) Flash Data Same as flash message, you can also flash data Import from mocha import flash_data , get_flash_data Usage class Index ( Mocha ): def index ( self ): flash_data ({ \"temp\" : 70 }) def get ( self , id ): temp = get_flash_data (). get ( \"temp\" )","title":"Session flash"},{"location":"_xviews/session-flash/#session","text":"Mocha natively uses Flask session, with the addition of having the ability to use as backend either: Redis, Memcache, S3, CloudStorage","title":"Session"},{"location":"_xviews/session-flash/#config","text":"#: SESSION #: Flask - KVSession is used to save the user ' s session #: Set the SESSION_URL by using these examples below to set KVSession #: To use local session , just set SESSION_URL to None #: #: Redis : redis : // username : password @host : 6379 / db #: S3 : s3 : // username : password @s3 . aws . amazon . com / bucket #: Google Storage : google_storage : // username : password @cloud . google . com / bucket #: SQL : postgresql : // username : password @host : 3306 / db #: mysql + pysql : // username : password @host : 3306 / db #: sqlite : // #: Memcached : memcache : // host : port #: SESSION_URL = None","title":"Config"},{"location":"_xviews/session-flash/#usage","text":"from mocha import session","title":"Usage"},{"location":"_xviews/session-flash/#flash","text":"The Flash provides single-use string storage. It useful for implementing the Post/Redirect/Get pattern, or for transient \"Operation Successful!\" or \"Operation Failed!\" messages You can import the flash as is, but for convenience, we provided some special message pattern: flash_info , flash_success , flash_error to indicate a info, success and error message respectively.","title":"Flash"},{"location":"_xviews/session-flash/#flash-message","text":"","title":"Flash Message"},{"location":"_xviews/session-flash/#import","text":"from mocha import flash_info , flash_success , flash_error","title":"Import"},{"location":"_xviews/session-flash/#usage_1","text":"class Index ( Mocha ) : def index ( self ) : flash_info ( \" You need to provide your account info \" ) return def post ( self ) : try : # do something flash_success ( ' Account info saved successfully! ' ) except Exception as ex : flash_error ( ' An error occured while saving your info ' ) return redirect ( self . index )","title":"Usage"},{"location":"_xviews/session-flash/#flash-data","text":"Same as flash message, you can also flash data","title":"Flash Data"},{"location":"_xviews/session-flash/#import_1","text":"from mocha import flash_data , get_flash_data","title":"Import"},{"location":"_xviews/session-flash/#usage_2","text":"class Index ( Mocha ): def index ( self ): flash_data ({ \"temp\" : 70 }) def get ( self , id ): temp = get_flash_data (). get ( \"temp\" )","title":"Usage"},{"location":"_xviews/url_for/","text":"url_for use a view endpoint to create a full url Mocha adds a little flavor in it, to reference other views by their reference. Import from mocha import url_for Usage class Index ( Mocha ) : def index ( self ) : doc_1_url = url_for ( self . doc , id = 1 ) full_url_account_info = url_for ( views . account . Index . info , _external = True ) return { \" urls \" : { \" doc_1 \" : doc_1_url , \" full_url \" : full_url_account_info } } def doc ( self , id ) : pass","title":"Url for"},{"location":"_xviews/url_for/#import","text":"from mocha import url_for","title":"Import"},{"location":"_xviews/url_for/#usage","text":"class Index ( Mocha ) : def index ( self ) : doc_1_url = url_for ( self . doc , id = 1 ) full_url_account_info = url_for ( views . account . Index . info , _external = True ) return { \" urls \" : { \" doc_1 \" : doc_1_url , \" full_url \" : full_url_account_info } } def doc ( self , id ) : pass","title":"Usage"},{"location":"advanced/flash/","text":"","title":"Flash"},{"location":"advanced/sessions/","text":"from assembly import session","title":"Sessions"},{"location":"advanced/signals/","text":"Mocha uses Blinker to provide a fast dispatching system that allows any number of interested parties to subscribe to events, or \u201csignals\u201d. As it will be described below, a best way to use signal is to dispatch data/message between modules. For example, when a user register using the built-in AUTH, you may want to do something with that new user. So the create_user emit a signal containing the new user data, and each function observing the create_user, will be executed Import from mocha.decorators import emit_signal Emit Signal @emit_signal A decorator that will turn a function into a signal emitter, which will contain a pre and post signal. # signals.py from mocha import decorators as deco @deco.emit_signal def do_something ( data ): return data The example above creates a signal do_something , each time this function is invoked it will emit two signals do_something.pre and do_something.post . These objects (pre, post) were created when @emit_signal decorated the do_something function. pre will be invoked before running accepting the signal, and post after the signal is executed. For every @emit_signal use, the function will have two blinker signal objects: pre and post @emit_signal def hello () : pass will now have the following decorators: @hello . post @hello . pre Receive Signal @observe @observe allows you to connect a function to an emitter. @observe is a shortcut for @post.connect . import my_signals @signals.do_something.observe def my_thing ( result , ** kw ): if result : pass To fully utilize Blinker functionalities, use post and pre , for example @do_something.post.connect , @do_something.pre.connect @post.connect @ signals . do_something . post . connect def receive_create_user ( user , ** kw ) : if user : # do something with user The function receiving the signal, must have 2 args: result: that's the result sent from the signal **kwargs: some kwargs: kwargs that were passed in the signal function sender: The name of the function emitter: The instance of the @pre.connect @ signals . do_something . pre . connect def receive_create_user_pre ( ** kw ) : # do something","title":"Signals"},{"location":"advanced/signals/#emit-signal","text":"","title":"Emit Signal"},{"location":"advanced/signals/#emit_signal","text":"A decorator that will turn a function into a signal emitter, which will contain a pre and post signal. # signals.py from mocha import decorators as deco @deco.emit_signal def do_something ( data ): return data The example above creates a signal do_something , each time this function is invoked it will emit two signals do_something.pre and do_something.post . These objects (pre, post) were created when @emit_signal decorated the do_something function. pre will be invoked before running accepting the signal, and post after the signal is executed. For every @emit_signal use, the function will have two blinker signal objects: pre and post @emit_signal def hello () : pass will now have the following decorators: @hello . post @hello . pre","title":"@emit_signal"},{"location":"advanced/signals/#receive-signal","text":"","title":"Receive Signal"},{"location":"advanced/signals/#observe","text":"@observe allows you to connect a function to an emitter. @observe is a shortcut for @post.connect . import my_signals @signals.do_something.observe def my_thing ( result , ** kw ): if result : pass To fully utilize Blinker functionalities, use post and pre , for example @do_something.post.connect , @do_something.pre.connect","title":"@observe"},{"location":"advanced/signals/#postconnect","text":"@ signals . do_something . post . connect def receive_create_user ( user , ** kw ) : if user : # do something with user The function receiving the signal, must have 2 args: result: that's the result sent from the signal **kwargs: some kwargs: kwargs that were passed in the signal function sender: The name of the function emitter: The instance of the","title":"@post.connect"},{"location":"advanced/signals/#preconnect","text":"@ signals . do_something . pre . connect def receive_create_user_pre ( ** kw ) : # do something","title":"@pre.connect"},{"location":"advanced/utils/","text":"Utils contains some common functionw and also exposes under the utils namespace some 3rd party function for convenience Import Import the utils as follow: from assembly import utils gen_md5 gen_uuid gen_uuid_hex to_json chunk_list in_any_list dict_replace list_replace DotDict is_valid_email is_valid_password is_valid_username is_valid_url lib: slugify slugify lib: inflection camelize titleize dasherize underscore plurialize singularize ordinalize ordinal","title":"Utils"},{"location":"advanced/utils/#lib-slugify","text":"slugify","title":"lib: slugify"},{"location":"advanced/utils/#lib-inflection","text":"camelize titleize dasherize underscore plurialize singularize ordinalize ordinal","title":"lib: inflection"},{"location":"application/cli/","text":"Mocha provides a command line tool to do sim asm :init Running init will initialize asm in the current directory asm : init :serve Run the server in the development mode. asm : serve By default it will run the main application in config.Dev environment To change application and environment, prepend the app before asm :serve app = main : production asm : serve The code above will run the main application with the config.Production app = admin : stage asm : serve The code above will run admin application with config.Stage env = production asm : serve The code above will run the main application with config.Production . When app is not provided, or only env is provided, it will assume the app is main :addview To create a new view asm : addview :install-assets To install assets from application/assets/package.json This command requires npm as it will run npm install to install the assets asm : install - assets :dbsync To create new models in your DBMS. asm : dbsync :assets2s3 When config.ASSETS_DELIVERY_METHOD is S3 , this util will allow you to upload your assets to S3, and the application will automatically point all your assets to S3. asm : assets2s3 Since it will be in production or some other places other than local, you may need to add the environment variables app = main : production asm : assets2s3 Develop CLI You can develop your own CLI to also attach to the asm cli. This will allow you to admin your application within one command line. Mocha provides a CLI interface using click Create import asm.cli class MyCLI ( asm . cli . CLI ): def __init__ ( self , command , click ): @command ( 'hello-world' ) def hello_world (): \"\"\" This is my hello world \"\"\" print ( \"Hello World!\" ) @command ( \"add-entry\" ) @click.argument ( \"name\" ) def add_entry ( name ): \"\"\" Add new entry \"\"\" print ( \"Name: %s \" % name ) Running asm Running the code above will show the follow Commands : : addview Create a new view and template page : assets2s3 Upload assets files to S3 : dbsync Sync database Create new tables etc ... : init Setup Mocha in the current directory : install - assets Install NPM Packages for the front end in the ... : serve Serve application in development mode : version add - entry Add new entry hello - world This is my hellow word If you run asm hello - world It will print out 'Hello World!' And... asm add - entry Jonas will print out 'Name: Jonas' How does it work? Mocha looks for all the subclasses of asm.cli.CLI and instantiate them by passing the asm.cli command scope, along with click Importing application modules in the CLI To import application modules, place them in __init__ of the class, so Mocha has the time to load all the necessary modules class MyCLI ( asm . cli . CLI ): def __init__ ( self , command , click ): import application.helpers as helpers @command ( 'hello-world' ) def hello_world (): \"\"\" This is my hello world \"\"\" print ( \"Hello World!\" )","title":"CLI"},{"location":"application/cli/#init","text":"Running init will initialize asm in the current directory asm : init","title":":init"},{"location":"application/cli/#serve","text":"Run the server in the development mode. asm : serve By default it will run the main application in config.Dev environment To change application and environment, prepend the app before asm :serve app = main : production asm : serve The code above will run the main application with the config.Production app = admin : stage asm : serve The code above will run admin application with config.Stage env = production asm : serve The code above will run the main application with config.Production . When app is not provided, or only env is provided, it will assume the app is main","title":":serve"},{"location":"application/cli/#addview","text":"To create a new view asm : addview","title":":addview"},{"location":"application/cli/#install-assets","text":"To install assets from application/assets/package.json This command requires npm as it will run npm install to install the assets asm : install - assets","title":":install-assets"},{"location":"application/cli/#dbsync","text":"To create new models in your DBMS. asm : dbsync","title":":dbsync"},{"location":"application/cli/#assets2s3","text":"When config.ASSETS_DELIVERY_METHOD is S3 , this util will allow you to upload your assets to S3, and the application will automatically point all your assets to S3. asm : assets2s3 Since it will be in production or some other places other than local, you may need to add the environment variables app = main : production asm : assets2s3","title":":assets2s3"},{"location":"application/cli/#develop-cli","text":"You can develop your own CLI to also attach to the asm cli. This will allow you to admin your application within one command line. Mocha provides a CLI interface using click","title":"Develop CLI"},{"location":"application/cli/#create","text":"import asm.cli class MyCLI ( asm . cli . CLI ): def __init__ ( self , command , click ): @command ( 'hello-world' ) def hello_world (): \"\"\" This is my hello world \"\"\" print ( \"Hello World!\" ) @command ( \"add-entry\" ) @click.argument ( \"name\" ) def add_entry ( name ): \"\"\" Add new entry \"\"\" print ( \"Name: %s \" % name )","title":"Create"},{"location":"application/cli/#running","text":"asm Running the code above will show the follow Commands : : addview Create a new view and template page : assets2s3 Upload assets files to S3 : dbsync Sync database Create new tables etc ... : init Setup Mocha in the current directory : install - assets Install NPM Packages for the front end in the ... : serve Serve application in development mode : version add - entry Add new entry hello - world This is my hellow word If you run asm hello - world It will print out 'Hello World!' And... asm add - entry Jonas will print out 'Name: Jonas'","title":"Running"},{"location":"application/cli/#how-does-it-work","text":"Mocha looks for all the subclasses of asm.cli.CLI and instantiate them by passing the asm.cli command scope, along with click","title":"How does it work?"},{"location":"application/cli/#importing-application-modules-in-the-cli","text":"To import application modules, place them in __init__ of the class, so Mocha has the time to load all the necessary modules class MyCLI ( asm . cli . CLI ): def __init__ ( self , command , click ): import application.helpers as helpers @command ( 'hello-world' ) def hello_world (): \"\"\" This is my hello world \"\"\" print ( \"Hello World!\" )","title":"Importing application modules in the CLI"},{"location":"application/config/","text":"Path: ./__config__.py . from assembly import config Assembly uses class-based configuration, and the config will be loaded upon startup. class BaseConfig ( object ) : APPLICATION_NAME = \" Assembly \" APPLICATION_URL = \"\" APPLICATION_VERSION = \" 0.0.1 \" GOOGLE_ANALYTICS_ID = \"\" ADMIN_EMAIL = None CONTACT_EMAIL = None PAGINATION_PER_PAGE = 20 ... class Development ( BaseConfig ) : \"\"\" Config for development environment \"\"\" SERVER_NAME = None DEBUG = True SECRET_KEY = \" PLEASE CHANGE ME \" class Production ( BaseConfig ) : \"\"\" Config for Production environment \"\"\" SERVER_NAME = \" abc.com \" DEBUG = False SECRET_KEY = \" My Prod Secret \" COMPRESS_HTML = True It is recommended to have a base class, BaseConfig , and your environment classes Development , Production which are subclasses of the BaseConfig , this way they can share some common config. The environment classes will be loaded on Assembly startup. By default, and in development, Assembly will attempt to load the Development if one isn't provided. To switch to a different config, you have to set the environment variable, or in production export ASSEMBLY_ENV = Production export ASSEMBLY_PROJECT = default or to set the application along with the environment ASSEMBLY_ENV = Production ASSEMBLY_PROJECT = default asm - admin serve The code above will load the Production config. One main advantage of having your config like that, is that you have the ability of using different config for different environment, could be for testing, prod, dev, etc.","title":"Config"},{"location":"application/core/","text":"\"Assembly\" , \"g\" , \"db\" , \"env\" , \"ext\" , \"date\" , \"views\" , \"flash\" , \"config\" , \"models\" , \"session\" , \"extends\" , \"url_for\" , \"redirect\" , \"HTTPError\"","title":"Core"},{"location":"application/deploy/","text":"Deployment Yes, yes, deploying Python app is not as easy as let's j. So let me introduce to you Propel I created Deploy to Production Now your application is ready, it is time to deploy in production. While there many other options, I'm more familiar with Propel and Gunicorn. With Propel propel - w On Gunicorn gunicorn app_www : app","title":"Deployment"},{"location":"application/deploy/#deployment","text":"Yes, yes, deploying Python app is not as easy as let's j. So let me introduce to you Propel I created","title":"Deployment"},{"location":"application/deploy/#deploy-to-production","text":"Now your application is ready, it is time to deploy in production. While there many other options, I'm more familiar with Propel and Gunicorn. With Propel propel - w On Gunicorn gunicorn app_www : app","title":"Deploy to Production"},{"location":"application/httperror/","text":"HTTPError from assembly import HTTPError abort BadRequest 400 Unauthorized 401 Forbidden 403 NotFound 404 MethodNotAllowed 405 NotAcceptable 406 RequestTimeout 408 Conflict 409 Gone 410 LengthRequired 411 PreconditionFailed 412 RequestEntityTooLarge 413 RequestURITooLarge 414 UnsupportedMediaType 415 RequestedRangeNotSatisfiable 416 ExpectationFailed 417 ImATeapot 418 UnprocessableEntity 422 Locked 423 FailedDependency 424 PreconditionRequired 428 TooManyRequests 429 RequestHeaderFieldsTooLarge 431 UnavailableForLegalReasons 451 InternalServerError 500 NotImplemented 501 BadGateway 502 ServiceUnavailable 503 GatewayTimeout 504 HTTPVersionNotSupported 505 ClientDisconnected SecurityError MochaError MochaError is raised when there is an error in the core of Mocha AppError class Index ( Mocha ): def error ( self ): try: # blah blah code raise exceptions . AppError ( 'Something bad happened..' ) except exceptions . MochaError as ae: flash_error ( ae . message ) ModelError","title":"HTTPError"},{"location":"application/httperror/#abort","text":"","title":"abort"},{"location":"application/httperror/#badrequest","text":"400","title":"BadRequest"},{"location":"application/httperror/#unauthorized","text":"401","title":"Unauthorized"},{"location":"application/httperror/#forbidden","text":"403","title":"Forbidden"},{"location":"application/httperror/#notfound","text":"404","title":"NotFound"},{"location":"application/httperror/#methodnotallowed","text":"405","title":"MethodNotAllowed"},{"location":"application/httperror/#notacceptable","text":"406","title":"NotAcceptable"},{"location":"application/httperror/#requesttimeout","text":"408","title":"RequestTimeout"},{"location":"application/httperror/#conflict","text":"409","title":"Conflict"},{"location":"application/httperror/#gone","text":"410","title":"Gone"},{"location":"application/httperror/#lengthrequired","text":"411","title":"LengthRequired"},{"location":"application/httperror/#preconditionfailed","text":"412","title":"PreconditionFailed"},{"location":"application/httperror/#requestentitytoolarge","text":"413","title":"RequestEntityTooLarge"},{"location":"application/httperror/#requesturitoolarge","text":"414","title":"RequestURITooLarge"},{"location":"application/httperror/#unsupportedmediatype","text":"415","title":"UnsupportedMediaType"},{"location":"application/httperror/#requestedrangenotsatisfiable","text":"416","title":"RequestedRangeNotSatisfiable"},{"location":"application/httperror/#expectationfailed","text":"417","title":"ExpectationFailed"},{"location":"application/httperror/#imateapot","text":"418","title":"ImATeapot"},{"location":"application/httperror/#unprocessableentity","text":"422","title":"UnprocessableEntity"},{"location":"application/httperror/#locked","text":"423","title":"Locked"},{"location":"application/httperror/#faileddependency","text":"424","title":"FailedDependency"},{"location":"application/httperror/#preconditionrequired","text":"428","title":"PreconditionRequired"},{"location":"application/httperror/#toomanyrequests","text":"429","title":"TooManyRequests"},{"location":"application/httperror/#requestheaderfieldstoolarge","text":"431","title":"RequestHeaderFieldsTooLarge"},{"location":"application/httperror/#unavailableforlegalreasons","text":"451","title":"UnavailableForLegalReasons"},{"location":"application/httperror/#internalservererror","text":"500","title":"InternalServerError"},{"location":"application/httperror/#notimplemented","text":"501","title":"NotImplemented"},{"location":"application/httperror/#badgateway","text":"502","title":"BadGateway"},{"location":"application/httperror/#serviceunavailable","text":"503","title":"ServiceUnavailable"},{"location":"application/httperror/#gatewaytimeout","text":"504","title":"GatewayTimeout"},{"location":"application/httperror/#httpversionnotsupported","text":"505","title":"HTTPVersionNotSupported"},{"location":"application/httperror/#clientdisconnected","text":"","title":"ClientDisconnected"},{"location":"application/httperror/#securityerror","text":"","title":"SecurityError"},{"location":"application/httperror/#mochaerror","text":"MochaError is raised when there is an error in the core of Mocha","title":"MochaError"},{"location":"application/httperror/#apperror","text":"class Index ( Mocha ): def error ( self ): try: # blah blah code raise exceptions . AppError ( 'Something bad happened..' ) except exceptions . MochaError as ae: flash_error ( ae . message )","title":"AppError"},{"location":"application/httperror/#modelerror","text":"","title":"ModelError"},{"location":"application/models/","text":"Path: $$APP_NAME/__models__.py CONVENTION By convention, Assembly expects you to have one models file per application. And the file must be named models .py , for it to be loaded automatically. Configuration db model Types Special Types Beside the default SQLAlchemy column types, SQLAlchemy-Utils DateTime Alias to ArrowType, which provides way of saving Arrow objects into database. It automatically changes Arrow objects to datetime objects on the way in and datetime objects back to Arrow objects on the way out (when querying database). Example from mocha import db class Article ( db . Model ): title = db . Column ( db . String ( 255 )) published_at = db . Column ( db . DateTime ) Create from mocha import utc_now , models models . Article . create ( title = 'Hi' , published_at = utc_now ) Read from mocha import models article = models . Article . get ( 1 ) article . created_at = article . created_at . replace ( hours =- 1 ) article . created_at . humanize () # 'an hour ago' Links ArrowType Arrow Arrow Tokens StorageObjectType StorageObjectType offers way of saving Storage.Object data structures to database. It automatically changes Arrow objects to JSON objects on the way in and Storage.Object objects back on the way out (when querying database). Example from mocha import db class Article ( db . Model ): title = db . Column ( db . String ( 255 )) published_at = db . Column ( db . DateTime ) image = db . Column ( db . StorageObjectType ) Create from mocha import utc_now , models , upload_file image_file = \"file/xyz.jpg\" image = upload_file ( image_file ) models . Article . create ( title = 'Hi' , published_at = utc_now , image = image ) Read from mocha import models article = models . Article . get ( 1 ) article . image . url article . image . size article . image . download () EmailType Provides a way for storing emails in a lower case. Example from mocha import db class Article ( db . Model ): title = db . Column ( db . String ( 255 )) published_at = db . Column ( db . DateTime ) email = db . Column ( db . EmailType ) Link: EmailType JSONType JSONType offers way of saving JSON data structures to database. On PostgreSQL the underlying implementation of this data type is \u2018json\u2019 while on other databases its simply \u2018text\u2019. Example from mocha import db class Article ( db . Model ): title = db . Column ( db . String ( 255 )) published_at = db . Column ( db . DateTime ) data = db . Column ( db . JSONType ) Create from mocha import models , utc_now models . Article . create ( title = 'Hello' , published_at = utc_now , data = { \"reference\" : \"blah\" , \"tags\" : [ \"A\" , \"B\" , \"C\" ] }) Read article = models . Article . get ( 1 ) article . data . get ( \"reference\" ) # blah article . data . get ( \"tags\" ) # [ \"A\" , \"B\" , \"C\" ] article . data . get ( \"location\" , \"Charlotte\" ) # Charlotte Link: JSONType Generic Types SQLAlchemy-Utils Types If you want to use the other types from SQLAlchemy-Utils ArrowType ChoiceType ColorType CountryType CurrencyType EmailType EncryptedType JSONType LocaleType LtreeType IPAddressType PasswordType PhoneNumberType ScalarListType TimezoneType TSVectorType URLType UUIDType WeekDaysType","title":"Models"},{"location":"application/models/#convention","text":"By convention, Assembly expects you to have one models file per application. And the file must be named models .py , for it to be loaded automatically.","title":"CONVENTION"},{"location":"application/models/#configuration","text":"","title":"Configuration"},{"location":"application/models/#db","text":"","title":"db"},{"location":"application/models/#model","text":"","title":"model"},{"location":"application/models/#types","text":"","title":"Types"},{"location":"application/models/#special-types","text":"Beside the default SQLAlchemy column types, SQLAlchemy-Utils","title":"Special Types"},{"location":"application/models/#datetime","text":"Alias to ArrowType, which provides way of saving Arrow objects into database. It automatically changes Arrow objects to datetime objects on the way in and datetime objects back to Arrow objects on the way out (when querying database). Example from mocha import db class Article ( db . Model ): title = db . Column ( db . String ( 255 )) published_at = db . Column ( db . DateTime ) Create from mocha import utc_now , models models . Article . create ( title = 'Hi' , published_at = utc_now ) Read from mocha import models article = models . Article . get ( 1 ) article . created_at = article . created_at . replace ( hours =- 1 ) article . created_at . humanize () # 'an hour ago' Links ArrowType Arrow Arrow Tokens","title":"DateTime"},{"location":"application/models/#storageobjecttype","text":"StorageObjectType offers way of saving Storage.Object data structures to database. It automatically changes Arrow objects to JSON objects on the way in and Storage.Object objects back on the way out (when querying database). Example from mocha import db class Article ( db . Model ): title = db . Column ( db . String ( 255 )) published_at = db . Column ( db . DateTime ) image = db . Column ( db . StorageObjectType ) Create from mocha import utc_now , models , upload_file image_file = \"file/xyz.jpg\" image = upload_file ( image_file ) models . Article . create ( title = 'Hi' , published_at = utc_now , image = image ) Read from mocha import models article = models . Article . get ( 1 ) article . image . url article . image . size article . image . download ()","title":"StorageObjectType"},{"location":"application/models/#emailtype","text":"Provides a way for storing emails in a lower case. Example from mocha import db class Article ( db . Model ): title = db . Column ( db . String ( 255 )) published_at = db . Column ( db . DateTime ) email = db . Column ( db . EmailType ) Link: EmailType","title":"EmailType"},{"location":"application/models/#jsontype","text":"JSONType offers way of saving JSON data structures to database. On PostgreSQL the underlying implementation of this data type is \u2018json\u2019 while on other databases its simply \u2018text\u2019. Example from mocha import db class Article ( db . Model ): title = db . Column ( db . String ( 255 )) published_at = db . Column ( db . DateTime ) data = db . Column ( db . JSONType ) Create from mocha import models , utc_now models . Article . create ( title = 'Hello' , published_at = utc_now , data = { \"reference\" : \"blah\" , \"tags\" : [ \"A\" , \"B\" , \"C\" ] }) Read article = models . Article . get ( 1 ) article . data . get ( \"reference\" ) # blah article . data . get ( \"tags\" ) # [ \"A\" , \"B\" , \"C\" ] article . data . get ( \"location\" , \"Charlotte\" ) # Charlotte Link: JSONType","title":"JSONType"},{"location":"application/models/#generic-types","text":"","title":"Generic Types"},{"location":"application/models/#sqlalchemy-utils-types","text":"If you want to use the other types from SQLAlchemy-Utils ArrowType ChoiceType ColorType CountryType CurrencyType EmailType EncryptedType JSONType LocaleType LtreeType IPAddressType PasswordType PhoneNumberType ScalarListType TimezoneType TSVectorType URLType UUIDType WeekDaysType","title":"SQLAlchemy-Utils Types"},{"location":"application/request/","text":"request is a proxy to flask.request object, with some additional decorators and attributes Import from mocha import request Methods get @request.get set a view to accept only GET method class Index ( Mocha ) : @ request . get def index ( self ) : # do something post @request.post set a view to accept only POST method class Index ( Mocha ) : @ request . post def index ( self ) : # do something put @request.put set a view to accept only PUT method class Index ( Mocha ) : @ request . put def index ( self ) : # do something delete @request.delete set a view to accept only DELETE method class Index ( Mocha ) : @ request . delete def index ( self ) : # do something all @request.all set a view to accept only ALL methods. It will accept: GET, POST, PUT, DELETE, OPTIONS class Index ( Mocha ) : @ request . all def index ( self ) : # do something Combine An alternative to @all is to use all methods as class Index ( Mocha ) : @ request . get @ request . post @ request . put @ request . delete @ request . options def index ( self ) : # do something Test Method Usually if a view method accept more than one request method, it is best to test for the method IS_GET request.IS_GET tests if the request method is GET class Index ( Mocha ) : def index ( self ) : if request . IS_GET : # do something It is equivalent to request.method == 'GET' IS_POST request.IS_GET tests if the request method is POST class Index ( Mocha ) : def index ( self ) : if request . IS_POST : # do something It is equivalent to request.method == 'POST' Same as above for PUT and DELETE IS_PUT IS_DELETE Args & Forms This is already part of Flask. It is added as a reference args request.args.get lets you get the query vars # http://127.0.0.1/?name=Mocha class Index ( Mocha ): def index ( self ): name = request . args . get ( \"name\" ) form request.form.get lets you get the data that was sent in a post form class Index ( Mocha ): def index ( self ): name = request . form . get ( \"name\" ) getlist request.form.getlist returns a list of all the items with the same name that was posted in a form < input type = 'checkbox' name = 'options' value = 'apple' > < input type = 'checkbox' name = 'options' value = 'orange' > < input type = 'checkbox' name = 'options' value = 'grapes' > Python class Index ( Mocha ): def index ( self ): my_options = request . form . getlist ( \"options\" ) files.get request.files.get allow you to retrieve a file that was uploaded HTML < input type = file name = \"file\" > Python class Index ( Mocha ): def index ( self ): file = request . files . get ( \"file\" ) files.getlist request.files.getlist allow you to retrieve multiple files uploaded with the same name HTML < input type = file name = \"file\" > < input type = file name = \"file\" > < input type = file name = \"file\" > Python class Index ( Mocha ): def index ( self ): files = request . files . getlist ( \"file\" ) Save uploaded file Here's a snippet on how to upload a file. from mocha import request , upload_file class Index ( Mocha ): @request.post def upload_file ( self ): image_file = request . files . get ( \"file\" ) upload_file ( \"image\" , file )","title":"Request"},{"location":"application/request/#import","text":"from mocha import request","title":"Import"},{"location":"application/request/#methods","text":"","title":"Methods"},{"location":"application/request/#get","text":"@request.get set a view to accept only GET method class Index ( Mocha ) : @ request . get def index ( self ) : # do something","title":"get"},{"location":"application/request/#post","text":"@request.post set a view to accept only POST method class Index ( Mocha ) : @ request . post def index ( self ) : # do something","title":"post"},{"location":"application/request/#put","text":"@request.put set a view to accept only PUT method class Index ( Mocha ) : @ request . put def index ( self ) : # do something","title":"put"},{"location":"application/request/#delete","text":"@request.delete set a view to accept only DELETE method class Index ( Mocha ) : @ request . delete def index ( self ) : # do something","title":"delete"},{"location":"application/request/#all","text":"@request.all set a view to accept only ALL methods. It will accept: GET, POST, PUT, DELETE, OPTIONS class Index ( Mocha ) : @ request . all def index ( self ) : # do something","title":"all"},{"location":"application/request/#combine","text":"An alternative to @all is to use all methods as class Index ( Mocha ) : @ request . get @ request . post @ request . put @ request . delete @ request . options def index ( self ) : # do something","title":"Combine"},{"location":"application/request/#test-method","text":"Usually if a view method accept more than one request method, it is best to test for the method","title":"Test Method"},{"location":"application/request/#is_get","text":"request.IS_GET tests if the request method is GET class Index ( Mocha ) : def index ( self ) : if request . IS_GET : # do something It is equivalent to request.method == 'GET'","title":"IS_GET"},{"location":"application/request/#is_post","text":"request.IS_GET tests if the request method is POST class Index ( Mocha ) : def index ( self ) : if request . IS_POST : # do something It is equivalent to request.method == 'POST' Same as above for PUT and DELETE","title":"IS_POST"},{"location":"application/request/#is_put","text":"","title":"IS_PUT"},{"location":"application/request/#is_delete","text":"","title":"IS_DELETE"},{"location":"application/request/#args-forms","text":"This is already part of Flask. It is added as a reference","title":"Args &amp; Forms"},{"location":"application/request/#args","text":"request.args.get lets you get the query vars # http://127.0.0.1/?name=Mocha class Index ( Mocha ): def index ( self ): name = request . args . get ( \"name\" )","title":"args"},{"location":"application/request/#form","text":"request.form.get lets you get the data that was sent in a post form class Index ( Mocha ): def index ( self ): name = request . form . get ( \"name\" )","title":"form"},{"location":"application/request/#getlist","text":"request.form.getlist returns a list of all the items with the same name that was posted in a form < input type = 'checkbox' name = 'options' value = 'apple' > < input type = 'checkbox' name = 'options' value = 'orange' > < input type = 'checkbox' name = 'options' value = 'grapes' > Python class Index ( Mocha ): def index ( self ): my_options = request . form . getlist ( \"options\" )","title":"getlist"},{"location":"application/request/#filesget","text":"request.files.get allow you to retrieve a file that was uploaded HTML < input type = file name = \"file\" > Python class Index ( Mocha ): def index ( self ): file = request . files . get ( \"file\" )","title":"files.get"},{"location":"application/request/#filesgetlist","text":"request.files.getlist allow you to retrieve multiple files uploaded with the same name HTML < input type = file name = \"file\" > < input type = file name = \"file\" > < input type = file name = \"file\" > Python class Index ( Mocha ): def index ( self ): files = request . files . getlist ( \"file\" )","title":"files.getlist"},{"location":"application/request/#save-uploaded-file","text":"Here's a snippet on how to upload a file. from mocha import request , upload_file class Index ( Mocha ): @request.post def upload_file ( self ): image_file = request . files . get ( \"file\" ) upload_file ( \"image\" , file )","title":"Save uploaded file"},{"location":"application/static/","text":"Path: $$APP_NAME/static/ CONVENTION By convention, Assembly expects you to have one static directory per application. And the file must be named $$APP_NAME/static/ , for it to be loaded automatically.","title":"Static"},{"location":"application/static/#convention","text":"By convention, Assembly expects you to have one static directory per application. And the file must be named $$APP_NAME/static/ , for it to be loaded automatically.","title":"CONVENTION"},{"location":"application/templates/","text":"Path: $$APP_NAME/templates/ CONVENTION By convention, Assembly expects you to have one templates directory per application. And the file must be named $$APP_NAME/templates/ , for it to be loaded automatically.","title":"Templates"},{"location":"application/templates/#convention","text":"By convention, Assembly expects you to have one templates directory per application. And the file must be named $$APP_NAME/templates/ , for it to be loaded automatically.","title":"CONVENTION"},{"location":"application/views/","text":"Path: $$APP_NAME/__views__.py CONVENTION By convention, Assembly expects you to have one view file per application. And the file must be named views .py , for it to be loaded automatically. Examples from assembly import Assembly class Index ( Assembly ): def index ( self ): return","title":"Views"},{"location":"application/views/#convention","text":"By convention, Assembly expects you to have one view file per application. And the file must be named views .py , for it to be loaded automatically. Examples from assembly import Assembly class Index ( Assembly ): def index ( self ): return","title":"CONVENTION"},{"location":"ext/arrow/","text":"Arrow is a Python library that offers a sensible, human-friendly approach to creating, manipulating, formatting and converting dates, times, and timestamps. It implements and updates the datetime type, plugging gaps in functionality, and provides an intelligent module API that supports many common creation scenarios. Simply put, it helps you work with dates and times with fewer imports and a lot less code.","title":"Arrow"},{"location":"ext/bcrypt/","text":"bcrypt from the passlib library is used to hash and verify password. Import from mocha import bcrypt Hash password Hash a password for storage my_string_pass = \"mypass123\" my_hash = bcrypt . hash ( my_string_pass ) Verify password Verify a password by using the string provided to hash, and the hash that was created previously. It returns a bool. bcrypt . verify ( my_string_pass , my_hash ) Config bcrypt can be used with no configuration as it will fall back to its default. But if you want you can have the following config BCRYPT_SALT = \"\" BCRYPT_ROUNDS = 12 BCRYPT_INDENT = \"\"","title":"Bcrypt"},{"location":"ext/bcrypt/#import","text":"from mocha import bcrypt","title":"Import"},{"location":"ext/bcrypt/#hash-password","text":"Hash a password for storage my_string_pass = \"mypass123\" my_hash = bcrypt . hash ( my_string_pass )","title":"Hash password"},{"location":"ext/bcrypt/#verify-password","text":"Verify a password by using the string provided to hash, and the hash that was created previously. It returns a bool. bcrypt . verify ( my_string_pass , my_hash )","title":"Verify password"},{"location":"ext/bcrypt/#config","text":"bcrypt can be used with no configuration as it will fall back to its default. But if you want you can have the following config BCRYPT_SALT = \"\" BCRYPT_ROUNDS = 12 BCRYPT_INDENT = \"\"","title":"Config"},{"location":"ext/cache/","text":"flask_cache is used to cache data. It allows to use different backend, ie: Redis, Memcache, etc. Import from mocha import cache Decorator from mocha import Mocha , cache class Index ( Mocha ): @cache.cached ( 3600 ) def index ( self ): return { } Config #: CACHE_TYPE #: The type of cache to use #: null , simple , redis , filesystem , CACHE_TYPE = \" simple \" #: CACHE_REDIS_URL #: If CHACHE_TYPE is ' redis ' , set the redis uri #: redis : // username : password @ host : port / db CACHE_REDIS_URL = \"\" #: CACHE_DIR #: Directory to store cache if CACHE_TYPE is filesystem , it will CACHE_DIR = \"\" Extension: flask-cache","title":"Cache"},{"location":"ext/cache/#import","text":"from mocha import cache","title":"Import"},{"location":"ext/cache/#decorator","text":"from mocha import Mocha , cache class Index ( Mocha ): @cache.cached ( 3600 ) def index ( self ): return { }","title":"Decorator"},{"location":"ext/cache/#config","text":"#: CACHE_TYPE #: The type of cache to use #: null , simple , redis , filesystem , CACHE_TYPE = \" simple \" #: CACHE_REDIS_URL #: If CHACHE_TYPE is ' redis ' , set the redis uri #: redis : // username : password @ host : port / db CACHE_REDIS_URL = \"\" #: CACHE_DIR #: Directory to store cache if CACHE_TYPE is filesystem , it will CACHE_DIR = \"\" Extension: flask-cache","title":"Config"},{"location":"ext/csrf/","text":"csrf prevents cross-site request forgery (CSRF) on your application Import from mocha import csrf Automatically all POST, UPDATE methods will require a CSRF token, unless explicitly exempt. To exempt and endpoint, jus add the decorator csrf.exempt class Index ( Mocha ) : def index ( self ) : pass @csrf . exempt def exempted_post ( self ) : pass @post () def save_data ( self ) : pass In the example above, when posting to /exempted-post/ it will not require the CSRF token, however /save-data/ requires it. Config CSRF_COOKIE_NAME # _csrf_token CSRF_HEADER_NAME # X - CSRFToken CSRF_DISABLE CSRF_COOKIE_TIMEOUT CSRF_COOKIE_SECURE CSRF_COOKIE_HTTPONLY CSRF_COOKIE_DOMAIN CSRF_CHECK_REFERER SEASURF_INCLUDE_OR_EXEMPT_VIEWS About Extension: flask-seasurf SeaSurf is a Flask extension for preventing cross-site request forgery (CSRF). CSRF vulnerabilities have been found in large and popular sites such as YouTube. These attacks are problematic because the mechanism they use is relatively easy to exploit. This extension attempts to aid you in securing your application from such attacks.","title":"Csrf"},{"location":"ext/csrf/#import","text":"from mocha import csrf Automatically all POST, UPDATE methods will require a CSRF token, unless explicitly exempt. To exempt and endpoint, jus add the decorator csrf.exempt class Index ( Mocha ) : def index ( self ) : pass @csrf . exempt def exempted_post ( self ) : pass @post () def save_data ( self ) : pass In the example above, when posting to /exempted-post/ it will not require the CSRF token, however /save-data/ requires it.","title":"Import"},{"location":"ext/csrf/#config","text":"CSRF_COOKIE_NAME # _csrf_token CSRF_HEADER_NAME # X - CSRFToken CSRF_DISABLE CSRF_COOKIE_TIMEOUT CSRF_COOKIE_SECURE CSRF_COOKIE_HTTPONLY CSRF_COOKIE_DOMAIN CSRF_CHECK_REFERER SEASURF_INCLUDE_OR_EXEMPT_VIEWS About Extension: flask-seasurf SeaSurf is a Flask extension for preventing cross-site request forgery (CSRF). CSRF vulnerabilities have been found in large and popular sites such as YouTube. These attacks are problematic because the mechanism they use is relatively easy to exploit. This extension attempts to aid you in securing your application from such attacks.","title":"Config"},{"location":"ext/mail/","text":"Mail exposes an interface to send email via SMTP or AWS SES. Import from mocha import send_mail Send Mail Send mail helps you quickly send emails. template = \"\" to = \"me@email.com\" send_email ( template = template , to = to ) Mail signals observer from mocha import signals @signals.send_email.observe def my_email_observer (): pass Mail interface from mocha.ext import mail Config # AWS SES # To use AWS SES to send email #: #: - To use the default AWS credentials ( AWS_ACCESS_KEY_ID , AWS_SECRET_ACCESS_KEY ) #: set MAIL_URI = \" ses:// \" #: * To use a different credential : #: set MAIL_URI = \" ses://{access_key}:{secret_key}@{region} \" #: #: *** uncomment if you are using SMTP instead MAIL_URI = \" ses:// \" # SMTP #: If you are using SMTP , it will use Flask - Mail #: The uri for the smtp connection . It will use Flask - Mail #: format : smtp : // USERNAME : PASSWORD @ HOST : PORT #: with sll -> smtp + ssl : // USERNAME : PASSWORD @ HOST : PORT #: with ssl and tls -> smtp + ssl + tls : // USERNAME : PASSWORD @ HOST : PORT #: #: *** comment out if you are using SES instead # MAIL_URI = \" smtp+ssl://{username}:{password}@{host}:{port} \" \\ # . format ( username = \"\" , password = \"\" , host = \" smtp.gmail.com \" , port = 465 ) #: MAIL_SENDER - The sender of the email by default #: For SES , this email must be authorized MAIL_SENDER = APPLICATION_ADMIN_EMAIL #: MAIL_REPLY_TO #: The email to reply to by default MAIL_REPLY_TO = APPLICATION_ADMIN_EMAIL #: MAIL_TEMPLATE #: a directory that contains the email template or a dict MAIL_TEMPLATE = os . path . join ( APPLICATION_DATA_DIR , \" mail-templates \" ) #: MAIL_TEMPLATE_CONTEXT #: a dict of all context to pass to the email by default MAIL_TEMPLATE_CONTEXT = { \" site_name \" : APPLICATION_NAME , \" site_url \" : APPLICATION_URL } As a convenience, you can use send_email() to send email. from mocha import Mocha , send_email class Index ( Mocha ): @post () def send (): recipient = \"email@email.com\" sender = request . form . get ( \"sender\" ) subject = \"Welcome\" mail . send ( to = recipient , sender = sender , subject = subet ) Extension: ses-mailer Extension: flask-mail","title":"Mail"},{"location":"ext/mail/#import","text":"from mocha import send_mail","title":"Import"},{"location":"ext/mail/#send-mail","text":"Send mail helps you quickly send emails. template = \"\" to = \"me@email.com\" send_email ( template = template , to = to )","title":"Send Mail"},{"location":"ext/mail/#mail-signals-observer","text":"from mocha import signals @signals.send_email.observe def my_email_observer (): pass","title":"Mail signals observer"},{"location":"ext/mail/#mail-interface","text":"from mocha.ext import mail","title":"Mail interface"},{"location":"ext/mail/#config","text":"# AWS SES # To use AWS SES to send email #: #: - To use the default AWS credentials ( AWS_ACCESS_KEY_ID , AWS_SECRET_ACCESS_KEY ) #: set MAIL_URI = \" ses:// \" #: * To use a different credential : #: set MAIL_URI = \" ses://{access_key}:{secret_key}@{region} \" #: #: *** uncomment if you are using SMTP instead MAIL_URI = \" ses:// \" # SMTP #: If you are using SMTP , it will use Flask - Mail #: The uri for the smtp connection . It will use Flask - Mail #: format : smtp : // USERNAME : PASSWORD @ HOST : PORT #: with sll -> smtp + ssl : // USERNAME : PASSWORD @ HOST : PORT #: with ssl and tls -> smtp + ssl + tls : // USERNAME : PASSWORD @ HOST : PORT #: #: *** comment out if you are using SES instead # MAIL_URI = \" smtp+ssl://{username}:{password}@{host}:{port} \" \\ # . format ( username = \"\" , password = \"\" , host = \" smtp.gmail.com \" , port = 465 ) #: MAIL_SENDER - The sender of the email by default #: For SES , this email must be authorized MAIL_SENDER = APPLICATION_ADMIN_EMAIL #: MAIL_REPLY_TO #: The email to reply to by default MAIL_REPLY_TO = APPLICATION_ADMIN_EMAIL #: MAIL_TEMPLATE #: a directory that contains the email template or a dict MAIL_TEMPLATE = os . path . join ( APPLICATION_DATA_DIR , \" mail-templates \" ) #: MAIL_TEMPLATE_CONTEXT #: a dict of all context to pass to the email by default MAIL_TEMPLATE_CONTEXT = { \" site_name \" : APPLICATION_NAME , \" site_url \" : APPLICATION_URL } As a convenience, you can use send_email() to send email. from mocha import Mocha , send_email class Index ( Mocha ): @post () def send (): recipient = \"email@email.com\" sender = request . form . get ( \"sender\" ) subject = \"Welcome\" mail . send ( to = recipient , sender = sender , subject = subet ) Extension: ses-mailer Extension: flask-mail","title":"Config"},{"location":"ext/recaptcha/","text":"Recaptcha implements the Google recaptcha in your application. Import from mocha import recaptcha Implement in Jinja To include the recaptcha in your template add the code below {{ recaptcha }} Verify code class Index ( Mocha ) : def send_data ( self ) : if recaptcha . verify () : # everythings is ok else : # FAILED Config # : Flask - Recaptcha # : Register your application at https : // www . google . com / recaptcha / admin # : RECAPTCHA_ENABLED RECAPTCHA_ENABLED = True # : RECAPTCHA_SITE_KEY RECAPTCHA_SITE_KEY = \"\" # : RECAPTCHA_SECRET_KEY RECAPTCHA_SECRET_KEY = \"\" Extension: flask-recaptcha To register your application go https://www.google.com/recaptcha/admin","title":"Recaptcha"},{"location":"ext/recaptcha/#import","text":"from mocha import recaptcha","title":"Import"},{"location":"ext/recaptcha/#implement-in-jinja","text":"To include the recaptcha in your template add the code below {{ recaptcha }}","title":"Implement in Jinja"},{"location":"ext/recaptcha/#verify-code","text":"class Index ( Mocha ) : def send_data ( self ) : if recaptcha . verify () : # everythings is ok else : # FAILED","title":"Verify code"},{"location":"ext/recaptcha/#config","text":"# : Flask - Recaptcha # : Register your application at https : // www . google . com / recaptcha / admin # : RECAPTCHA_ENABLED RECAPTCHA_ENABLED = True # : RECAPTCHA_SITE_KEY RECAPTCHA_SITE_KEY = \"\" # : RECAPTCHA_SECRET_KEY RECAPTCHA_SECRET_KEY = \"\" Extension: flask-recaptcha To register your application go https://www.google.com/recaptcha/admin","title":"Config"},{"location":"ext/storage/","text":"storage Allows you to to access, upload, download, save and delete files on cloud storage providers such as: AWS S3, Google Storage, Microsoft Azure, Rackspace Cloudfiles, and even Local file system Import from mocha import storage Upload File Delete File Config Edit the keys below in your config class file: #: STORAGE_PROVIDER : # The provider to use . By default it ' s ' LOCAL ' . # You can use : # LOCAL , S3 , GOOGLE_STORAGE , AZURE_BLOBS , CLOUDFILES STORAGE_PROVIDER = \" LOCAL \" #: STORAGE_KEY # The storage key . Leave it blank if PROVIDER is LOCAL STORAGE_KEY = AWS_ACCESS_KEY_ID #: STORAGE_SECRET #: The storage secret key . Leave it blank if PROVIDER is LOCAL STORAGE_SECRET = AWS_SECRET_ACCESS_KEY #: STORAGE_REGION_NAME #: The region for the storage . Leave it blank if PROVIDER is LOCAL STORAGE_REGION_NAME = AWS_REGION_NAME #: STORAGE_CONTAINER #: The Bucket name ( for S3 , Google storage , Azure , cloudfile ) #: or the directory name ( LOCAL ) to access STORAGE_CONTAINER = os . path . join ( APPLICATION_DATA_DIR , \" uploads \" ) #: STORAGE_SERVER #: Bool , to serve local file STORAGE_SERVER = True #: STORAGE_SERVER_URL #: The url suffix for local storage STORAGE_SERVER_URL = \" files \" storage.get Allows you to get a file from the storage my_file = storage . get ( \" myfile.jpg \" ) my_file . name # return The file name my_file . size # returns file size storage.upload","title":"Storage"},{"location":"ext/storage/#storage","text":"Allows you to to access, upload, download, save and delete files on cloud storage providers such as: AWS S3, Google Storage, Microsoft Azure, Rackspace Cloudfiles, and even Local file system","title":"storage"},{"location":"ext/storage/#import","text":"from mocha import storage","title":"Import"},{"location":"ext/storage/#upload-file","text":"","title":"Upload File"},{"location":"ext/storage/#delete-file","text":"","title":"Delete File"},{"location":"ext/storage/#config","text":"Edit the keys below in your config class file: #: STORAGE_PROVIDER : # The provider to use . By default it ' s ' LOCAL ' . # You can use : # LOCAL , S3 , GOOGLE_STORAGE , AZURE_BLOBS , CLOUDFILES STORAGE_PROVIDER = \" LOCAL \" #: STORAGE_KEY # The storage key . Leave it blank if PROVIDER is LOCAL STORAGE_KEY = AWS_ACCESS_KEY_ID #: STORAGE_SECRET #: The storage secret key . Leave it blank if PROVIDER is LOCAL STORAGE_SECRET = AWS_SECRET_ACCESS_KEY #: STORAGE_REGION_NAME #: The region for the storage . Leave it blank if PROVIDER is LOCAL STORAGE_REGION_NAME = AWS_REGION_NAME #: STORAGE_CONTAINER #: The Bucket name ( for S3 , Google storage , Azure , cloudfile ) #: or the directory name ( LOCAL ) to access STORAGE_CONTAINER = os . path . join ( APPLICATION_DATA_DIR , \" uploads \" ) #: STORAGE_SERVER #: Bool , to serve local file STORAGE_SERVER = True #: STORAGE_SERVER_URL #: The url suffix for local storage STORAGE_SERVER_URL = \" files \"","title":"Config"},{"location":"ext/storage/#storageget","text":"Allows you to get a file from the storage my_file = storage . get ( \" myfile.jpg \" ) my_file . name # return The file name my_file . size # returns file size","title":"storage.get"},{"location":"ext/storage/#storageupload","text":"","title":"storage.upload"}]}